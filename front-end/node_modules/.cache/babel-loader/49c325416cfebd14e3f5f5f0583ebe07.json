{"ast":null,"code":"'use strict';\n\nconst mergeOptions = require('merge-options').bind({\n  ignoreUndefined: true\n});\n\nconst toMfsPath = require('./utils/to-mfs-path');\n\nconst log = require('debug')('ipfs:mfs:touch');\n\nconst errCode = require('err-code');\n\nconst {\n  UnixFS\n} = require('ipfs-unixfs');\n\nconst toTrail = require('./utils/to-trail');\n\nconst addLink = require('./utils/add-link');\n\nconst updateTree = require('./utils/update-tree');\n\nconst updateMfsRoot = require('./utils/update-mfs-root');\n\nconst dagPb = require('@ipld/dag-pb');\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst {\n  importer\n} = require('ipfs-unixfs-importer');\n\nconst {\n  recursive\n} = require('ipfs-unixfs-exporter');\n\nconst last = require('it-last');\n\nconst cp = require('./cp');\n\nconst rm = require('./rm');\n\nconst persist = require('./utils/persist');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n/**\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n * @typedef {import('./').MfsContext} MfsContext\n *\n * @typedef {object} DefaultOptions\n * @property {boolean} flush\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {number} shardSplitThreshold\n * @property {boolean} recursive\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\n\n\nconst defaultOptions = {\n  flush: true,\n  shardSplitThreshold: 1000,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  recursive: false\n};\n/**\n * @param {string} mode\n * @param {number} originalMode\n * @param {boolean} isDirectory\n */\n\nfunction calculateModification(mode, originalMode, isDirectory) {\n  let modification = 0;\n\n  if (mode.includes('x') || mode.includes('X') && (isDirectory || originalMode & 0o1 || originalMode & 0o10 || originalMode & 0o100)) {\n    modification += 1;\n  }\n\n  if (mode.includes('w')) {\n    modification += 2;\n  }\n\n  if (mode.includes('r')) {\n    modification += 4;\n  }\n\n  return modification;\n}\n/**\n * @param {string} references\n * @param {number} modification\n */\n\n\nfunction calculateUGO(references, modification) {\n  let ugo = 0;\n\n  if (references.includes('u')) {\n    ugo += modification << 6;\n  }\n\n  if (references.includes('g')) {\n    ugo += modification << 3;\n  }\n\n  if (references.includes('o')) {\n    ugo += modification;\n  }\n\n  return ugo;\n}\n/**\n * @param {string} references\n * @param {string} mode\n * @param {number} modification\n */\n\n\nfunction calculateSpecial(references, mode, modification) {\n  if (mode.includes('t')) {\n    modification += parseInt('1000', 8);\n  }\n\n  if (mode.includes('s')) {\n    if (references.includes('u')) {\n      modification += parseInt('4000', 8);\n    }\n\n    if (references.includes('g')) {\n      modification += parseInt('2000', 8);\n    }\n  }\n\n  return modification;\n}\n/**\n * https://en.wikipedia.org/wiki/Chmod#Symbolic_modes\n *\n * @param {string} input\n * @param {number} originalMode\n * @param {boolean} isDirectory\n */\n\n\nfunction parseSymbolicMode(input, originalMode, isDirectory) {\n  if (!originalMode) {\n    originalMode = 0;\n  }\n\n  const match = input.match(/^(u?g?o?a?)(-?\\+?=?)?(r?w?x?X?s?t?)$/);\n\n  if (!match) {\n    throw new Error(`Invalid file mode: ${input}`);\n  }\n\n  let [, references, operator, mode] = match;\n\n  if (references === 'a' || !references) {\n    references = 'ugo';\n  }\n\n  let modification = calculateModification(mode, originalMode, isDirectory);\n  modification = calculateUGO(references, modification);\n  modification = calculateSpecial(references, mode, modification);\n\n  if (operator === '=') {\n    if (references.includes('u')) {\n      // blank u bits\n      originalMode = originalMode & parseInt('7077', 8); // or them together\n\n      originalMode = originalMode | modification;\n    }\n\n    if (references.includes('g')) {\n      // blank g bits\n      originalMode = originalMode & parseInt('7707', 8); // or them together\n\n      originalMode = originalMode | modification;\n    }\n\n    if (references.includes('o')) {\n      // blank o bits\n      originalMode = originalMode & parseInt('7770', 8); // or them together\n\n      originalMode = originalMode | modification;\n    }\n\n    return originalMode;\n  }\n\n  if (operator === '+') {\n    return modification | originalMode;\n  }\n\n  if (operator === '-') {\n    return modification ^ originalMode;\n  }\n\n  return originalMode;\n}\n/**\n * @param {string | InstanceType<typeof window.String> | number} mode\n * @param {UnixFS} metadata\n * @returns {number}\n */\n\n\nfunction calculateMode(mode, metadata) {\n  if (mode instanceof String || typeof mode === 'string') {\n    const strMode = `${mode}`;\n\n    if (strMode.match(/^\\d+$/g)) {\n      mode = parseInt(strMode, 8);\n    } else {\n      // @ts-ignore freaks out over the curr: number, acc: string thing\n      mode = 0 + strMode.split(',').reduce((curr, acc) => {\n        return parseSymbolicMode(acc, curr, metadata.isDirectory());\n      }, metadata.mode || 0);\n    }\n  }\n\n  return mode;\n}\n/**\n * @param {MfsContext} context\n */\n\n\nmodule.exports = context => {\n  /**\n   * @type {import('ipfs-core-types/src/files').API[\"chmod\"]}\n   */\n  async function mfsChmod(path, mode, options = {}) {\n    /** @type {DefaultOptions} */\n    const opts = mergeOptions(defaultOptions, options);\n    log(`Fetching stats for ${path}`);\n    const {\n      cid,\n      mfsDirectory,\n      name\n    } = await toMfsPath(context, path, opts);\n\n    if (cid.code !== dagPb.code) {\n      throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS');\n    }\n\n    if (opts.recursive) {\n      // recursively export from root CID, change perms of each entry then reimport\n      // but do not reimport files, only manipulate dag-pb nodes\n      const root = await pipe(async function* () {\n        for await (const entry of recursive(cid, context.repo.blocks)) {\n          if (entry.type !== 'file' && entry.type !== 'directory') {\n            throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS');\n          }\n\n          entry.unixfs.mode = calculateMode(mode, entry.unixfs);\n          const node = dagPb.prepare({\n            Data: entry.unixfs.marshal(),\n            Links: entry.node.Links\n          });\n          yield {\n            path: entry.path,\n            content: node\n          };\n        }\n      }, // @ts-ignore we account for the incompatible source type with our custom dag builder below\n      source => importer(source, context.repo.blocks, { ...opts,\n        pin: false,\n        dagBuilder: async function* (source, block, opts) {\n          for await (const entry of source) {\n            yield async function () {\n              /** @type {PBNode} */\n              // @ts-ignore - cannot derive type\n              const node = entry.content;\n              const buf = dagPb.encode(node);\n              const cid = await persist(buf, block, opts);\n\n              if (!node.Data) {\n                throw errCode(new Error(`${cid} had no data`), 'ERR_INVALID_NODE');\n              }\n\n              const unixfs = UnixFS.unmarshal(node.Data);\n              return {\n                cid,\n                size: buf.length,\n                path: entry.path,\n                unixfs\n              };\n            };\n          }\n        }\n      }), nodes => last(nodes));\n\n      if (!root) {\n        throw errCode(new Error(`Could not chmod ${path}`), 'ERR_COULD_NOT_CHMOD');\n      } // remove old path from mfs\n\n\n      await rm(context)(path, opts); // add newly created tree to mfs at path\n\n      await cp(context)(`/ipfs/${root.cid}`, path, opts);\n      return;\n    }\n\n    const block = await context.repo.blocks.get(cid);\n    const node = dagPb.decode(block);\n\n    if (!node.Data) {\n      throw errCode(new Error(`${cid} had no data`), 'ERR_INVALID_NODE');\n    }\n\n    const metadata = UnixFS.unmarshal(node.Data);\n    metadata.mode = calculateMode(mode, metadata);\n    const updatedBlock = dagPb.encode({\n      Data: metadata.marshal(),\n      Links: node.Links\n    });\n    const hashAlg = opts.hashAlg || defaultOptions.hashAlg;\n    const hasher = await context.hashers.getHasher(hashAlg);\n    const hash = await hasher.digest(updatedBlock);\n    const updatedCid = CID.create(opts.cidVersion, dagPb.code, hash);\n\n    if (opts.flush) {\n      await context.repo.blocks.put(updatedCid, updatedBlock);\n    }\n\n    const trail = await toTrail(context, mfsDirectory);\n    const parent = trail[trail.length - 1];\n    const parentCid = CID.decode(parent.cid.bytes);\n    const parentBlock = await context.repo.blocks.get(parentCid);\n    const parentNode = dagPb.decode(parentBlock);\n    const result = await addLink(context, {\n      parent: parentNode,\n      name: name,\n      cid: updatedCid,\n      size: updatedBlock.length,\n      flush: opts.flush,\n      // TODO vmx 2021-03-29: decide on the API, whether it should be a `hashAlg` or `hasher`\n      hashAlg,\n      cidVersion: cid.version,\n      shardSplitThreshold: Infinity\n    });\n    parent.cid = result.cid; // update the tree with the new child\n\n    const newRootCid = await updateTree(context, trail, opts); // Update the MFS record with the new CID for the root of the tree\n\n    await updateMfsRoot(context, newRootCid, opts);\n  }\n\n  return withTimeoutOption(mfsChmod);\n};","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/ipfs-core/src/components/files/chmod.js"],"names":["mergeOptions","require","bind","ignoreUndefined","toMfsPath","log","errCode","UnixFS","toTrail","addLink","updateTree","updateMfsRoot","dagPb","CID","pipe","importer","recursive","last","cp","rm","persist","withTimeoutOption","defaultOptions","flush","shardSplitThreshold","hashAlg","cidVersion","calculateModification","mode","originalMode","isDirectory","modification","includes","calculateUGO","references","ugo","calculateSpecial","parseInt","parseSymbolicMode","input","match","Error","operator","calculateMode","metadata","String","strMode","split","reduce","curr","acc","module","exports","context","mfsChmod","path","options","opts","cid","mfsDirectory","name","code","root","entry","repo","blocks","type","unixfs","node","prepare","Data","marshal","Links","content","source","pin","dagBuilder","block","buf","encode","unmarshal","size","length","nodes","get","decode","updatedBlock","hasher","hashers","getHasher","hash","digest","updatedCid","create","put","trail","parent","parentCid","bytes","parentBlock","parentNode","result","version","Infinity","newRootCid"],"mappings":"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","sourcesContent":["'use strict'\n\nconst mergeOptions = require('merge-options').bind({ ignoreUndefined: true })\nconst toMfsPath = require('./utils/to-mfs-path')\nconst log = require('debug')('ipfs:mfs:touch')\nconst errCode = require('err-code')\nconst { UnixFS } = require('ipfs-unixfs')\nconst toTrail = require('./utils/to-trail')\nconst addLink = require('./utils/add-link')\nconst updateTree = require('./utils/update-tree')\nconst updateMfsRoot = require('./utils/update-mfs-root')\nconst dagPb = require('@ipld/dag-pb')\nconst { CID } = require('multiformats/cid')\nconst { pipe } = require('it-pipe')\nconst { importer } = require('ipfs-unixfs-importer')\nconst { recursive } = require('ipfs-unixfs-exporter')\nconst last = require('it-last')\nconst cp = require('./cp')\nconst rm = require('./rm')\nconst persist = require('./utils/persist')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\n\n/**\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n * @typedef {import('./').MfsContext} MfsContext\n *\n * @typedef {object} DefaultOptions\n * @property {boolean} flush\n * @property {string} hashAlg\n * @property {CIDVersion} cidVersion\n * @property {number} shardSplitThreshold\n * @property {boolean} recursive\n * @property {AbortSignal} [signal]\n * @property {number} [timeout]\n */\n\n/**\n * @type {DefaultOptions}\n */\nconst defaultOptions = {\n  flush: true,\n  shardSplitThreshold: 1000,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  recursive: false\n}\n\n/**\n * @param {string} mode\n * @param {number} originalMode\n * @param {boolean} isDirectory\n */\nfunction calculateModification (mode, originalMode, isDirectory) {\n  let modification = 0\n\n  if (mode.includes('x') || (mode.includes('X') && (isDirectory || (originalMode & 0o1 || originalMode & 0o10 || originalMode & 0o100)))) {\n    modification += 1\n  }\n\n  if (mode.includes('w')) {\n    modification += 2\n  }\n\n  if (mode.includes('r')) {\n    modification += 4\n  }\n\n  return modification\n}\n\n/**\n * @param {string} references\n * @param {number} modification\n */\nfunction calculateUGO (references, modification) {\n  let ugo = 0\n\n  if (references.includes('u')) {\n    ugo += (modification << 6)\n  }\n\n  if (references.includes('g')) {\n    ugo += (modification << 3)\n  }\n\n  if (references.includes('o')) {\n    ugo += (modification)\n  }\n\n  return ugo\n}\n\n/**\n * @param {string} references\n * @param {string} mode\n * @param {number} modification\n */\nfunction calculateSpecial (references, mode, modification) {\n  if (mode.includes('t')) {\n    modification += parseInt('1000', 8)\n  }\n\n  if (mode.includes('s')) {\n    if (references.includes('u')) {\n      modification += parseInt('4000', 8)\n    }\n\n    if (references.includes('g')) {\n      modification += parseInt('2000', 8)\n    }\n  }\n\n  return modification\n}\n\n/**\n * https://en.wikipedia.org/wiki/Chmod#Symbolic_modes\n *\n * @param {string} input\n * @param {number} originalMode\n * @param {boolean} isDirectory\n */\nfunction parseSymbolicMode (input, originalMode, isDirectory) {\n  if (!originalMode) {\n    originalMode = 0\n  }\n\n  const match = input.match(/^(u?g?o?a?)(-?\\+?=?)?(r?w?x?X?s?t?)$/)\n\n  if (!match) {\n    throw new Error(`Invalid file mode: ${input}`)\n  }\n\n  let [\n    ,\n    references,\n    operator,\n    mode\n  ] = match\n\n  if (references === 'a' || !references) {\n    references = 'ugo'\n  }\n\n  let modification = calculateModification(mode, originalMode, isDirectory)\n  modification = calculateUGO(references, modification)\n  modification = calculateSpecial(references, mode, modification)\n\n  if (operator === '=') {\n    if (references.includes('u')) {\n      // blank u bits\n      originalMode = originalMode & parseInt('7077', 8)\n\n      // or them together\n      originalMode = originalMode | modification\n    }\n\n    if (references.includes('g')) {\n      // blank g bits\n      originalMode = originalMode & parseInt('7707', 8)\n\n      // or them together\n      originalMode = originalMode | modification\n    }\n\n    if (references.includes('o')) {\n      // blank o bits\n      originalMode = originalMode & parseInt('7770', 8)\n\n      // or them together\n      originalMode = originalMode | modification\n    }\n\n    return originalMode\n  }\n\n  if (operator === '+') {\n    return modification | originalMode\n  }\n\n  if (operator === '-') {\n    return modification ^ originalMode\n  }\n\n  return originalMode\n}\n\n/**\n * @param {string | InstanceType<typeof window.String> | number} mode\n * @param {UnixFS} metadata\n * @returns {number}\n */\nfunction calculateMode (mode, metadata) {\n  if (mode instanceof String || typeof mode === 'string') {\n    const strMode = `${mode}`\n\n    if (strMode.match(/^\\d+$/g)) {\n      mode = parseInt(strMode, 8)\n    } else {\n      // @ts-ignore freaks out over the curr: number, acc: string thing\n      mode = 0 + strMode.split(',').reduce((curr, acc) => {\n        return parseSymbolicMode(acc, curr, metadata.isDirectory())\n      }, metadata.mode || 0)\n    }\n  }\n\n  return mode\n}\n\n/**\n * @param {MfsContext} context\n */\nmodule.exports = (context) => {\n  /**\n   * @type {import('ipfs-core-types/src/files').API[\"chmod\"]}\n   */\n  async function mfsChmod (path, mode, options = {}) {\n    /** @type {DefaultOptions} */\n    const opts = mergeOptions(defaultOptions, options)\n\n    log(`Fetching stats for ${path}`)\n\n    const {\n      cid,\n      mfsDirectory,\n      name\n    } = await toMfsPath(context, path, opts)\n\n    if (cid.code !== dagPb.code) {\n      throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS')\n    }\n\n    if (opts.recursive) {\n      // recursively export from root CID, change perms of each entry then reimport\n      // but do not reimport files, only manipulate dag-pb nodes\n      const root = await pipe(\n        async function * () {\n          for await (const entry of recursive(cid, context.repo.blocks)) {\n            if (entry.type !== 'file' && entry.type !== 'directory') {\n              throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS')\n            }\n\n            entry.unixfs.mode = calculateMode(mode, entry.unixfs)\n\n            const node = dagPb.prepare({\n              Data: entry.unixfs.marshal(),\n              Links: entry.node.Links\n            })\n\n            yield {\n              path: entry.path,\n              content: node\n            }\n          }\n        },\n        // @ts-ignore we account for the incompatible source type with our custom dag builder below\n        (source) => importer(source, context.repo.blocks, {\n          ...opts,\n          pin: false,\n          dagBuilder: async function * (source, block, opts) {\n            for await (const entry of source) {\n              yield async function () {\n                /** @type {PBNode} */\n                // @ts-ignore - cannot derive type\n                const node = entry.content\n\n                const buf = dagPb.encode(node)\n                const cid = await persist(buf, block, opts)\n\n                if (!node.Data) {\n                  throw errCode(new Error(`${cid} had no data`), 'ERR_INVALID_NODE')\n                }\n\n                const unixfs = UnixFS.unmarshal(node.Data)\n\n                return {\n                  cid,\n                  size: buf.length,\n                  path: entry.path,\n                  unixfs\n                }\n              }\n            }\n          }\n        }),\n        (nodes) => last(nodes)\n      )\n\n      if (!root) {\n        throw errCode(new Error(`Could not chmod ${path}`), 'ERR_COULD_NOT_CHMOD')\n      }\n\n      // remove old path from mfs\n      await rm(context)(path, opts)\n\n      // add newly created tree to mfs at path\n      await cp(context)(`/ipfs/${root.cid}`, path, opts)\n\n      return\n    }\n\n    const block = await context.repo.blocks.get(cid)\n    const node = dagPb.decode(block)\n\n    if (!node.Data) {\n      throw errCode(new Error(`${cid} had no data`), 'ERR_INVALID_NODE')\n    }\n\n    const metadata = UnixFS.unmarshal(node.Data)\n    metadata.mode = calculateMode(mode, metadata)\n    const updatedBlock = dagPb.encode({\n      Data: metadata.marshal(),\n      Links: node.Links\n    })\n\n    const hashAlg = opts.hashAlg || defaultOptions.hashAlg\n    const hasher = await context.hashers.getHasher(hashAlg)\n    const hash = await hasher.digest(updatedBlock)\n    const updatedCid = CID.create(opts.cidVersion, dagPb.code, hash)\n\n    if (opts.flush) {\n      await context.repo.blocks.put(updatedCid, updatedBlock)\n    }\n\n    const trail = await toTrail(context, mfsDirectory)\n    const parent = trail[trail.length - 1]\n    const parentCid = CID.decode(parent.cid.bytes)\n    const parentBlock = await context.repo.blocks.get(parentCid)\n    const parentNode = dagPb.decode(parentBlock)\n\n    const result = await addLink(context, {\n      parent: parentNode,\n      name: name,\n      cid: updatedCid,\n      size: updatedBlock.length,\n      flush: opts.flush,\n      // TODO vmx 2021-03-29: decide on the API, whether it should be a `hashAlg` or `hasher`\n      hashAlg,\n      cidVersion: cid.version,\n      shardSplitThreshold: Infinity\n    })\n\n    parent.cid = result.cid\n\n    // update the tree with the new child\n    const newRootCid = await updateTree(context, trail, opts)\n\n    // Update the MFS record with the new CID for the root of the tree\n    await updateMfsRoot(context, newRootCid, opts)\n  }\n\n  return withTimeoutOption(mfsChmod)\n}\n"]},"metadata":{},"sourceType":"script"}