{"ast":null,"code":"'use strict';\n\nconst errCode = require('err-code');\n\nconst filter = require('it-filter');\n\nconst map = require('it-map');\n\nconst take = require('it-take');\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * Store the multiaddrs from every peer in the passed peer store\n *\n * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source\n * @param {import('../peer-store')} peerStore\n */\n\n\nfunction storeAddresses(source, peerStore) {\n  return map(source, peer => {\n    // ensure we have the addresses for a given peer\n    peerStore.addressBook.add(peer.id, peer.multiaddrs);\n    return peer;\n  });\n}\n/**\n * Filter peers by unique peer id\n *\n * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source\n */\n\n\nfunction uniquePeers(source) {\n  /** @type Set<string> */\n  const seen = new Set();\n  return filter(source, peer => {\n    // dedupe by peer id\n    if (seen.has(peer.id.toString())) {\n      return false;\n    }\n\n    seen.add(peer.id.toString());\n    return true;\n  });\n}\n/**\n * Require at least `min` peers to be yielded from `source`\n *\n * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source\n * @param {number} min\n */\n\n\nasync function* requirePeers(source, min = 1) {\n  let seen = 0;\n\n  for await (const peer of source) {\n    seen++;\n    yield peer;\n  }\n\n  if (seen < min) {\n    throw errCode(new Error('not found'), 'NOT_FOUND');\n  }\n}\n/**\n * If `max` is passed, only take that number of peers from the source\n * otherwise take all the peers\n *\n * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source\n * @param {number} [max]\n */\n\n\nfunction maybeLimitSource(source, max) {\n  if (max) {\n    return take(source, max);\n  }\n\n  return source;\n}\n\nmodule.exports = {\n  storeAddresses,\n  uniquePeers,\n  requirePeers,\n  maybeLimitSource\n};","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/libp2p/src/content-routing/utils.js"],"names":["errCode","require","filter","map","take","storeAddresses","source","peerStore","peer","addressBook","add","id","multiaddrs","uniquePeers","seen","Set","has","toString","requirePeers","min","Error","maybeLimitSource","max","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,WAAD,CAAtB;;AACA,MAAME,GAAG,GAAGF,OAAO,CAAC,QAAD,CAAnB;;AACA,MAAMG,IAAI,GAAGH,OAAO,CAAC,SAAD,CAApB;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASI,cAAT,CAAyBC,MAAzB,EAAiCC,SAAjC,EAA4C;AAC1C,SAAOJ,GAAG,CAACG,MAAD,EAAUE,IAAD,IAAU;AAC3B;AACAD,IAAAA,SAAS,CAACE,WAAV,CAAsBC,GAAtB,CAA0BF,IAAI,CAACG,EAA/B,EAAmCH,IAAI,CAACI,UAAxC;AAEA,WAAOJ,IAAP;AACD,GALS,CAAV;AAMD;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASK,WAAT,CAAsBP,MAAtB,EAA8B;AAC5B;AACA,QAAMQ,IAAI,GAAG,IAAIC,GAAJ,EAAb;AAEA,SAAOb,MAAM,CAACI,MAAD,EAAUE,IAAD,IAAU;AAC9B;AACA,QAAIM,IAAI,CAACE,GAAL,CAASR,IAAI,CAACG,EAAL,CAAQM,QAAR,EAAT,CAAJ,EAAkC;AAChC,aAAO,KAAP;AACD;;AAEDH,IAAAA,IAAI,CAACJ,GAAL,CAASF,IAAI,CAACG,EAAL,CAAQM,QAAR,EAAT;AAEA,WAAO,IAAP;AACD,GATY,CAAb;AAUD;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,gBAAiBC,YAAjB,CAA+BZ,MAA/B,EAAuCa,GAAG,GAAG,CAA7C,EAAgD;AAC9C,MAAIL,IAAI,GAAG,CAAX;;AAEA,aAAW,MAAMN,IAAjB,IAAyBF,MAAzB,EAAiC;AAC/BQ,IAAAA,IAAI;AAEJ,UAAMN,IAAN;AACD;;AAED,MAAIM,IAAI,GAAGK,GAAX,EAAgB;AACd,UAAMnB,OAAO,CAAC,IAAIoB,KAAJ,CAAU,WAAV,CAAD,EAAyB,WAAzB,CAAb;AACD;AACF;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,gBAAT,CAA2Bf,MAA3B,EAAmCgB,GAAnC,EAAwC;AACtC,MAAIA,GAAJ,EAAS;AACP,WAAOlB,IAAI,CAACE,MAAD,EAASgB,GAAT,CAAX;AACD;;AAED,SAAOhB,MAAP;AACD;;AAEDiB,MAAM,CAACC,OAAP,GAAiB;AACfnB,EAAAA,cADe;AAEfQ,EAAAA,WAFe;AAGfK,EAAAA,YAHe;AAIfG,EAAAA;AAJe,CAAjB","sourcesContent":["'use strict'\n\nconst errCode = require('err-code')\nconst filter = require('it-filter')\nconst map = require('it-map')\nconst take = require('it-take')\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * Store the multiaddrs from every peer in the passed peer store\n *\n * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source\n * @param {import('../peer-store')} peerStore\n */\nfunction storeAddresses (source, peerStore) {\n  return map(source, (peer) => {\n    // ensure we have the addresses for a given peer\n    peerStore.addressBook.add(peer.id, peer.multiaddrs)\n\n    return peer\n  })\n}\n\n/**\n * Filter peers by unique peer id\n *\n * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source\n */\nfunction uniquePeers (source) {\n  /** @type Set<string> */\n  const seen = new Set()\n\n  return filter(source, (peer) => {\n    // dedupe by peer id\n    if (seen.has(peer.id.toString())) {\n      return false\n    }\n\n    seen.add(peer.id.toString())\n\n    return true\n  })\n}\n\n/**\n * Require at least `min` peers to be yielded from `source`\n *\n * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source\n * @param {number} min\n */\nasync function * requirePeers (source, min = 1) {\n  let seen = 0\n\n  for await (const peer of source) {\n    seen++\n\n    yield peer\n  }\n\n  if (seen < min) {\n    throw errCode(new Error('not found'), 'NOT_FOUND')\n  }\n}\n\n/**\n * If `max` is passed, only take that number of peers from the source\n * otherwise take all the peers\n *\n * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source\n * @param {number} [max]\n */\nfunction maybeLimitSource (source, max) {\n  if (max) {\n    return take(source, max)\n  }\n\n  return source\n}\n\nmodule.exports = {\n  storeAddresses,\n  uniquePeers,\n  requirePeers,\n  maybeLimitSource\n}\n"]},"metadata":{},"sourceType":"script"}