{"ast":null,"code":"'use strict';\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst {\n  ipfs: {\n    pin: {\n      Set: PinSet\n    }\n  }\n} = require('./pin'); // @ts-ignore\n\n\nconst fnv1a = require('fnv1a');\n\nconst varint = require('varint');\n\nconst dagPb = require('@ipld/dag-pb');\n\nconst {\n  DEFAULT_FANOUT,\n  MAX_ITEMS,\n  EMPTY_KEY\n} = require('./utils');\n\nconst {\n  concat: uint8ArrayConcat\n} = require('uint8arrays/concat');\n\nconst {\n  compare: uint8ArrayCompare\n} = require('uint8arrays/compare');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n\nconst {\n  sha256\n} = require('multiformats/hashes/sha2');\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n *\n * @typedef {object} Pin\n * @property {CID} key\n * @property {Uint8Array} [data]\n */\n\n/**\n * @param {PBNode} rootNode\n */\n\n\nfunction readHeader(rootNode) {\n  // rootNode.data should be a buffer of the format:\n  // < varint(headerLength) | header | itemData... >\n  const rootData = rootNode.Data;\n\n  if (!rootData) {\n    throw new Error('No data present');\n  }\n\n  const hdrLength = varint.decode(rootData);\n  const vBytes = varint.decode.bytes;\n\n  if (vBytes <= 0) {\n    throw new Error('Invalid Set header length');\n  }\n\n  if (vBytes + hdrLength > rootData.length) {\n    throw new Error('Impossibly large set header length');\n  }\n\n  const hdrSlice = rootData.slice(vBytes, hdrLength + vBytes);\n  const header = PinSet.toObject(PinSet.decode(hdrSlice), {\n    defaults: false,\n    arrays: true,\n    longs: Number,\n    objects: false\n  });\n\n  if (header.version !== 1) {\n    throw new Error(`Unsupported Set version: ${header.version}`);\n  }\n\n  if (header.fanout > rootNode.Links.length) {\n    throw new Error('Impossibly large fanout');\n  }\n\n  return {\n    header: header,\n    data: rootData.slice(hdrLength + vBytes)\n  };\n}\n/**\n * @param {number} seed\n * @param {CID} key\n */\n\n\nfunction hash(seed, key) {\n  const buffer = new Uint8Array(4);\n  const dataView = new DataView(buffer.buffer);\n  dataView.setUint32(0, seed, true);\n  const encodedKey = uint8ArrayFromString(key.toString());\n  const data = uint8ArrayConcat([buffer, encodedKey], buffer.byteLength + encodedKey.byteLength);\n  return fnv1a(uint8ArrayToString(data));\n}\n/**\n * @param {Blockstore} blockstore\n * @param {PBNode} node\n * @returns {AsyncGenerator<CID, void, undefined>}\n */\n\n\nasync function* walkItems(blockstore, node) {\n  const pbh = readHeader(node);\n  let idx = 0;\n\n  for (const link of node.Links) {\n    if (idx < pbh.header.fanout) {\n      // the first pbh.header.fanout links are fanout bins\n      // if a fanout bin is not 'empty', dig into and walk its DAGLinks\n      const linkHash = link.Hash;\n\n      if (!EMPTY_KEY.equals(linkHash)) {\n        // walk the links of this fanout bin\n        const buf = await blockstore.get(linkHash);\n        const node = dagPb.decode(buf);\n        yield* walkItems(blockstore, node);\n      }\n    } else {\n      // otherwise, the link is a pin\n      yield link.Hash;\n    }\n\n    idx++;\n  }\n}\n/**\n * @param {Blockstore} blockstore\n * @param {PBNode} rootNode\n * @param {string} name\n */\n\n\nasync function* loadSet(blockstore, rootNode, name) {\n  const link = rootNode.Links.find(l => l.Name === name);\n\n  if (!link) {\n    throw new Error('No link found with name ' + name);\n  }\n\n  const buf = await blockstore.get(link.Hash);\n  const node = dagPb.decode(buf);\n  yield* walkItems(blockstore, node);\n}\n/**\n * @param {Blockstore} blockstore\n * @param {Pin[]} items\n */\n\n\nfunction storeItems(blockstore, items) {\n  return storePins(items, 0);\n  /**\n   * @param {Pin[]} pins\n   * @param {number} depth\n   */\n\n  async function storePins(pins, depth) {\n    const pbHeader = PinSet.encode({\n      version: 1,\n      fanout: DEFAULT_FANOUT,\n      seed: depth\n    }).finish();\n    const header = varint.encode(pbHeader.length);\n    const headerBuf = uint8ArrayConcat([header, pbHeader]);\n    const fanoutLinks = [];\n\n    for (let i = 0; i < DEFAULT_FANOUT; i++) {\n      fanoutLinks.push({\n        Name: '',\n        Tsize: 1,\n        Hash: EMPTY_KEY\n      });\n    }\n\n    if (pins.length <= MAX_ITEMS) {\n      const nodes = pins.map(item => {\n        return {\n          link: {\n            Name: '',\n            Tsize: 1,\n            Hash: item.key\n          },\n          data: item.data || new Uint8Array()\n        };\n      }) // sorting makes any ordering of `pins` produce the same DAGNode\n      .sort((a, b) => {\n        return uint8ArrayCompare(a.link.Hash.bytes, b.link.Hash.bytes);\n      });\n      const rootLinks = fanoutLinks.concat(nodes.map(item => item.link));\n      const rootData = uint8ArrayConcat([headerBuf, ...nodes.map(item => item.data)]);\n      return {\n        Data: rootData,\n        Links: rootLinks\n      };\n    } else {\n      // If the array of pins is > MAX_ITEMS, we:\n      //  - distribute the pins among `DEFAULT_FANOUT` bins\n      //    - create a DAGNode for each bin\n      //      - add each pin as a DAGLink to that bin\n      //  - create a root DAGNode\n      //    - add each bin as a DAGLink\n      //  - send that root DAGNode via callback\n      // (using go-ipfs' \"wasteful but simple\" approach for consistency)\n      // https://github.com/ipfs/go-ipfs/blob/master/pin/set.go#L57\n\n      /** @type {Pin[][]} */\n      const bins = pins.reduce((bins, pin) => {\n        const n = hash(depth, pin.key) % DEFAULT_FANOUT; // @ts-ignore\n\n        bins[n] = n in bins ? bins[n].concat([pin]) : [pin];\n        return bins;\n      }, []);\n      let idx = 0;\n\n      for (const bin of bins) {\n        const child = await storePins(bin, depth + 1);\n        await storeChild(child, idx);\n        idx++;\n      }\n\n      return {\n        Data: headerBuf,\n        Links: fanoutLinks\n      };\n    }\n    /**\n     * @param {PBNode} child\n     * @param {number} binIdx\n     */\n\n\n    async function storeChild(child, binIdx) {\n      const buf = dagPb.encode(child);\n      const digest = await sha256.digest(buf);\n      const cid = CID.createV0(digest);\n      await blockstore.put(cid, buf);\n      const size = child.Links.reduce((acc, curr) => acc + (curr.Tsize || 0), 0) + buf.length;\n      fanoutLinks[binIdx] = {\n        Name: '',\n        Tsize: size,\n        Hash: cid\n      };\n    }\n  }\n}\n/**\n * @param {Blockstore} blockstore\n * @param {string} type\n * @param {CID[]} cids\n */\n\n\nasync function storeSet(blockstore, type, cids) {\n  const rootNode = await storeItems(blockstore, cids.map(cid => {\n    return {\n      key: cid\n    };\n  }));\n  const buf = dagPb.encode(rootNode);\n  const digest = await sha256.digest(buf);\n  const cid = CID.createV0(digest);\n  await blockstore.put(cid, buf);\n  const size = rootNode.Links.reduce((acc, curr) => acc + curr.Tsize, 0) + buf.length;\n  return {\n    Name: type,\n    Tsize: size,\n    Hash: cid\n  };\n}\n\nmodule.exports = {\n  loadSet,\n  storeSet\n};","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/ipfs-repo-migrations/migrations/migration-9/pin-set.js"],"names":["CID","require","ipfs","pin","Set","PinSet","fnv1a","varint","dagPb","DEFAULT_FANOUT","MAX_ITEMS","EMPTY_KEY","concat","uint8ArrayConcat","compare","uint8ArrayCompare","toString","uint8ArrayToString","fromString","uint8ArrayFromString","sha256","readHeader","rootNode","rootData","Data","Error","hdrLength","decode","vBytes","bytes","length","hdrSlice","slice","header","toObject","defaults","arrays","longs","Number","objects","version","fanout","Links","data","hash","seed","key","buffer","Uint8Array","dataView","DataView","setUint32","encodedKey","byteLength","walkItems","blockstore","node","pbh","idx","link","linkHash","Hash","equals","buf","get","loadSet","name","find","l","Name","storeItems","items","storePins","pins","depth","pbHeader","encode","finish","headerBuf","fanoutLinks","i","push","Tsize","nodes","map","item","sort","a","b","rootLinks","bins","reduce","n","bin","child","storeChild","binIdx","digest","cid","createV0","put","size","acc","curr","storeSet","type","cids","module","exports"],"mappings":"AAAA;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAUC,OAAO,CAAC,kBAAD,CAAvB;;AACA,MAAM;AACJC,EAAAA,IAAI,EAAE;AACJC,IAAAA,GAAG,EAAE;AACHC,MAAAA,GAAG,EAAEC;AADF;AADD;AADF,IAMFJ,OAAO,CAAC,OAAD,CANX,C,CAQA;;;AACA,MAAMK,KAAK,GAAGL,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMM,MAAM,GAAGN,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMO,KAAK,GAAGP,OAAO,CAAC,cAAD,CAArB;;AACA,MAAM;AAAEQ,EAAAA,cAAF;AAAkBC,EAAAA,SAAlB;AAA6BC,EAAAA;AAA7B,IAA2CV,OAAO,CAAC,SAAD,CAAxD;;AACA,MAAM;AAAEW,EAAAA,MAAM,EAAEC;AAAV,IAA+BZ,OAAO,CAAC,oBAAD,CAA5C;;AACA,MAAM;AAAEa,EAAAA,OAAO,EAAEC;AAAX,IAAiCd,OAAO,CAAC,qBAAD,CAA9C;;AACA,MAAM;AAAEe,EAAAA,QAAQ,EAAEC;AAAZ,IAAmChB,OAAO,CAAC,uBAAD,CAAhD;;AACA,MAAM;AAAEiB,EAAAA,UAAU,EAAEC;AAAd,IAAuClB,OAAO,CAAC,yBAAD,CAApD;;AACA,MAAM;AAAEmB,EAAAA;AAAF,IAAanB,OAAO,CAAC,0BAAD,CAA1B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AACA,SAASoB,UAAT,CAAqBC,QAArB,EAA+B;AAC7B;AACA;AACA,QAAMC,QAAQ,GAAGD,QAAQ,CAACE,IAA1B;;AAEA,MAAI,CAACD,QAAL,EAAe;AACb,UAAM,IAAIE,KAAJ,CAAU,iBAAV,CAAN;AACD;;AAED,QAAMC,SAAS,GAAGnB,MAAM,CAACoB,MAAP,CAAcJ,QAAd,CAAlB;AACA,QAAMK,MAAM,GAAGrB,MAAM,CAACoB,MAAP,CAAcE,KAA7B;;AAEA,MAAID,MAAM,IAAI,CAAd,EAAiB;AACf,UAAM,IAAIH,KAAJ,CAAU,2BAAV,CAAN;AACD;;AAED,MAAIG,MAAM,GAAGF,SAAT,GAAqBH,QAAQ,CAACO,MAAlC,EAA0C;AACxC,UAAM,IAAIL,KAAJ,CAAU,oCAAV,CAAN;AACD;;AAED,QAAMM,QAAQ,GAAGR,QAAQ,CAACS,KAAT,CAAeJ,MAAf,EAAuBF,SAAS,GAAGE,MAAnC,CAAjB;AACA,QAAMK,MAAM,GAAG5B,MAAM,CAAC6B,QAAP,CAAgB7B,MAAM,CAACsB,MAAP,CAAcI,QAAd,CAAhB,EAAyC;AACtDI,IAAAA,QAAQ,EAAE,KAD4C;AAEtDC,IAAAA,MAAM,EAAE,IAF8C;AAGtDC,IAAAA,KAAK,EAAEC,MAH+C;AAItDC,IAAAA,OAAO,EAAE;AAJ6C,GAAzC,CAAf;;AAOA,MAAIN,MAAM,CAACO,OAAP,KAAmB,CAAvB,EAA0B;AACxB,UAAM,IAAIf,KAAJ,CAAW,4BAA2BQ,MAAM,CAACO,OAAQ,EAArD,CAAN;AACD;;AAED,MAAIP,MAAM,CAACQ,MAAP,GAAgBnB,QAAQ,CAACoB,KAAT,CAAeZ,MAAnC,EAA2C;AACzC,UAAM,IAAIL,KAAJ,CAAU,yBAAV,CAAN;AACD;;AAED,SAAO;AACLQ,IAAAA,MAAM,EAAEA,MADH;AAELU,IAAAA,IAAI,EAAEpB,QAAQ,CAACS,KAAT,CAAeN,SAAS,GAAGE,MAA3B;AAFD,GAAP;AAID;AAED;AACA;AACA;AACA;;;AACA,SAASgB,IAAT,CAAeC,IAAf,EAAqBC,GAArB,EAA0B;AACxB,QAAMC,MAAM,GAAG,IAAIC,UAAJ,CAAe,CAAf,CAAf;AACA,QAAMC,QAAQ,GAAG,IAAIC,QAAJ,CAAaH,MAAM,CAACA,MAApB,CAAjB;AACAE,EAAAA,QAAQ,CAACE,SAAT,CAAmB,CAAnB,EAAsBN,IAAtB,EAA4B,IAA5B;AACA,QAAMO,UAAU,GAAGjC,oBAAoB,CAAC2B,GAAG,CAAC9B,QAAJ,EAAD,CAAvC;AACA,QAAM2B,IAAI,GAAG9B,gBAAgB,CAAC,CAACkC,MAAD,EAASK,UAAT,CAAD,EAAuBL,MAAM,CAACM,UAAP,GAAoBD,UAAU,CAACC,UAAtD,CAA7B;AAEA,SAAO/C,KAAK,CAACW,kBAAkB,CAAC0B,IAAD,CAAnB,CAAZ;AACD;AAED;AACA;AACA;AACA;AACA;;;AACA,gBAAiBW,SAAjB,CAA4BC,UAA5B,EAAwCC,IAAxC,EAA8C;AAC5C,QAAMC,GAAG,GAAGpC,UAAU,CAACmC,IAAD,CAAtB;AACA,MAAIE,GAAG,GAAG,CAAV;;AAEA,OAAK,MAAMC,IAAX,IAAmBH,IAAI,CAACd,KAAxB,EAA+B;AAC7B,QAAIgB,GAAG,GAAGD,GAAG,CAACxB,MAAJ,CAAWQ,MAArB,EAA6B;AAC3B;AACA;AACA,YAAMmB,QAAQ,GAAGD,IAAI,CAACE,IAAtB;;AAEA,UAAI,CAAClD,SAAS,CAACmD,MAAV,CAAiBF,QAAjB,CAAL,EAAiC;AAC/B;AACA,cAAMG,GAAG,GAAG,MAAMR,UAAU,CAACS,GAAX,CAAeJ,QAAf,CAAlB;AACA,cAAMJ,IAAI,GAAGhD,KAAK,CAACmB,MAAN,CAAaoC,GAAb,CAAb;AAEA,eAAQT,SAAS,CAACC,UAAD,EAAaC,IAAb,CAAjB;AACD;AACF,KAZD,MAYO;AACL;AACA,YAAMG,IAAI,CAACE,IAAX;AACD;;AAEDH,IAAAA,GAAG;AACJ;AACF;AAED;AACA;AACA;AACA;AACA;;;AACA,gBAAiBO,OAAjB,CAA0BV,UAA1B,EAAsCjC,QAAtC,EAAgD4C,IAAhD,EAAsD;AACpD,QAAMP,IAAI,GAAGrC,QAAQ,CAACoB,KAAT,CAAeyB,IAAf,CAAoBC,CAAC,IAAIA,CAAC,CAACC,IAAF,KAAWH,IAApC,CAAb;;AAEA,MAAI,CAACP,IAAL,EAAW;AACT,UAAM,IAAIlC,KAAJ,CAAU,6BAA6ByC,IAAvC,CAAN;AACD;;AAED,QAAMH,GAAG,GAAG,MAAMR,UAAU,CAACS,GAAX,CAAeL,IAAI,CAACE,IAApB,CAAlB;AACA,QAAML,IAAI,GAAGhD,KAAK,CAACmB,MAAN,CAAaoC,GAAb,CAAb;AAEA,SAAQT,SAAS,CAACC,UAAD,EAAaC,IAAb,CAAjB;AACD;AAED;AACA;AACA;AACA;;;AACA,SAASc,UAAT,CAAqBf,UAArB,EAAiCgB,KAAjC,EAAwC;AACtC,SAAOC,SAAS,CAACD,KAAD,EAAQ,CAAR,CAAhB;AAEA;AACF;AACA;AACA;;AACE,iBAAeC,SAAf,CAA0BC,IAA1B,EAAgCC,KAAhC,EAAuC;AACrC,UAAMC,QAAQ,GAAGtE,MAAM,CAACuE,MAAP,CAAc;AAC7BpC,MAAAA,OAAO,EAAE,CADoB;AAE7BC,MAAAA,MAAM,EAAEhC,cAFqB;AAG7BoC,MAAAA,IAAI,EAAE6B;AAHuB,KAAd,EAIdG,MAJc,EAAjB;AAMA,UAAM5C,MAAM,GAAG1B,MAAM,CAACqE,MAAP,CAAcD,QAAQ,CAAC7C,MAAvB,CAAf;AACA,UAAMgD,SAAS,GAAGjE,gBAAgB,CAAC,CAACoB,MAAD,EAAS0C,QAAT,CAAD,CAAlC;AACA,UAAMI,WAAW,GAAG,EAApB;;AAEA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGvE,cAApB,EAAoCuE,CAAC,EAArC,EAAyC;AACvCD,MAAAA,WAAW,CAACE,IAAZ,CAAiB;AACfZ,QAAAA,IAAI,EAAE,EADS;AAEfa,QAAAA,KAAK,EAAE,CAFQ;AAGfrB,QAAAA,IAAI,EAAElD;AAHS,OAAjB;AAKD;;AAED,QAAI8D,IAAI,CAAC3C,MAAL,IAAepB,SAAnB,EAA8B;AAC5B,YAAMyE,KAAK,GAAGV,IAAI,CACfW,GADW,CACPC,IAAI,IAAI;AACX,eAAQ;AACN1B,UAAAA,IAAI,EAAE;AACJU,YAAAA,IAAI,EAAE,EADF;AAEJa,YAAAA,KAAK,EAAE,CAFH;AAGJrB,YAAAA,IAAI,EAAEwB,IAAI,CAACvC;AAHP,WADA;AAMNH,UAAAA,IAAI,EAAE0C,IAAI,CAAC1C,IAAL,IAAa,IAAIK,UAAJ;AANb,SAAR;AAQD,OAVW,EAWZ;AAXY,OAYXsC,IAZW,CAYN,CAACC,CAAD,EAAIC,CAAJ,KAAU;AACd,eAAOzE,iBAAiB,CAACwE,CAAC,CAAC5B,IAAF,CAAOE,IAAP,CAAYhC,KAAb,EAAoB2D,CAAC,CAAC7B,IAAF,CAAOE,IAAP,CAAYhC,KAAhC,CAAxB;AACD,OAdW,CAAd;AAgBA,YAAM4D,SAAS,GAAGV,WAAW,CAACnE,MAAZ,CAAmBuE,KAAK,CAACC,GAAN,CAAUC,IAAI,IAAIA,IAAI,CAAC1B,IAAvB,CAAnB,CAAlB;AACA,YAAMpC,QAAQ,GAAGV,gBAAgB,CAAC,CAACiE,SAAD,EAAY,GAAGK,KAAK,CAACC,GAAN,CAAUC,IAAI,IAAIA,IAAI,CAAC1C,IAAvB,CAAf,CAAD,CAAjC;AAEA,aAAO;AACLnB,QAAAA,IAAI,EAAED,QADD;AAELmB,QAAAA,KAAK,EAAE+C;AAFF,OAAP;AAID,KAxBD,MAwBO;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAMC,IAAI,GAAGjB,IAAI,CAACkB,MAAL,CAAY,CAACD,IAAD,EAAOvF,GAAP,KAAe;AACtC,cAAMyF,CAAC,GAAGhD,IAAI,CAAC8B,KAAD,EAAQvE,GAAG,CAAC2C,GAAZ,CAAJ,GAAuBrC,cAAjC,CADsC,CAEtC;;AACAiF,QAAAA,IAAI,CAACE,CAAD,CAAJ,GAAUA,CAAC,IAAIF,IAAL,GAAYA,IAAI,CAACE,CAAD,CAAJ,CAAQhF,MAAR,CAAe,CAACT,GAAD,CAAf,CAAZ,GAAoC,CAACA,GAAD,CAA9C;AACA,eAAOuF,IAAP;AACD,OALY,EAKV,EALU,CAAb;AAOA,UAAIhC,GAAG,GAAG,CAAV;;AACA,WAAK,MAAMmC,GAAX,IAAkBH,IAAlB,EAAwB;AACtB,cAAMI,KAAK,GAAG,MAAMtB,SAAS,CAACqB,GAAD,EAAMnB,KAAK,GAAG,CAAd,CAA7B;AAEA,cAAMqB,UAAU,CAACD,KAAD,EAAQpC,GAAR,CAAhB;AAEAA,QAAAA,GAAG;AACJ;;AAED,aAAO;AACLlC,QAAAA,IAAI,EAAEsD,SADD;AAELpC,QAAAA,KAAK,EAAEqC;AAFF,OAAP;AAID;AAED;AACJ;AACA;AACA;;;AACI,mBAAegB,UAAf,CAA2BD,KAA3B,EAAkCE,MAAlC,EAA0C;AACxC,YAAMjC,GAAG,GAAGvD,KAAK,CAACoE,MAAN,CAAakB,KAAb,CAAZ;AACA,YAAMG,MAAM,GAAG,MAAM7E,MAAM,CAAC6E,MAAP,CAAclC,GAAd,CAArB;AACA,YAAMmC,GAAG,GAAGlG,GAAG,CAACmG,QAAJ,CAAaF,MAAb,CAAZ;AAEA,YAAM1C,UAAU,CAAC6C,GAAX,CAAeF,GAAf,EAAoBnC,GAApB,CAAN;AAEA,YAAMsC,IAAI,GAAGP,KAAK,CAACpD,KAAN,CAAYiD,MAAZ,CAAmB,CAACW,GAAD,EAAMC,IAAN,KAAeD,GAAG,IAAIC,IAAI,CAACrB,KAAL,IAAc,CAAlB,CAArC,EAA2D,CAA3D,IAAgEnB,GAAG,CAACjC,MAAjF;AAEAiD,MAAAA,WAAW,CAACiB,MAAD,CAAX,GAAsB;AACpB3B,QAAAA,IAAI,EAAE,EADc;AAEpBa,QAAAA,KAAK,EAAEmB,IAFa;AAGpBxC,QAAAA,IAAI,EAAEqC;AAHc,OAAtB;AAKD;AACF;AACF;AAED;AACA;AACA;AACA;AACA;;;AACA,eAAeM,QAAf,CAAyBjD,UAAzB,EAAqCkD,IAArC,EAA2CC,IAA3C,EAAiD;AAC/C,QAAMpF,QAAQ,GAAG,MAAMgD,UAAU,CAACf,UAAD,EAAamD,IAAI,CAACtB,GAAL,CAASc,GAAG,IAAI;AAC5D,WAAO;AACLpD,MAAAA,GAAG,EAAEoD;AADA,KAAP;AAGD,GAJ6C,CAAb,CAAjC;AAKA,QAAMnC,GAAG,GAAGvD,KAAK,CAACoE,MAAN,CAAatD,QAAb,CAAZ;AACA,QAAM2E,MAAM,GAAG,MAAM7E,MAAM,CAAC6E,MAAP,CAAclC,GAAd,CAArB;AACA,QAAMmC,GAAG,GAAGlG,GAAG,CAACmG,QAAJ,CAAaF,MAAb,CAAZ;AAEA,QAAM1C,UAAU,CAAC6C,GAAX,CAAeF,GAAf,EAAoBnC,GAApB,CAAN;AAEA,QAAMsC,IAAI,GAAG/E,QAAQ,CAACoB,KAAT,CAAeiD,MAAf,CAAsB,CAACW,GAAD,EAAMC,IAAN,KAAeD,GAAG,GAAGC,IAAI,CAACrB,KAAhD,EAAuD,CAAvD,IAA4DnB,GAAG,CAACjC,MAA7E;AAEA,SAAO;AACLuC,IAAAA,IAAI,EAAEoC,IADD;AAELvB,IAAAA,KAAK,EAAEmB,IAFF;AAGLxC,IAAAA,IAAI,EAAEqC;AAHD,GAAP;AAKD;;AAEDS,MAAM,CAACC,OAAP,GAAiB;AACf3C,EAAAA,OADe;AAEfuC,EAAAA;AAFe,CAAjB","sourcesContent":["'use strict'\n\nconst { CID } = require('multiformats/cid')\nconst {\n  ipfs: {\n    pin: {\n      Set: PinSet\n    }\n  }\n} = require('./pin')\n\n// @ts-ignore\nconst fnv1a = require('fnv1a')\nconst varint = require('varint')\nconst dagPb = require('@ipld/dag-pb')\nconst { DEFAULT_FANOUT, MAX_ITEMS, EMPTY_KEY } = require('./utils')\nconst { concat: uint8ArrayConcat } = require('uint8arrays/concat')\nconst { compare: uint8ArrayCompare } = require('uint8arrays/compare')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\nconst { sha256 } = require('multiformats/hashes/sha2')\n\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('@ipld/dag-pb').PBNode} PBNode\n *\n * @typedef {object} Pin\n * @property {CID} key\n * @property {Uint8Array} [data]\n */\n\n/**\n * @param {PBNode} rootNode\n */\nfunction readHeader (rootNode) {\n  // rootNode.data should be a buffer of the format:\n  // < varint(headerLength) | header | itemData... >\n  const rootData = rootNode.Data\n\n  if (!rootData) {\n    throw new Error('No data present')\n  }\n\n  const hdrLength = varint.decode(rootData)\n  const vBytes = varint.decode.bytes\n\n  if (vBytes <= 0) {\n    throw new Error('Invalid Set header length')\n  }\n\n  if (vBytes + hdrLength > rootData.length) {\n    throw new Error('Impossibly large set header length')\n  }\n\n  const hdrSlice = rootData.slice(vBytes, hdrLength + vBytes)\n  const header = PinSet.toObject(PinSet.decode(hdrSlice), {\n    defaults: false,\n    arrays: true,\n    longs: Number,\n    objects: false\n  })\n\n  if (header.version !== 1) {\n    throw new Error(`Unsupported Set version: ${header.version}`)\n  }\n\n  if (header.fanout > rootNode.Links.length) {\n    throw new Error('Impossibly large fanout')\n  }\n\n  return {\n    header: header,\n    data: rootData.slice(hdrLength + vBytes)\n  }\n}\n\n/**\n * @param {number} seed\n * @param {CID} key\n */\nfunction hash (seed, key) {\n  const buffer = new Uint8Array(4)\n  const dataView = new DataView(buffer.buffer)\n  dataView.setUint32(0, seed, true)\n  const encodedKey = uint8ArrayFromString(key.toString())\n  const data = uint8ArrayConcat([buffer, encodedKey], buffer.byteLength + encodedKey.byteLength)\n\n  return fnv1a(uint8ArrayToString(data))\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {PBNode} node\n * @returns {AsyncGenerator<CID, void, undefined>}\n */\nasync function * walkItems (blockstore, node) {\n  const pbh = readHeader(node)\n  let idx = 0\n\n  for (const link of node.Links) {\n    if (idx < pbh.header.fanout) {\n      // the first pbh.header.fanout links are fanout bins\n      // if a fanout bin is not 'empty', dig into and walk its DAGLinks\n      const linkHash = link.Hash\n\n      if (!EMPTY_KEY.equals(linkHash)) {\n        // walk the links of this fanout bin\n        const buf = await blockstore.get(linkHash)\n        const node = dagPb.decode(buf)\n\n        yield * walkItems(blockstore, node)\n      }\n    } else {\n      // otherwise, the link is a pin\n      yield link.Hash\n    }\n\n    idx++\n  }\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {PBNode} rootNode\n * @param {string} name\n */\nasync function * loadSet (blockstore, rootNode, name) {\n  const link = rootNode.Links.find(l => l.Name === name)\n\n  if (!link) {\n    throw new Error('No link found with name ' + name)\n  }\n\n  const buf = await blockstore.get(link.Hash)\n  const node = dagPb.decode(buf)\n\n  yield * walkItems(blockstore, node)\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {Pin[]} items\n */\nfunction storeItems (blockstore, items) {\n  return storePins(items, 0)\n\n  /**\n   * @param {Pin[]} pins\n   * @param {number} depth\n   */\n  async function storePins (pins, depth) {\n    const pbHeader = PinSet.encode({\n      version: 1,\n      fanout: DEFAULT_FANOUT,\n      seed: depth\n    }).finish()\n\n    const header = varint.encode(pbHeader.length)\n    const headerBuf = uint8ArrayConcat([header, pbHeader])\n    const fanoutLinks = []\n\n    for (let i = 0; i < DEFAULT_FANOUT; i++) {\n      fanoutLinks.push({\n        Name: '',\n        Tsize: 1,\n        Hash: EMPTY_KEY\n      })\n    }\n\n    if (pins.length <= MAX_ITEMS) {\n      const nodes = pins\n        .map(item => {\n          return ({\n            link: {\n              Name: '',\n              Tsize: 1,\n              Hash: item.key\n            },\n            data: item.data || new Uint8Array()\n          })\n        })\n        // sorting makes any ordering of `pins` produce the same DAGNode\n        .sort((a, b) => {\n          return uint8ArrayCompare(a.link.Hash.bytes, b.link.Hash.bytes)\n        })\n\n      const rootLinks = fanoutLinks.concat(nodes.map(item => item.link))\n      const rootData = uint8ArrayConcat([headerBuf, ...nodes.map(item => item.data)])\n\n      return {\n        Data: rootData,\n        Links: rootLinks\n      }\n    } else {\n      // If the array of pins is > MAX_ITEMS, we:\n      //  - distribute the pins among `DEFAULT_FANOUT` bins\n      //    - create a DAGNode for each bin\n      //      - add each pin as a DAGLink to that bin\n      //  - create a root DAGNode\n      //    - add each bin as a DAGLink\n      //  - send that root DAGNode via callback\n      // (using go-ipfs' \"wasteful but simple\" approach for consistency)\n      // https://github.com/ipfs/go-ipfs/blob/master/pin/set.go#L57\n\n      /** @type {Pin[][]} */\n      const bins = pins.reduce((bins, pin) => {\n        const n = hash(depth, pin.key) % DEFAULT_FANOUT\n        // @ts-ignore\n        bins[n] = n in bins ? bins[n].concat([pin]) : [pin]\n        return bins\n      }, [])\n\n      let idx = 0\n      for (const bin of bins) {\n        const child = await storePins(bin, depth + 1)\n\n        await storeChild(child, idx)\n\n        idx++\n      }\n\n      return {\n        Data: headerBuf,\n        Links: fanoutLinks\n      }\n    }\n\n    /**\n     * @param {PBNode} child\n     * @param {number} binIdx\n     */\n    async function storeChild (child, binIdx) {\n      const buf = dagPb.encode(child)\n      const digest = await sha256.digest(buf)\n      const cid = CID.createV0(digest)\n\n      await blockstore.put(cid, buf)\n\n      const size = child.Links.reduce((acc, curr) => acc + (curr.Tsize || 0), 0) + buf.length\n\n      fanoutLinks[binIdx] = {\n        Name: '',\n        Tsize: size,\n        Hash: cid\n      }\n    }\n  }\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {string} type\n * @param {CID[]} cids\n */\nasync function storeSet (blockstore, type, cids) {\n  const rootNode = await storeItems(blockstore, cids.map(cid => {\n    return {\n      key: cid\n    }\n  }))\n  const buf = dagPb.encode(rootNode)\n  const digest = await sha256.digest(buf)\n  const cid = CID.createV0(digest)\n\n  await blockstore.put(cid, buf)\n\n  const size = rootNode.Links.reduce((acc, curr) => acc + curr.Tsize, 0) + buf.length\n\n  return {\n    Name: type,\n    Tsize: size,\n    Hash: cid\n  }\n}\n\nmodule.exports = {\n  loadSet,\n  storeSet\n}\n"]},"metadata":{},"sourceType":"script"}