{"ast":null,"code":"'use strict';\n\nconst errCode = require('err-code');\n\nconst {\n  parallelMap,\n  filter\n} = require('streaming-iterables');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst {\n  cleanCid\n} = require('./utils');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst BLOCK_RM_CONCURRENCY = 8;\n/**\n * @param {Object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n */\n\nmodule.exports = ({\n  repo\n}) => {\n  /**\n   * @type {import('ipfs-core-types/src/block').API[\"rm\"]}\n   */\n  async function* rm(cids, options = {}) {\n    if (!Array.isArray(cids)) {\n      cids = [cids];\n    } // We need to take a write lock here to ensure that adding and removing\n    // blocks are exclusive operations\n\n\n    const release = await repo.gcLock.writeLock();\n\n    try {\n      yield* pipe(cids, parallelMap(BLOCK_RM_CONCURRENCY, async cid => {\n        cid = cleanCid(cid);\n        /** @type {import('ipfs-core-types/src/block').RmResult} */\n\n        const result = {\n          cid\n        };\n\n        try {\n          const has = await repo.blocks.has(cid);\n\n          if (!has) {\n            throw errCode(new Error('block not found'), 'ERR_BLOCK_NOT_FOUND');\n          }\n\n          await repo.blocks.delete(cid);\n        } catch (err) {\n          if (!options.force) {\n            err.message = `cannot remove ${cid}: ${err.message}`;\n            result.error = err;\n          }\n        }\n\n        return result;\n      }), filter(() => !options.quiet));\n    } finally {\n      release();\n    }\n  }\n\n  return withTimeoutOption(rm);\n};","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/ipfs-core/src/components/block/rm.js"],"names":["errCode","require","parallelMap","filter","pipe","cleanCid","withTimeoutOption","BLOCK_RM_CONCURRENCY","module","exports","repo","rm","cids","options","Array","isArray","release","gcLock","writeLock","cid","result","has","blocks","Error","delete","err","force","message","error","quiet"],"mappings":"AAAA;;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAM;AAAEC,EAAAA,WAAF;AAAeC,EAAAA;AAAf,IAA0BF,OAAO,CAAC,qBAAD,CAAvC;;AACA,MAAM;AAAEG,EAAAA;AAAF,IAAWH,OAAO,CAAC,SAAD,CAAxB;;AACA,MAAM;AAAEI,EAAAA;AAAF,IAAeJ,OAAO,CAAC,SAAD,CAA5B;;AACA,MAAMK,iBAAiB,GAAGL,OAAO,CAAC,yCAAD,CAAjC;;AAEA,MAAMM,oBAAoB,GAAG,CAA7B;AAEA;AACA;AACA;AACA;;AACAC,MAAM,CAACC,OAAP,GAAiB,CAAC;AAAEC,EAAAA;AAAF,CAAD,KAAc;AAC7B;AACF;AACA;AACE,kBAAiBC,EAAjB,CAAqBC,IAArB,EAA2BC,OAAO,GAAG,EAArC,EAAyC;AACvC,QAAI,CAACC,KAAK,CAACC,OAAN,CAAcH,IAAd,CAAL,EAA0B;AACxBA,MAAAA,IAAI,GAAG,CAACA,IAAD,CAAP;AACD,KAHsC,CAKvC;AACA;;;AACA,UAAMI,OAAO,GAAG,MAAMN,IAAI,CAACO,MAAL,CAAYC,SAAZ,EAAtB;;AAEA,QAAI;AACF,aAAQd,IAAI,CACVQ,IADU,EAEVV,WAAW,CAACK,oBAAD,EAAuB,MAAMY,GAAN,IAAa;AAC7CA,QAAAA,GAAG,GAAGd,QAAQ,CAACc,GAAD,CAAd;AAEA;;AACA,cAAMC,MAAM,GAAG;AAAED,UAAAA;AAAF,SAAf;;AAEA,YAAI;AACF,gBAAME,GAAG,GAAG,MAAMX,IAAI,CAACY,MAAL,CAAYD,GAAZ,CAAgBF,GAAhB,CAAlB;;AAEA,cAAI,CAACE,GAAL,EAAU;AACR,kBAAMrB,OAAO,CAAC,IAAIuB,KAAJ,CAAU,iBAAV,CAAD,EAA+B,qBAA/B,CAAb;AACD;;AAED,gBAAMb,IAAI,CAACY,MAAL,CAAYE,MAAZ,CAAmBL,GAAnB,CAAN;AACD,SARD,CAQE,OAAOM,GAAP,EAAY;AACZ,cAAI,CAACZ,OAAO,CAACa,KAAb,EAAoB;AAClBD,YAAAA,GAAG,CAACE,OAAJ,GAAe,iBAAgBR,GAAI,KAAIM,GAAG,CAACE,OAAQ,EAAnD;AACAP,YAAAA,MAAM,CAACQ,KAAP,GAAeH,GAAf;AACD;AACF;;AAED,eAAOL,MAAP;AACD,OAtBU,CAFD,EAyBVjB,MAAM,CAAC,MAAM,CAACU,OAAO,CAACgB,KAAhB,CAzBI,CAAZ;AA2BD,KA5BD,SA4BU;AACRb,MAAAA,OAAO;AACR;AACF;;AAED,SAAOV,iBAAiB,CAACK,EAAD,CAAxB;AACD,CA/CD","sourcesContent":["'use strict'\n\nconst errCode = require('err-code')\nconst { parallelMap, filter } = require('streaming-iterables')\nconst { pipe } = require('it-pipe')\nconst { cleanCid } = require('./utils')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\n\nconst BLOCK_RM_CONCURRENCY = 8\n\n/**\n * @param {Object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n */\nmodule.exports = ({ repo }) => {\n  /**\n   * @type {import('ipfs-core-types/src/block').API[\"rm\"]}\n   */\n  async function * rm (cids, options = {}) {\n    if (!Array.isArray(cids)) {\n      cids = [cids]\n    }\n\n    // We need to take a write lock here to ensure that adding and removing\n    // blocks are exclusive operations\n    const release = await repo.gcLock.writeLock()\n\n    try {\n      yield * pipe(\n        cids,\n        parallelMap(BLOCK_RM_CONCURRENCY, async cid => {\n          cid = cleanCid(cid)\n\n          /** @type {import('ipfs-core-types/src/block').RmResult} */\n          const result = { cid }\n\n          try {\n            const has = await repo.blocks.has(cid)\n\n            if (!has) {\n              throw errCode(new Error('block not found'), 'ERR_BLOCK_NOT_FOUND')\n            }\n\n            await repo.blocks.delete(cid)\n          } catch (err) {\n            if (!options.force) {\n              err.message = `cannot remove ${cid}: ${err.message}`\n              result.error = err\n            }\n          }\n\n          return result\n        }),\n        filter(() => !options.quiet)\n      )\n    } finally {\n      release()\n    }\n  }\n\n  return withTimeoutOption(rm)\n}\n"]},"metadata":{},"sourceType":"script"}