{"ast":null,"code":"'use strict';\n\nconst errcode = require('err-code');\n\nconst pTimeout = require('p-timeout');\n\nconst PeerId = require('peer-id');\n\nconst crypto = require('libp2p-crypto');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst c = require('../constants');\n\nconst Message = require('../message');\n\nconst Query = require('../query');\n\nconst utils = require('../utils');\n/**\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * @param {import('../index')} dht\n */\n\n\nmodule.exports = dht => {\n  /**\n   * Look if we are connected to a peer with the given id.\n   * Returns its id and addresses, if found, otherwise `undefined`.\n   *\n   * @param {PeerId} peer\n   */\n  const findPeerLocal = async peer => {\n    dht._log(`findPeerLocal ${peer.toB58String()}`);\n\n    const p = await dht.routingTable.find(peer);\n    /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */\n\n    const peerData = p && dht.peerStore.get(p);\n\n    if (peerData) {\n      return {\n        id: peerData.id,\n        multiaddrs: peerData.addresses.map(address => address.multiaddr)\n      };\n    }\n  };\n  /**\n   * Get a value via rpc call for the given parameters.\n   *\n   * @param {PeerId} peer\n   * @param {Uint8Array} key\n   * @returns {Promise<Message>}\n   * @private\n   */\n\n\n  const getValueSingle = async (peer, key) => {\n    // eslint-disable-line require-await\n    const msg = new Message(Message.TYPES.GET_VALUE, key, 0);\n    return dht.network.sendRequest(peer, msg);\n  };\n  /**\n   * Find close peers for a given peer\n   *\n   * @param {Uint8Array} key\n   * @param {PeerId} peer\n   * @returns {Promise<Array<{ id: PeerId, multiaddrs: Multiaddr[] }>>}\n   * @private\n   */\n\n\n  const closerPeersSingle = async (key, peer) => {\n    dht._log(`closerPeersSingle ${uint8ArrayToString(key, 'base32')} from ${peer.toB58String()}`);\n\n    const msg = await dht.peerRouting._findPeerSingle(peer, new PeerId(key));\n    return msg.closerPeers.filter(peerData => !dht._isSelf(peerData.id)).map(peerData => {\n      dht.peerStore.addressBook.add(peerData.id, peerData.multiaddrs);\n      return peerData;\n    });\n  };\n  /**\n   * Get the public key directly from a node.\n   *\n   * @param {PeerId} peer\n   */\n\n\n  const getPublicKeyFromNode = async peer => {\n    const pkKey = utils.keyForPublicKey(peer);\n    const msg = await getValueSingle(peer, pkKey);\n\n    if (!msg.record || !msg.record.value) {\n      throw errcode(new Error(`Node not responding with its public key: ${peer.toB58String()}`), 'ERR_INVALID_RECORD');\n    }\n\n    const recPeer = await PeerId.createFromPubKey(msg.record.value); // compare hashes of the pub key\n\n    if (!recPeer.equals(peer)) {\n      throw errcode(new Error('public key does not match id'), 'ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID');\n    }\n\n    return recPeer.pubKey;\n  };\n\n  return {\n    /**\n     * Ask peer `peer` if they know where the peer with id `target` is.\n     *\n     * @param {PeerId} peer\n     * @param {PeerId} target\n     * @returns {Promise<Message>}\n     * @private\n     */\n    async _findPeerSingle(peer, target) {\n      // eslint-disable-line require-await\n      dht._log('findPeerSingle %s', peer.toB58String());\n\n      const msg = new Message(Message.TYPES.FIND_NODE, target.id, 0);\n      return dht.network.sendRequest(peer, msg);\n    },\n\n    /**\n     * Search for a peer with the given ID.\n     *\n     * @param {PeerId} id\n     * @param {Object} [options] - findPeer options\n     * @param {number} [options.timeout=60000] - how long the query should maximally run, in milliseconds\n     * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n     */\n    async findPeer(id, options = {\n      timeout: 60000\n    }) {\n      options.timeout = options.timeout || c.minute;\n\n      dht._log('findPeer %s', id.toB58String()); // Try to find locally\n\n\n      const pi = await findPeerLocal(id); // already got it\n\n      if (pi != null) {\n        dht._log('found local');\n\n        return pi;\n      }\n\n      const key = await utils.convertPeerId(id);\n      const peers = dht.routingTable.closestPeers(key, dht.kBucketSize);\n\n      if (peers.length === 0) {\n        throw errcode(new Error('Peer lookup failed'), 'ERR_LOOKUP_FAILED');\n      } // sanity check\n\n\n      const match = peers.find(p => p.isEqual(id));\n\n      if (match) {\n        /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */\n        const peer = dht.peerStore.get(id);\n\n        if (peer) {\n          dht._log('found in peerStore');\n\n          return {\n            id: peer.id,\n            multiaddrs: peer.addresses.map(address => address.multiaddr)\n          };\n        }\n      } // query the network\n\n\n      const query = new Query(dht, id.id, () => {\n        /**\n         * There is no distinction between the disjoint paths, so there are no per-path\n         * variables in dht scope. Just return the actual query function.\n         *\n         * @param {PeerId} peer\n         */\n        const queryFn = async peer => {\n          const msg = await this._findPeerSingle(peer, id);\n          const match = msg.closerPeers.find(p => p.id.isEqual(id)); // found it\n\n          if (match) {\n            return {\n              peer: match,\n              queryComplete: true\n            };\n          }\n\n          return {\n            closerPeers: msg.closerPeers\n          };\n        };\n\n        return queryFn;\n      });\n      let result;\n\n      try {\n        result = await pTimeout(query.run(peers), options.timeout);\n      } finally {\n        query.stop();\n      }\n\n      let success = false;\n      result.paths.forEach(result => {\n        if (result.success && result.peer) {\n          success = true;\n          dht.peerStore.addressBook.add(result.peer.id, result.peer.multiaddrs);\n        }\n      });\n\n      dht._log('findPeer %s: %s', id.toB58String(), success);\n\n      if (!success) {\n        throw errcode(new Error('No peer found'), 'ERR_NOT_FOUND');\n      }\n      /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */\n\n\n      const peerData = dht.peerStore.get(id);\n\n      if (!peerData) {\n        throw errcode(new Error('No peer found in peer store'), 'ERR_NOT_FOUND');\n      }\n\n      return {\n        id: peerData.id,\n        multiaddrs: peerData.addresses.map(address => address.multiaddr)\n      };\n    },\n\n    /**\n     * Kademlia 'node lookup' operation.\n     *\n     * @param {Uint8Array} key\n     * @param {Object} [options]\n     * @param {boolean} [options.shallow=false] - shallow query\n     * @returns {AsyncIterable<PeerId>}\n     */\n    async *getClosestPeers(key, options = {\n      shallow: false\n    }) {\n      dht._log('getClosestPeers to %b', key);\n\n      const id = await utils.convertBuffer(key);\n      const tablePeers = dht.routingTable.closestPeers(id, dht.kBucketSize);\n      const q = new Query(dht, key, () => {\n        // There is no distinction between the disjoint paths,\n        // so there are no per-path variables in dht scope.\n        // Just return the actual query function.\n        return async peer => {\n          const closer = await closerPeersSingle(key, peer);\n          return {\n            closerPeers: closer,\n            pathComplete: options.shallow ? true : undefined\n          };\n        };\n      });\n      const res = await q.run(tablePeers);\n\n      if (!res || !res.finalSet) {\n        return [];\n      }\n\n      const sorted = await utils.sortClosestPeers(Array.from(res.finalSet), id);\n\n      for (const pId of sorted.slice(0, dht.kBucketSize)) {\n        yield pId;\n      }\n    },\n\n    /**\n     * Get the public key for the given peer id.\n     *\n     * @param {PeerId} peer\n     */\n    async getPublicKey(peer) {\n      dht._log('getPublicKey %s', peer.toB58String()); // local check\n\n      /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */\n\n\n      const peerData = dht.peerStore.get(peer);\n\n      if (peerData && peerData.id.pubKey) {\n        dht._log('getPublicKey: found local copy');\n\n        return peerData.id.pubKey;\n      } // try the node directly\n\n\n      let pk;\n\n      try {\n        pk = await getPublicKeyFromNode(peer);\n      } catch (err) {\n        // try dht directly\n        const pkKey = utils.keyForPublicKey(peer);\n        const value = await dht.get(pkKey);\n        pk = crypto.keys.unmarshalPublicKey(value);\n      }\n\n      const peerId = new PeerId(peer.id, undefined, pk);\n      const addrs = (peerData && peerData.addresses || []).map(address => address.multiaddr);\n      dht.peerStore.addressBook.add(peerId, addrs);\n      dht.peerStore.keyBook.set(peerId, pk);\n      return pk;\n    }\n\n  };\n};","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/libp2p-kad-dht/src/peer-routing/index.js"],"names":["errcode","require","pTimeout","PeerId","crypto","toString","uint8ArrayToString","c","Message","Query","utils","module","exports","dht","findPeerLocal","peer","_log","toB58String","p","routingTable","find","peerData","peerStore","get","id","multiaddrs","addresses","map","address","multiaddr","getValueSingle","key","msg","TYPES","GET_VALUE","network","sendRequest","closerPeersSingle","peerRouting","_findPeerSingle","closerPeers","filter","_isSelf","addressBook","add","getPublicKeyFromNode","pkKey","keyForPublicKey","record","value","Error","recPeer","createFromPubKey","equals","pubKey","target","FIND_NODE","findPeer","options","timeout","minute","pi","convertPeerId","peers","closestPeers","kBucketSize","length","match","isEqual","query","queryFn","queryComplete","result","run","stop","success","paths","forEach","getClosestPeers","shallow","convertBuffer","tablePeers","q","closer","pathComplete","undefined","res","finalSet","sorted","sortClosestPeers","Array","from","pId","slice","getPublicKey","pk","err","keys","unmarshalPublicKey","peerId","addrs","keyBook","set"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errcode = require('err-code')\nconst pTimeout = require('p-timeout')\n\nconst PeerId = require('peer-id')\nconst crypto = require('libp2p-crypto')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\n\nconst c = require('../constants')\nconst Message = require('../message')\nconst Query = require('../query')\n\nconst utils = require('../utils')\n\n/**\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * @param {import('../index')} dht\n */\nmodule.exports = (dht) => {\n  /**\n   * Look if we are connected to a peer with the given id.\n   * Returns its id and addresses, if found, otherwise `undefined`.\n   *\n   * @param {PeerId} peer\n   */\n  const findPeerLocal = async (peer) => {\n    dht._log(`findPeerLocal ${peer.toB58String()}`)\n    const p = await dht.routingTable.find(peer)\n\n    /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */\n    const peerData = p && dht.peerStore.get(p)\n\n    if (peerData) {\n      return {\n        id: peerData.id,\n        multiaddrs: peerData.addresses.map((address) => address.multiaddr)\n      }\n    }\n  }\n\n  /**\n   * Get a value via rpc call for the given parameters.\n   *\n   * @param {PeerId} peer\n   * @param {Uint8Array} key\n   * @returns {Promise<Message>}\n   * @private\n   */\n  const getValueSingle = async (peer, key) => { // eslint-disable-line require-await\n    const msg = new Message(Message.TYPES.GET_VALUE, key, 0)\n    return dht.network.sendRequest(peer, msg)\n  }\n\n  /**\n   * Find close peers for a given peer\n   *\n   * @param {Uint8Array} key\n   * @param {PeerId} peer\n   * @returns {Promise<Array<{ id: PeerId, multiaddrs: Multiaddr[] }>>}\n   * @private\n   */\n\n  const closerPeersSingle = async (key, peer) => {\n    dht._log(`closerPeersSingle ${uint8ArrayToString(key, 'base32')} from ${peer.toB58String()}`)\n    const msg = await dht.peerRouting._findPeerSingle(peer, new PeerId(key))\n\n    return msg.closerPeers\n      .filter((peerData) => !dht._isSelf(peerData.id))\n      .map((peerData) => {\n        dht.peerStore.addressBook.add(peerData.id, peerData.multiaddrs)\n\n        return peerData\n      })\n  }\n\n  /**\n   * Get the public key directly from a node.\n   *\n   * @param {PeerId} peer\n   */\n  const getPublicKeyFromNode = async (peer) => {\n    const pkKey = utils.keyForPublicKey(peer)\n    const msg = await getValueSingle(peer, pkKey)\n\n    if (!msg.record || !msg.record.value) {\n      throw errcode(new Error(`Node not responding with its public key: ${peer.toB58String()}`), 'ERR_INVALID_RECORD')\n    }\n\n    const recPeer = await PeerId.createFromPubKey(msg.record.value)\n\n    // compare hashes of the pub key\n    if (!recPeer.equals(peer)) {\n      throw errcode(new Error('public key does not match id'), 'ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID')\n    }\n\n    return recPeer.pubKey\n  }\n\n  return {\n  /**\n   * Ask peer `peer` if they know where the peer with id `target` is.\n   *\n   * @param {PeerId} peer\n   * @param {PeerId} target\n   * @returns {Promise<Message>}\n   * @private\n   */\n    async _findPeerSingle (peer, target) { // eslint-disable-line require-await\n      dht._log('findPeerSingle %s', peer.toB58String())\n      const msg = new Message(Message.TYPES.FIND_NODE, target.id, 0)\n\n      return dht.network.sendRequest(peer, msg)\n    },\n\n    /**\n     * Search for a peer with the given ID.\n     *\n     * @param {PeerId} id\n     * @param {Object} [options] - findPeer options\n     * @param {number} [options.timeout=60000] - how long the query should maximally run, in milliseconds\n     * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n     */\n    async findPeer (id, options = { timeout: 60000 }) {\n      options.timeout = options.timeout || c.minute\n      dht._log('findPeer %s', id.toB58String())\n\n      // Try to find locally\n      const pi = await findPeerLocal(id)\n\n      // already got it\n      if (pi != null) {\n        dht._log('found local')\n        return pi\n      }\n\n      const key = await utils.convertPeerId(id)\n      const peers = dht.routingTable.closestPeers(key, dht.kBucketSize)\n\n      if (peers.length === 0) {\n        throw errcode(new Error('Peer lookup failed'), 'ERR_LOOKUP_FAILED')\n      }\n\n      // sanity check\n      const match = peers.find((p) => p.isEqual(id))\n      if (match) {\n        /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */\n        const peer = dht.peerStore.get(id)\n\n        if (peer) {\n          dht._log('found in peerStore')\n          return {\n            id: peer.id,\n            multiaddrs: peer.addresses.map((address) => address.multiaddr)\n          }\n        }\n      }\n\n      // query the network\n      const query = new Query(dht, id.id, () => {\n        /**\n         * There is no distinction between the disjoint paths, so there are no per-path\n         * variables in dht scope. Just return the actual query function.\n         *\n         * @param {PeerId} peer\n         */\n        const queryFn = async (peer) => {\n          const msg = await this._findPeerSingle(peer, id)\n          const match = msg.closerPeers.find((p) => p.id.isEqual(id))\n\n          // found it\n          if (match) {\n            return {\n              peer: match,\n              queryComplete: true\n            }\n          }\n\n          return {\n            closerPeers: msg.closerPeers\n          }\n        }\n\n        return queryFn\n      })\n\n      let result\n      try {\n        result = await pTimeout(query.run(peers), options.timeout)\n      } finally {\n        query.stop()\n      }\n\n      let success = false\n      result.paths.forEach((result) => {\n        if (result.success && result.peer) {\n          success = true\n          dht.peerStore.addressBook.add(result.peer.id, result.peer.multiaddrs)\n        }\n      })\n      dht._log('findPeer %s: %s', id.toB58String(), success)\n\n      if (!success) {\n        throw errcode(new Error('No peer found'), 'ERR_NOT_FOUND')\n      }\n\n      /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */\n      const peerData = dht.peerStore.get(id)\n\n      if (!peerData) {\n        throw errcode(new Error('No peer found in peer store'), 'ERR_NOT_FOUND')\n      }\n\n      return {\n        id: peerData.id,\n        multiaddrs: peerData.addresses.map((address) => address.multiaddr)\n      }\n    },\n\n    /**\n     * Kademlia 'node lookup' operation.\n     *\n     * @param {Uint8Array} key\n     * @param {Object} [options]\n     * @param {boolean} [options.shallow=false] - shallow query\n     * @returns {AsyncIterable<PeerId>}\n     */\n    async * getClosestPeers (key, options = { shallow: false }) {\n      dht._log('getClosestPeers to %b', key)\n\n      const id = await utils.convertBuffer(key)\n      const tablePeers = dht.routingTable.closestPeers(id, dht.kBucketSize)\n\n      const q = new Query(dht, key, () => {\n        // There is no distinction between the disjoint paths,\n        // so there are no per-path variables in dht scope.\n        // Just return the actual query function.\n        return async (peer) => {\n          const closer = await closerPeersSingle(key, peer)\n\n          return {\n            closerPeers: closer,\n            pathComplete: options.shallow ? true : undefined\n          }\n        }\n      })\n\n      const res = await q.run(tablePeers)\n      if (!res || !res.finalSet) {\n        return []\n      }\n\n      const sorted = await utils.sortClosestPeers(Array.from(res.finalSet), id)\n\n      for (const pId of sorted.slice(0, dht.kBucketSize)) {\n        yield pId\n      }\n    },\n\n    /**\n     * Get the public key for the given peer id.\n     *\n     * @param {PeerId} peer\n     */\n    async getPublicKey (peer) {\n      dht._log('getPublicKey %s', peer.toB58String())\n\n      // local check\n      /** @type {{ id: PeerId, addresses: { multiaddr: Multiaddr }[] }} */\n      const peerData = dht.peerStore.get(peer)\n\n      if (peerData && peerData.id.pubKey) {\n        dht._log('getPublicKey: found local copy')\n        return peerData.id.pubKey\n      }\n\n      // try the node directly\n      let pk\n\n      try {\n        pk = await getPublicKeyFromNode(peer)\n      } catch (err) {\n        // try dht directly\n        const pkKey = utils.keyForPublicKey(peer)\n        const value = await dht.get(pkKey)\n        pk = crypto.keys.unmarshalPublicKey(value)\n      }\n\n      const peerId = new PeerId(peer.id, undefined, pk)\n      const addrs = ((peerData && peerData.addresses) || []).map((address) => address.multiaddr)\n      dht.peerStore.addressBook.add(peerId, addrs)\n      dht.peerStore.keyBook.set(peerId, pk)\n\n      return pk\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}