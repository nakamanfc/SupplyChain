{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict';\n\nconst {\n  resolvePath\n} = require('../../utils');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst {\n  normaliseInput\n} = require('ipfs-core-utils/src/pins/normalise-input');\n\nconst {\n  PinTypes\n} = require('ipfs-repo');\n/**\n * @typedef {import('ipfs-core-utils/src/pins/normalise-input').Source} Source\n * @typedef {import('ipfs-core-utils/src/pins/normalise-input').Pin} PinTarget\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('multiformats/cid').CID} CID\n */\n\n/**\n * @template T\n * @typedef {Iterable<T>|AsyncIterable<T>} AwaitIterable\n */\n\n/**\n * @param {Object} config\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n */\n\n\nmodule.exports = ({\n  repo,\n  codecs\n}) => {\n  /**\n   * @type {import('ipfs-core-types/src/pin').API[\"addAll\"]}\n   */\n  async function* addAll(source, options = {}) {\n    /**\n     * @returns {AsyncIterable<CID>}\n     */\n    const pinAdd = async function* () {\n      for await (const {\n        path,\n        recursive,\n        metadata\n      } of normaliseInput(source)) {\n        const {\n          cid\n        } = await resolvePath(repo, codecs, path); // verify that each hash can be pinned\n\n        const {\n          reason\n        } = await repo.pins.isPinnedWithType(cid, [PinTypes.recursive, PinTypes.direct]);\n\n        if (reason === 'recursive' && !recursive) {\n          // only disallow trying to override recursive pins\n          throw new Error(`${cid} already pinned recursively`);\n        }\n\n        if (recursive) {\n          await repo.pins.pinRecursively(cid, {\n            metadata\n          });\n        } else {\n          await repo.pins.pinDirectly(cid, {\n            metadata\n          });\n        }\n\n        yield cid;\n      }\n    }; // When adding a file, we take a lock that gets released after pinning\n    // is complete, so don't take a second lock here\n\n\n    const lock = Boolean(options.lock);\n\n    if (!lock) {\n      yield* pinAdd();\n      return;\n    }\n\n    const release = await repo.gcLock.readLock();\n\n    try {\n      yield* pinAdd();\n    } finally {\n      release();\n    }\n  }\n\n  return withTimeoutOption(addAll);\n};","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/ipfs-core/src/components/pin/add-all.js"],"names":["resolvePath","require","withTimeoutOption","normaliseInput","PinTypes","module","exports","repo","codecs","addAll","source","options","pinAdd","path","recursive","metadata","cid","reason","pins","isPinnedWithType","direct","Error","pinRecursively","pinDirectly","lock","Boolean","release","gcLock","readLock"],"mappings":"AAAA;AACA;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAkBC,OAAO,CAAC,aAAD,CAA/B;;AACA,MAAMC,iBAAiB,GAAGD,OAAO,CAAC,yCAAD,CAAjC;;AACA,MAAM;AAAEE,EAAAA;AAAF,IAAqBF,OAAO,CAAC,0CAAD,CAAlC;;AACA,MAAM;AAAEG,EAAAA;AAAF,IAAeH,OAAO,CAAC,WAAD,CAA5B;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AACAI,MAAM,CAACC,OAAP,GAAiB,CAAC;AAAEC,EAAAA,IAAF;AAAQC,EAAAA;AAAR,CAAD,KAAsB;AACrC;AACF;AACA;AACE,kBAAiBC,MAAjB,CAAyBC,MAAzB,EAAiCC,OAAO,GAAG,EAA3C,EAA+C;AAC7C;AACJ;AACA;AACI,UAAMC,MAAM,GAAG,mBAAoB;AACjC,iBAAW,MAAM;AAAEC,QAAAA,IAAF;AAAQC,QAAAA,SAAR;AAAmBC,QAAAA;AAAnB,OAAjB,IAAkDZ,cAAc,CAACO,MAAD,CAAhE,EAA0E;AACxE,cAAM;AAAEM,UAAAA;AAAF,YAAU,MAAMhB,WAAW,CAACO,IAAD,EAAOC,MAAP,EAAeK,IAAf,CAAjC,CADwE,CAGxE;;AACA,cAAM;AAAEI,UAAAA;AAAF,YAAa,MAAMV,IAAI,CAACW,IAAL,CAAUC,gBAAV,CAA2BH,GAA3B,EAAgC,CAACZ,QAAQ,CAACU,SAAV,EAAqBV,QAAQ,CAACgB,MAA9B,CAAhC,CAAzB;;AAEA,YAAIH,MAAM,KAAK,WAAX,IAA0B,CAACH,SAA/B,EAA0C;AACxC;AACA,gBAAM,IAAIO,KAAJ,CAAW,GAAEL,GAAI,6BAAjB,CAAN;AACD;;AAED,YAAIF,SAAJ,EAAe;AACb,gBAAMP,IAAI,CAACW,IAAL,CAAUI,cAAV,CAAyBN,GAAzB,EAA8B;AAAED,YAAAA;AAAF,WAA9B,CAAN;AACD,SAFD,MAEO;AACL,gBAAMR,IAAI,CAACW,IAAL,CAAUK,WAAV,CAAsBP,GAAtB,EAA2B;AAAED,YAAAA;AAAF,WAA3B,CAAN;AACD;;AAED,cAAMC,GAAN;AACD;AACF,KApBD,CAJ6C,CA0B7C;AACA;;;AACA,UAAMQ,IAAI,GAAGC,OAAO,CAACd,OAAO,CAACa,IAAT,CAApB;;AAEA,QAAI,CAACA,IAAL,EAAW;AACT,aAAQZ,MAAM,EAAd;AACA;AACD;;AAED,UAAMc,OAAO,GAAG,MAAMnB,IAAI,CAACoB,MAAL,CAAYC,QAAZ,EAAtB;;AAEA,QAAI;AACF,aAAQhB,MAAM,EAAd;AACD,KAFD,SAEU;AACRc,MAAAA,OAAO;AACR;AACF;;AAED,SAAOxB,iBAAiB,CAACO,MAAD,CAAxB;AACD,CAjDD","sourcesContent":["/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict'\n\nconst { resolvePath } = require('../../utils')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\nconst { normaliseInput } = require('ipfs-core-utils/src/pins/normalise-input')\nconst { PinTypes } = require('ipfs-repo')\n\n/**\n * @typedef {import('ipfs-core-utils/src/pins/normalise-input').Source} Source\n * @typedef {import('ipfs-core-utils/src/pins/normalise-input').Pin} PinTarget\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('multiformats/cid').CID} CID\n */\n\n/**\n * @template T\n * @typedef {Iterable<T>|AsyncIterable<T>} AwaitIterable\n */\n\n/**\n * @param {Object} config\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n */\nmodule.exports = ({ repo, codecs }) => {\n  /**\n   * @type {import('ipfs-core-types/src/pin').API[\"addAll\"]}\n   */\n  async function * addAll (source, options = {}) {\n    /**\n     * @returns {AsyncIterable<CID>}\n     */\n    const pinAdd = async function * () {\n      for await (const { path, recursive, metadata } of normaliseInput(source)) {\n        const { cid } = await resolvePath(repo, codecs, path)\n\n        // verify that each hash can be pinned\n        const { reason } = await repo.pins.isPinnedWithType(cid, [PinTypes.recursive, PinTypes.direct])\n\n        if (reason === 'recursive' && !recursive) {\n          // only disallow trying to override recursive pins\n          throw new Error(`${cid} already pinned recursively`)\n        }\n\n        if (recursive) {\n          await repo.pins.pinRecursively(cid, { metadata })\n        } else {\n          await repo.pins.pinDirectly(cid, { metadata })\n        }\n\n        yield cid\n      }\n    }\n\n    // When adding a file, we take a lock that gets released after pinning\n    // is complete, so don't take a second lock here\n    const lock = Boolean(options.lock)\n\n    if (!lock) {\n      yield * pinAdd()\n      return\n    }\n\n    const release = await repo.gcLock.readLock()\n\n    try {\n      yield * pinAdd()\n    } finally {\n      release()\n    }\n  }\n\n  return withTimeoutOption(addAll)\n}\n"]},"metadata":{},"sourceType":"script"}