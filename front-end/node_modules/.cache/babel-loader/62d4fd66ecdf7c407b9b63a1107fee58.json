{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decode2 = exports.decode1 = exports.decode0 = exports.encode2 = exports.encode1 = exports.encode0 = exports.uint16BEDecode = exports.uint16BEEncode = void 0;\n\nconst buffer_1 = require(\"buffer\");\n\nconst uint16BEEncode = (value, target, offset) => {\n  target = target || buffer_1.Buffer.allocUnsafe(2);\n  target.writeUInt16BE(value, offset);\n  return target;\n};\n\nexports.uint16BEEncode = uint16BEEncode;\nexports.uint16BEEncode.bytes = 2;\n\nconst uint16BEDecode = data => {\n  if (data.length < 2) throw RangeError('Could not decode int16BE');\n  return data.readUInt16BE(0);\n};\n\nexports.uint16BEDecode = uint16BEDecode;\nexports.uint16BEDecode.bytes = 2; // Note: IK and XX encoder usage is opposite (XX uses in stages encode0 where IK uses encode1)\n\nfunction encode0(message) {\n  return buffer_1.Buffer.concat([message.ne, message.ciphertext]);\n}\n\nexports.encode0 = encode0;\n\nfunction encode1(message) {\n  return buffer_1.Buffer.concat([message.ne, message.ns, message.ciphertext]);\n}\n\nexports.encode1 = encode1;\n\nfunction encode2(message) {\n  return buffer_1.Buffer.concat([message.ns, message.ciphertext]);\n}\n\nexports.encode2 = encode2;\n\nfunction decode0(input) {\n  if (input.length < 32) {\n    throw new Error('Cannot decode stage 0 MessageBuffer: length less than 32 bytes.');\n  }\n\n  return {\n    ne: input.slice(0, 32),\n    ciphertext: input.slice(32, input.length),\n    ns: buffer_1.Buffer.alloc(0)\n  };\n}\n\nexports.decode0 = decode0;\n\nfunction decode1(input) {\n  if (input.length < 80) {\n    throw new Error('Cannot decode stage 1 MessageBuffer: length less than 80 bytes.');\n  }\n\n  return {\n    ne: input.slice(0, 32),\n    ns: input.slice(32, 80),\n    ciphertext: input.slice(80, input.length)\n  };\n}\n\nexports.decode1 = decode1;\n\nfunction decode2(input) {\n  if (input.length < 48) {\n    throw new Error('Cannot decode stage 2 MessageBuffer: length less than 48 bytes.');\n  }\n\n  return {\n    ne: buffer_1.Buffer.alloc(0),\n    ns: input.slice(0, 48),\n    ciphertext: input.slice(48, input.length)\n  };\n}\n\nexports.decode2 = decode2;","map":{"version":3,"sources":["../../src/encoder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decode2 = exports.decode1 = exports.decode0 = exports.encode2 = exports.encode1 = exports.encode0 = exports.uint16BEDecode = exports.uint16BEEncode = void 0;\nconst buffer_1 = require(\"buffer\");\nconst uint16BEEncode = (value, target, offset) => {\n    target = target || buffer_1.Buffer.allocUnsafe(2);\n    target.writeUInt16BE(value, offset);\n    return target;\n};\nexports.uint16BEEncode = uint16BEEncode;\nexports.uint16BEEncode.bytes = 2;\nconst uint16BEDecode = (data) => {\n    if (data.length < 2)\n        throw RangeError('Could not decode int16BE');\n    return data.readUInt16BE(0);\n};\nexports.uint16BEDecode = uint16BEDecode;\nexports.uint16BEDecode.bytes = 2;\n// Note: IK and XX encoder usage is opposite (XX uses in stages encode0 where IK uses encode1)\nfunction encode0(message) {\n    return buffer_1.Buffer.concat([message.ne, message.ciphertext]);\n}\nexports.encode0 = encode0;\nfunction encode1(message) {\n    return buffer_1.Buffer.concat([message.ne, message.ns, message.ciphertext]);\n}\nexports.encode1 = encode1;\nfunction encode2(message) {\n    return buffer_1.Buffer.concat([message.ns, message.ciphertext]);\n}\nexports.encode2 = encode2;\nfunction decode0(input) {\n    if (input.length < 32) {\n        throw new Error('Cannot decode stage 0 MessageBuffer: length less than 32 bytes.');\n    }\n    return {\n        ne: input.slice(0, 32),\n        ciphertext: input.slice(32, input.length),\n        ns: buffer_1.Buffer.alloc(0)\n    };\n}\nexports.decode0 = decode0;\nfunction decode1(input) {\n    if (input.length < 80) {\n        throw new Error('Cannot decode stage 1 MessageBuffer: length less than 80 bytes.');\n    }\n    return {\n        ne: input.slice(0, 32),\n        ns: input.slice(32, 80),\n        ciphertext: input.slice(80, input.length)\n    };\n}\nexports.decode1 = decode1;\nfunction decode2(input) {\n    if (input.length < 48) {\n        throw new Error('Cannot decode stage 2 MessageBuffer: length less than 48 bytes.');\n    }\n    return {\n        ne: buffer_1.Buffer.alloc(0),\n        ns: input.slice(0, 48),\n        ciphertext: input.slice(48, input.length)\n    };\n}\nexports.decode2 = decode2;\n//# sourceMappingURL=encoder.js.map"]},"metadata":{},"sourceType":"script"}