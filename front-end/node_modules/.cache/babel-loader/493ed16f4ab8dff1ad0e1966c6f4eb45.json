{"ast":null,"code":"'use strict';\n\nconst get = require('dlv');\n\nconst mergeOptions = require('merge-options').bind({\n  ignoreUndefined: true\n});\n\nconst errCode = require('err-code');\n\nconst PubsubRouters = require('../runtime/libp2p-pubsub-routers-nodejs'); // @ts-ignore - no types\n\n\nconst DelegatedPeerRouter = require('libp2p-delegated-peer-routing'); // @ts-ignore - no types\n\n\nconst DelegatedContentRouter = require('libp2p-delegated-content-routing');\n\nconst {\n  create: ipfsHttpClient\n} = require('ipfs-http-client');\n\nconst {\n  Multiaddr\n} = require('multiaddr');\n\nconst pkgversion = require('../../package.json').version;\n/**\n * @typedef {object} DekOptions\n * @property {string} hash\n * @property {string} salt\n * @property {number} iterationCount\n * @property {number} keyLength\n *\n * @typedef {Object} KeychainConfig\n * @property {string} [pass]\n * @property {DekOptions} [dek]\n *\n * @typedef {import('ipfs-repo').IPFSRepo} Repo\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../types').Options} IPFSOptions\n * @typedef {import('libp2p')} LibP2P\n * @typedef {import('libp2p').Libp2pOptions & import('libp2p').CreateOptions} Libp2pOptions\n * @typedef {import('ipfs-core-types/src/config').Config} IPFSConfig\n */\n\n/**\n * @param {Object} config\n * @param {Repo} config.repo\n * @param {IPFSOptions|undefined} config.options\n * @param {PeerId} config.peerId\n * @param {Multiaddr[]|undefined} config.multiaddrs\n * @param {KeychainConfig|undefined} config.keychainConfig\n * @param {Partial<IPFSConfig>|undefined} config.config\n */\n\n\nmodule.exports = ({\n  options = {},\n  peerId,\n  multiaddrs = [],\n  repo,\n  keychainConfig = {},\n  config = {}\n}) => {\n  const {\n    datastore,\n    keys\n  } = repo;\n  const libp2pOptions = getLibp2pOptions({\n    options,\n    config,\n    datastore,\n    keys,\n    keychainConfig,\n    peerId,\n    multiaddrs\n  });\n\n  if (typeof options.libp2p === 'function') {\n    return options.libp2p({\n      libp2pOptions,\n      options,\n      config,\n      datastore,\n      peerId\n    });\n  } // Required inline to reduce startup time\n\n\n  const Libp2p = require('libp2p');\n\n  return Libp2p.create(libp2pOptions);\n};\n/**\n * @param {Object} input\n * @param {IPFSOptions} input.options\n * @param {Partial<IPFSConfig>} input.config\n * @param {Repo['datastore']} input.datastore\n * @param {Repo['keys']} input.keys\n * @param {KeychainConfig} input.keychainConfig\n * @param {PeerId} input.peerId\n * @param {Multiaddr[]} input.multiaddrs\n * @returns {Libp2pOptions}\n */\n\n\nfunction getLibp2pOptions({\n  options,\n  config,\n  datastore,\n  keys,\n  keychainConfig,\n  peerId,\n  multiaddrs\n}) {\n  const getPubsubRouter = () => {\n    const router = get(config, 'Pubsub.Router') || 'gossipsub'; // @ts-ignore - `router` value is not constrained\n\n    if (!PubsubRouters[router]) {\n      throw errCode(new Error(`Router unavailable. Configure libp2p.modules.pubsub to use the ${router} router.`), 'ERR_NOT_SUPPORTED');\n    } // @ts-ignore - `router` value is not constrained\n\n\n    return PubsubRouters[router];\n  };\n\n  const libp2pDefaults = {\n    datastore,\n    peerId: peerId,\n    modules: {}\n  };\n  const libp2pOptions = {\n    /**\n     * @type {Partial<Libp2pOptions[\"modules\"]>}\n     */\n    modules: {\n      pubsub: getPubsubRouter(),\n      contentRouting: [],\n      peerRouting: []\n    },\n    config: {\n      peerDiscovery: {\n        mdns: {\n          enabled: get(options, 'config.Discovery.MDNS.Enabled', get(config, 'Discovery.MDNS.Enabled', true))\n        },\n        webRTCStar: {\n          enabled: get(options, 'config.Discovery.webRTCStar.Enabled', get(config, 'Discovery.webRTCStar.Enabled', true))\n        },\n        bootstrap: {\n          list: get(options, 'config.Bootstrap', get(config, 'Bootstrap', []))\n        }\n      },\n      relay: {\n        enabled: get(options, 'relay.enabled', get(config, 'relay.enabled', true)),\n        hop: {\n          enabled: get(options, 'relay.hop.enabled', get(config, 'relay.hop.enabled', false)),\n          active: get(options, 'relay.hop.active', get(config, 'relay.hop.active', false))\n        }\n      },\n      dht: {\n        enabled: get(config, 'Routing.Type', 'none') !== 'none',\n        clientMode: get(config, 'Routing.Type', 'dht') !== 'dhtserver',\n        kBucketSize: get(options, 'dht.kBucketSize', 20)\n      },\n      pubsub: {\n        enabled: get(options, 'config.Pubsub.Enabled', get(config, 'Pubsub.Enabled', true))\n      },\n      nat: {\n        enabled: !get(config, 'Swarm.DisableNatPortMap', false)\n      }\n    },\n    addresses: {\n      listen: multiaddrs.map(ma => ma.toString()),\n      announce: get(options, 'addresses.announce', get(config, 'Addresses.Announce', [])),\n      noAnnounce: get(options, 'addresses.noAnnounce', get(config, 'Addresses.NoAnnounce', []))\n    },\n    connectionManager: get(options, 'connectionManager', {\n      maxConnections: get(options, 'config.Swarm.ConnMgr.HighWater', get(config, 'Swarm.ConnMgr.HighWater')),\n      minConnections: get(options, 'config.Swarm.ConnMgr.LowWater', get(config, 'Swarm.ConnMgr.LowWater'))\n    }),\n    keychain: {\n      datastore: keys,\n      ...keychainConfig\n    },\n    host: {\n      agentVersion: `js-ipfs/${pkgversion}`\n    }\n  }; // Required inline to reduce startup time\n  // Note: libp2p-nodejs gets replaced by libp2p-browser when webpacked/browserified\n\n  const getEnvLibp2pOptions = require('../runtime/libp2p-nodejs');\n  /** @type {import('libp2p').Libp2pOptions | undefined} */\n\n\n  let constructorOptions = get(options, 'libp2p', undefined);\n\n  if (typeof constructorOptions === 'function') {\n    constructorOptions = undefined;\n  } // Merge defaults with Node.js/browser/other environments options and configuration\n\n\n  const libp2pConfig = mergeOptions(libp2pDefaults, getEnvLibp2pOptions(), libp2pOptions, constructorOptions);\n  const bootstrapList = get(libp2pConfig, 'config.peerDiscovery.bootstrap.list', []);\n\n  if (bootstrapList.length > 0) {\n    libp2pConfig.modules.peerDiscovery.push(require('libp2p-bootstrap'));\n  } // Set up Delegate Routing based on the presence of Delegates in the config\n\n\n  const delegateHosts = get(options, 'config.Addresses.Delegates', get(config, 'Addresses.Delegates', []));\n\n  if (delegateHosts.length > 0) {\n    // Pick a random delegate host\n    const delegateString = delegateHosts[Math.floor(Math.random() * delegateHosts.length)];\n    const delegateAddr = new Multiaddr(delegateString).toOptions();\n    const delegateApiOptions = {\n      host: delegateAddr.host,\n      // port is a string atm, so we need to convert for the check\n      // @ts-ignore - parseInt(input:string) => number\n      protocol: parseInt(delegateAddr.port) === 443 ? 'https' : 'http',\n      port: delegateAddr.port\n    };\n    const delegateHttpClient = ipfsHttpClient(delegateApiOptions);\n    libp2pOptions.modules.contentRouting = libp2pOptions.modules.contentRouting || [];\n    libp2pOptions.modules.contentRouting.push(new DelegatedContentRouter(peerId, delegateHttpClient));\n    libp2pOptions.modules.peerRouting = libp2pOptions.modules.peerRouting || [];\n    libp2pOptions.modules.peerRouting.push(new DelegatedPeerRouter(delegateHttpClient));\n  }\n\n  return libp2pConfig;\n}","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/ipfs-core/src/components/libp2p.js"],"names":["get","require","mergeOptions","bind","ignoreUndefined","errCode","PubsubRouters","DelegatedPeerRouter","DelegatedContentRouter","create","ipfsHttpClient","Multiaddr","pkgversion","version","module","exports","options","peerId","multiaddrs","repo","keychainConfig","config","datastore","keys","libp2pOptions","getLibp2pOptions","libp2p","Libp2p","getPubsubRouter","router","Error","libp2pDefaults","modules","pubsub","contentRouting","peerRouting","peerDiscovery","mdns","enabled","webRTCStar","bootstrap","list","relay","hop","active","dht","clientMode","kBucketSize","nat","addresses","listen","map","ma","toString","announce","noAnnounce","connectionManager","maxConnections","minConnections","keychain","host","agentVersion","getEnvLibp2pOptions","constructorOptions","undefined","libp2pConfig","bootstrapList","length","push","delegateHosts","delegateString","Math","floor","random","delegateAddr","toOptions","delegateApiOptions","protocol","parseInt","port","delegateHttpClient"],"mappings":"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","sourcesContent":["'use strict'\n\nconst get = require('dlv')\nconst mergeOptions = require('merge-options').bind({ ignoreUndefined: true })\nconst errCode = require('err-code')\nconst PubsubRouters = require('../runtime/libp2p-pubsub-routers-nodejs')\n// @ts-ignore - no types\nconst DelegatedPeerRouter = require('libp2p-delegated-peer-routing')\n// @ts-ignore - no types\nconst DelegatedContentRouter = require('libp2p-delegated-content-routing')\nconst { create: ipfsHttpClient } = require('ipfs-http-client')\nconst { Multiaddr } = require('multiaddr')\nconst pkgversion = require('../../package.json').version\n\n/**\n * @typedef {object} DekOptions\n * @property {string} hash\n * @property {string} salt\n * @property {number} iterationCount\n * @property {number} keyLength\n *\n * @typedef {Object} KeychainConfig\n * @property {string} [pass]\n * @property {DekOptions} [dek]\n *\n * @typedef {import('ipfs-repo').IPFSRepo} Repo\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../types').Options} IPFSOptions\n * @typedef {import('libp2p')} LibP2P\n * @typedef {import('libp2p').Libp2pOptions & import('libp2p').CreateOptions} Libp2pOptions\n * @typedef {import('ipfs-core-types/src/config').Config} IPFSConfig\n */\n\n/**\n * @param {Object} config\n * @param {Repo} config.repo\n * @param {IPFSOptions|undefined} config.options\n * @param {PeerId} config.peerId\n * @param {Multiaddr[]|undefined} config.multiaddrs\n * @param {KeychainConfig|undefined} config.keychainConfig\n * @param {Partial<IPFSConfig>|undefined} config.config\n */\nmodule.exports = ({\n  options = {},\n  peerId,\n  multiaddrs = [],\n  repo,\n  keychainConfig = {},\n  config = {}\n}) => {\n  const { datastore, keys } = repo\n\n  const libp2pOptions = getLibp2pOptions({\n    options,\n    config,\n    datastore,\n    keys,\n    keychainConfig,\n    peerId,\n    multiaddrs\n  })\n\n  if (typeof options.libp2p === 'function') {\n    return options.libp2p({ libp2pOptions, options, config, datastore, peerId })\n  }\n\n  // Required inline to reduce startup time\n  const Libp2p = require('libp2p')\n\n  return Libp2p.create(libp2pOptions)\n}\n\n/**\n * @param {Object} input\n * @param {IPFSOptions} input.options\n * @param {Partial<IPFSConfig>} input.config\n * @param {Repo['datastore']} input.datastore\n * @param {Repo['keys']} input.keys\n * @param {KeychainConfig} input.keychainConfig\n * @param {PeerId} input.peerId\n * @param {Multiaddr[]} input.multiaddrs\n * @returns {Libp2pOptions}\n */\nfunction getLibp2pOptions ({ options, config, datastore, keys, keychainConfig, peerId, multiaddrs }) {\n  const getPubsubRouter = () => {\n    const router = get(config, 'Pubsub.Router') || 'gossipsub'\n\n    // @ts-ignore - `router` value is not constrained\n    if (!PubsubRouters[router]) {\n      throw errCode(new Error(`Router unavailable. Configure libp2p.modules.pubsub to use the ${router} router.`), 'ERR_NOT_SUPPORTED')\n    }\n\n    // @ts-ignore - `router` value is not constrained\n    return PubsubRouters[router]\n  }\n\n  const libp2pDefaults = {\n    datastore,\n    peerId: peerId,\n    modules: {}\n  }\n\n  const libp2pOptions = {\n    /**\n     * @type {Partial<Libp2pOptions[\"modules\"]>}\n     */\n    modules: {\n      pubsub: getPubsubRouter(),\n      contentRouting: [],\n      peerRouting: []\n    },\n    config: {\n      peerDiscovery: {\n        mdns: {\n          enabled: get(options, 'config.Discovery.MDNS.Enabled', get(config, 'Discovery.MDNS.Enabled', true))\n        },\n        webRTCStar: {\n          enabled: get(options, 'config.Discovery.webRTCStar.Enabled', get(config, 'Discovery.webRTCStar.Enabled', true))\n        },\n        bootstrap: {\n          list: get(options, 'config.Bootstrap', get(config, 'Bootstrap', []))\n        }\n      },\n      relay: {\n        enabled: get(options, 'relay.enabled', get(config, 'relay.enabled', true)),\n        hop: {\n          enabled: get(options, 'relay.hop.enabled', get(config, 'relay.hop.enabled', false)),\n          active: get(options, 'relay.hop.active', get(config, 'relay.hop.active', false))\n        }\n      },\n      dht: {\n        enabled: get(config, 'Routing.Type', 'none') !== 'none',\n        clientMode: get(config, 'Routing.Type', 'dht') !== 'dhtserver',\n        kBucketSize: get(options, 'dht.kBucketSize', 20)\n      },\n      pubsub: {\n        enabled: get(options, 'config.Pubsub.Enabled', get(config, 'Pubsub.Enabled', true))\n      },\n      nat: {\n        enabled: !get(config, 'Swarm.DisableNatPortMap', false)\n      }\n    },\n    addresses: {\n      listen: multiaddrs.map(ma => ma.toString()),\n      announce: get(options, 'addresses.announce', get(config, 'Addresses.Announce', [])),\n      noAnnounce: get(options, 'addresses.noAnnounce', get(config, 'Addresses.NoAnnounce', []))\n    },\n    connectionManager: get(options, 'connectionManager', {\n      maxConnections: get(options, 'config.Swarm.ConnMgr.HighWater', get(config, 'Swarm.ConnMgr.HighWater')),\n      minConnections: get(options, 'config.Swarm.ConnMgr.LowWater', get(config, 'Swarm.ConnMgr.LowWater'))\n    }),\n    keychain: {\n      datastore: keys,\n      ...keychainConfig\n    },\n    host: {\n      agentVersion: `js-ipfs/${pkgversion}`\n    }\n  }\n\n  // Required inline to reduce startup time\n  // Note: libp2p-nodejs gets replaced by libp2p-browser when webpacked/browserified\n  const getEnvLibp2pOptions = require('../runtime/libp2p-nodejs')\n\n  /** @type {import('libp2p').Libp2pOptions | undefined} */\n  let constructorOptions = get(options, 'libp2p', undefined)\n\n  if (typeof constructorOptions === 'function') {\n    constructorOptions = undefined\n  }\n\n  // Merge defaults with Node.js/browser/other environments options and configuration\n  const libp2pConfig = mergeOptions(\n    libp2pDefaults,\n    getEnvLibp2pOptions(),\n    libp2pOptions,\n    constructorOptions\n  )\n\n  const bootstrapList = get(libp2pConfig, 'config.peerDiscovery.bootstrap.list', [])\n\n  if (bootstrapList.length > 0) {\n    libp2pConfig.modules.peerDiscovery.push(require('libp2p-bootstrap'))\n  }\n\n  // Set up Delegate Routing based on the presence of Delegates in the config\n  const delegateHosts = get(options, 'config.Addresses.Delegates',\n    get(config, 'Addresses.Delegates', [])\n  )\n\n  if (delegateHosts.length > 0) {\n    // Pick a random delegate host\n    const delegateString = delegateHosts[Math.floor(Math.random() * delegateHosts.length)]\n    const delegateAddr = new Multiaddr(delegateString).toOptions()\n    const delegateApiOptions = {\n      host: delegateAddr.host,\n      // port is a string atm, so we need to convert for the check\n      // @ts-ignore - parseInt(input:string) => number\n      protocol: parseInt(delegateAddr.port) === 443 ? 'https' : 'http',\n      port: delegateAddr.port\n    }\n\n    const delegateHttpClient = ipfsHttpClient(delegateApiOptions)\n\n    libp2pOptions.modules.contentRouting = libp2pOptions.modules.contentRouting || []\n    libp2pOptions.modules.contentRouting.push(new DelegatedContentRouter(peerId, delegateHttpClient))\n\n    libp2pOptions.modules.peerRouting = libp2pOptions.modules.peerRouting || []\n    libp2pOptions.modules.peerRouting.push(new DelegatedPeerRouter(delegateHttpClient))\n  }\n\n  return libp2pConfig\n}\n"]},"metadata":{},"sourceType":"script"}