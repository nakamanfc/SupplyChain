{"ast":null,"code":"/* global indexedDB */\n'use strict';\n\nmodule.exports = Level;\n\nconst AbstractLevelDOWN = require('abstract-leveldown').AbstractLevelDOWN;\n\nconst inherits = require('inherits');\n\nconst Iterator = require('./iterator');\n\nconst serialize = require('./util/serialize');\n\nconst deserialize = require('./util/deserialize');\n\nconst support = require('./util/support');\n\nconst clear = require('./util/clear');\n\nconst createKeyRange = require('./util/key-range');\n\nconst DEFAULT_PREFIX = 'level-js-';\n\nfunction Level(location, opts) {\n  if (!(this instanceof Level)) return new Level(location, opts);\n  AbstractLevelDOWN.call(this, {\n    bufferKeys: support.bufferKeys(indexedDB),\n    snapshots: true,\n    permanence: true,\n    clear: true\n  });\n  opts = opts || {};\n\n  if (typeof location !== 'string') {\n    throw new Error('constructor requires a location string argument');\n  }\n\n  this.location = location;\n  this.prefix = opts.prefix == null ? DEFAULT_PREFIX : opts.prefix;\n  this.version = parseInt(opts.version || 1, 10);\n}\n\ninherits(Level, AbstractLevelDOWN);\nLevel.prototype.type = 'level-js';\n\nLevel.prototype._open = function (options, callback) {\n  const req = indexedDB.open(this.prefix + this.location, this.version);\n\n  req.onerror = function () {\n    callback(req.error || new Error('unknown error'));\n  };\n\n  req.onsuccess = () => {\n    this.db = req.result;\n    callback();\n  };\n\n  req.onupgradeneeded = ev => {\n    const db = ev.target.result;\n\n    if (!db.objectStoreNames.contains(this.location)) {\n      db.createObjectStore(this.location);\n    }\n  };\n};\n\nLevel.prototype.store = function (mode) {\n  const transaction = this.db.transaction([this.location], mode);\n  return transaction.objectStore(this.location);\n};\n\nLevel.prototype.await = function (request, callback) {\n  const transaction = request.transaction; // Take advantage of the fact that a non-canceled request error aborts\n  // the transaction. I.e. no need to listen for \"request.onerror\".\n\n  transaction.onabort = function () {\n    callback(transaction.error || new Error('aborted by user'));\n  };\n\n  transaction.oncomplete = function () {\n    callback(null, request.result);\n  };\n};\n\nLevel.prototype._get = function (key, options, callback) {\n  const store = this.store('readonly');\n  let req;\n\n  try {\n    req = store.get(key);\n  } catch (err) {\n    return this._nextTick(callback, err);\n  }\n\n  this.await(req, function (err, value) {\n    if (err) return callback(err);\n\n    if (value === undefined) {\n      // 'NotFound' error, consistent with LevelDOWN API\n      return callback(new Error('NotFound'));\n    }\n\n    callback(null, deserialize(value, options.asBuffer));\n  });\n};\n\nLevel.prototype._del = function (key, options, callback) {\n  const store = this.store('readwrite');\n  let req;\n\n  try {\n    req = store.delete(key);\n  } catch (err) {\n    return this._nextTick(callback, err);\n  }\n\n  this.await(req, callback);\n};\n\nLevel.prototype._put = function (key, value, options, callback) {\n  const store = this.store('readwrite');\n  let req;\n\n  try {\n    // Will throw a DataError or DataCloneError if the environment\n    // does not support serializing the key or value respectively.\n    req = store.put(value, key);\n  } catch (err) {\n    return this._nextTick(callback, err);\n  }\n\n  this.await(req, callback);\n};\n\nLevel.prototype._serializeKey = function (key) {\n  return serialize(key, this.supports.bufferKeys);\n};\n\nLevel.prototype._serializeValue = function (value) {\n  return serialize(value, true);\n};\n\nLevel.prototype._iterator = function (options) {\n  return new Iterator(this, this.location, options);\n};\n\nLevel.prototype._batch = function (operations, options, callback) {\n  if (operations.length === 0) return this._nextTick(callback);\n  const store = this.store('readwrite');\n  const transaction = store.transaction;\n  let index = 0;\n  let error;\n\n  transaction.onabort = function () {\n    callback(error || transaction.error || new Error('aborted by user'));\n  };\n\n  transaction.oncomplete = function () {\n    callback();\n  }; // Wait for a request to complete before making the next, saving CPU.\n\n\n  function loop() {\n    const op = operations[index++];\n    const key = op.key;\n    let req;\n\n    try {\n      req = op.type === 'del' ? store.delete(key) : store.put(op.value, key);\n    } catch (err) {\n      error = err;\n      transaction.abort();\n      return;\n    }\n\n    if (index < operations.length) {\n      req.onsuccess = loop;\n    }\n  }\n\n  loop();\n};\n\nLevel.prototype._clear = function (options, callback) {\n  let keyRange;\n  let req;\n\n  try {\n    keyRange = createKeyRange(options);\n  } catch (e) {\n    // The lower key is greater than the upper key.\n    // IndexedDB throws an error, but we'll just do nothing.\n    return this._nextTick(callback);\n  }\n\n  if (options.limit >= 0) {\n    // IDBObjectStore#delete(range) doesn't have such an option.\n    // Fall back to cursor-based implementation.\n    return clear(this, this.location, keyRange, options, callback);\n  }\n\n  try {\n    const store = this.store('readwrite');\n    req = keyRange ? store.delete(keyRange) : store.clear();\n  } catch (err) {\n    return this._nextTick(callback, err);\n  }\n\n  this.await(req, callback);\n};\n\nLevel.prototype._close = function (callback) {\n  this.db.close();\n\n  this._nextTick(callback);\n}; // NOTE: remove in a next major release\n\n\nLevel.prototype.upgrade = function (callback) {\n  if (this.status !== 'open') {\n    return this._nextTick(callback, new Error('cannot upgrade() before open()'));\n  }\n\n  const it = this.iterator();\n  const batchOptions = {};\n  const self = this;\n  it._deserializeKey = it._deserializeValue = identity;\n  next();\n\n  function next(err) {\n    if (err) return finish(err);\n    it.next(each);\n  }\n\n  function each(err, key, value) {\n    if (err || key === undefined) {\n      return finish(err);\n    }\n\n    const newKey = self._serializeKey(deserialize(key, true));\n\n    const newValue = self._serializeValue(deserialize(value, true)); // To bypass serialization on the old key, use _batch() instead of batch().\n    // NOTE: if we disable snapshotting (#86) this could lead to a loop of\n    // inserting and then iterating those same entries, because the new keys\n    // possibly sort after the old keys.\n\n\n    self._batch([{\n      type: 'del',\n      key: key\n    }, {\n      type: 'put',\n      key: newKey,\n      value: newValue\n    }], batchOptions, next);\n  }\n\n  function finish(err) {\n    it.end(function (err2) {\n      callback(err || err2);\n    });\n  }\n\n  function identity(data) {\n    return data;\n  }\n};\n\nLevel.destroy = function (location, prefix, callback) {\n  if (typeof prefix === 'function') {\n    callback = prefix;\n    prefix = DEFAULT_PREFIX;\n  }\n\n  const request = indexedDB.deleteDatabase(prefix + location);\n\n  request.onsuccess = function () {\n    callback();\n  };\n\n  request.onerror = function (err) {\n    callback(err);\n  };\n};","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/level-js/index.js"],"names":["module","exports","Level","AbstractLevelDOWN","require","inherits","Iterator","serialize","deserialize","support","clear","createKeyRange","DEFAULT_PREFIX","location","opts","call","bufferKeys","indexedDB","snapshots","permanence","Error","prefix","version","parseInt","prototype","type","_open","options","callback","req","open","onerror","error","onsuccess","db","result","onupgradeneeded","ev","target","objectStoreNames","contains","createObjectStore","store","mode","transaction","objectStore","await","request","onabort","oncomplete","_get","key","get","err","_nextTick","value","undefined","asBuffer","_del","delete","_put","put","_serializeKey","supports","_serializeValue","_iterator","_batch","operations","length","index","loop","op","abort","_clear","keyRange","e","limit","_close","close","upgrade","status","it","iterator","batchOptions","self","_deserializeKey","_deserializeValue","identity","next","finish","each","newKey","newValue","end","err2","data","destroy","deleteDatabase"],"mappings":"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","sourcesContent":["/* global indexedDB */\n\n'use strict'\n\nmodule.exports = Level\n\nconst AbstractLevelDOWN = require('abstract-leveldown').AbstractLevelDOWN\nconst inherits = require('inherits')\nconst Iterator = require('./iterator')\nconst serialize = require('./util/serialize')\nconst deserialize = require('./util/deserialize')\nconst support = require('./util/support')\nconst clear = require('./util/clear')\nconst createKeyRange = require('./util/key-range')\n\nconst DEFAULT_PREFIX = 'level-js-'\n\nfunction Level (location, opts) {\n  if (!(this instanceof Level)) return new Level(location, opts)\n\n  AbstractLevelDOWN.call(this, {\n    bufferKeys: support.bufferKeys(indexedDB),\n    snapshots: true,\n    permanence: true,\n    clear: true\n  })\n\n  opts = opts || {}\n\n  if (typeof location !== 'string') {\n    throw new Error('constructor requires a location string argument')\n  }\n\n  this.location = location\n  this.prefix = opts.prefix == null ? DEFAULT_PREFIX : opts.prefix\n  this.version = parseInt(opts.version || 1, 10)\n}\n\ninherits(Level, AbstractLevelDOWN)\n\nLevel.prototype.type = 'level-js'\n\nLevel.prototype._open = function (options, callback) {\n  const req = indexedDB.open(this.prefix + this.location, this.version)\n\n  req.onerror = function () {\n    callback(req.error || new Error('unknown error'))\n  }\n\n  req.onsuccess = () => {\n    this.db = req.result\n    callback()\n  }\n\n  req.onupgradeneeded = (ev) => {\n    const db = ev.target.result\n\n    if (!db.objectStoreNames.contains(this.location)) {\n      db.createObjectStore(this.location)\n    }\n  }\n}\n\nLevel.prototype.store = function (mode) {\n  const transaction = this.db.transaction([this.location], mode)\n  return transaction.objectStore(this.location)\n}\n\nLevel.prototype.await = function (request, callback) {\n  const transaction = request.transaction\n\n  // Take advantage of the fact that a non-canceled request error aborts\n  // the transaction. I.e. no need to listen for \"request.onerror\".\n  transaction.onabort = function () {\n    callback(transaction.error || new Error('aborted by user'))\n  }\n\n  transaction.oncomplete = function () {\n    callback(null, request.result)\n  }\n}\n\nLevel.prototype._get = function (key, options, callback) {\n  const store = this.store('readonly')\n  let req\n\n  try {\n    req = store.get(key)\n  } catch (err) {\n    return this._nextTick(callback, err)\n  }\n\n  this.await(req, function (err, value) {\n    if (err) return callback(err)\n\n    if (value === undefined) {\n      // 'NotFound' error, consistent with LevelDOWN API\n      return callback(new Error('NotFound'))\n    }\n\n    callback(null, deserialize(value, options.asBuffer))\n  })\n}\n\nLevel.prototype._del = function (key, options, callback) {\n  const store = this.store('readwrite')\n  let req\n\n  try {\n    req = store.delete(key)\n  } catch (err) {\n    return this._nextTick(callback, err)\n  }\n\n  this.await(req, callback)\n}\n\nLevel.prototype._put = function (key, value, options, callback) {\n  const store = this.store('readwrite')\n  let req\n\n  try {\n    // Will throw a DataError or DataCloneError if the environment\n    // does not support serializing the key or value respectively.\n    req = store.put(value, key)\n  } catch (err) {\n    return this._nextTick(callback, err)\n  }\n\n  this.await(req, callback)\n}\n\nLevel.prototype._serializeKey = function (key) {\n  return serialize(key, this.supports.bufferKeys)\n}\n\nLevel.prototype._serializeValue = function (value) {\n  return serialize(value, true)\n}\n\nLevel.prototype._iterator = function (options) {\n  return new Iterator(this, this.location, options)\n}\n\nLevel.prototype._batch = function (operations, options, callback) {\n  if (operations.length === 0) return this._nextTick(callback)\n\n  const store = this.store('readwrite')\n  const transaction = store.transaction\n  let index = 0\n  let error\n\n  transaction.onabort = function () {\n    callback(error || transaction.error || new Error('aborted by user'))\n  }\n\n  transaction.oncomplete = function () {\n    callback()\n  }\n\n  // Wait for a request to complete before making the next, saving CPU.\n  function loop () {\n    const op = operations[index++]\n    const key = op.key\n\n    let req\n\n    try {\n      req = op.type === 'del' ? store.delete(key) : store.put(op.value, key)\n    } catch (err) {\n      error = err\n      transaction.abort()\n      return\n    }\n\n    if (index < operations.length) {\n      req.onsuccess = loop\n    }\n  }\n\n  loop()\n}\n\nLevel.prototype._clear = function (options, callback) {\n  let keyRange\n  let req\n\n  try {\n    keyRange = createKeyRange(options)\n  } catch (e) {\n    // The lower key is greater than the upper key.\n    // IndexedDB throws an error, but we'll just do nothing.\n    return this._nextTick(callback)\n  }\n\n  if (options.limit >= 0) {\n    // IDBObjectStore#delete(range) doesn't have such an option.\n    // Fall back to cursor-based implementation.\n    return clear(this, this.location, keyRange, options, callback)\n  }\n\n  try {\n    const store = this.store('readwrite')\n    req = keyRange ? store.delete(keyRange) : store.clear()\n  } catch (err) {\n    return this._nextTick(callback, err)\n  }\n\n  this.await(req, callback)\n}\n\nLevel.prototype._close = function (callback) {\n  this.db.close()\n  this._nextTick(callback)\n}\n\n// NOTE: remove in a next major release\nLevel.prototype.upgrade = function (callback) {\n  if (this.status !== 'open') {\n    return this._nextTick(callback, new Error('cannot upgrade() before open()'))\n  }\n\n  const it = this.iterator()\n  const batchOptions = {}\n  const self = this\n\n  it._deserializeKey = it._deserializeValue = identity\n  next()\n\n  function next (err) {\n    if (err) return finish(err)\n    it.next(each)\n  }\n\n  function each (err, key, value) {\n    if (err || key === undefined) {\n      return finish(err)\n    }\n\n    const newKey = self._serializeKey(deserialize(key, true))\n    const newValue = self._serializeValue(deserialize(value, true))\n\n    // To bypass serialization on the old key, use _batch() instead of batch().\n    // NOTE: if we disable snapshotting (#86) this could lead to a loop of\n    // inserting and then iterating those same entries, because the new keys\n    // possibly sort after the old keys.\n    self._batch([\n      { type: 'del', key: key },\n      { type: 'put', key: newKey, value: newValue }\n    ], batchOptions, next)\n  }\n\n  function finish (err) {\n    it.end(function (err2) {\n      callback(err || err2)\n    })\n  }\n\n  function identity (data) {\n    return data\n  }\n}\n\nLevel.destroy = function (location, prefix, callback) {\n  if (typeof prefix === 'function') {\n    callback = prefix\n    prefix = DEFAULT_PREFIX\n  }\n  const request = indexedDB.deleteDatabase(prefix + location)\n  request.onsuccess = function () {\n    callback()\n  }\n  request.onerror = function (err) {\n    callback(err)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}