{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar errCode = require('err-code');\n\nvar cid = require('multiformats/cid');\n\nvar index = require('./resolvers/index.js');\n\nvar last = require('it-last');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\n\nvar last__default = /*#__PURE__*/_interopDefaultLegacy(last);\n\nconst toPathComponents = (path = '') => {\n  return (path.trim().match(/([^\\\\^/]|\\\\\\/)+/g) || []).filter(Boolean);\n};\n\nconst cidAndRest = path => {\n  if (path instanceof Uint8Array) {\n    return {\n      cid: cid.CID.decode(path),\n      toResolve: []\n    };\n  }\n\n  const cid$1 = cid.CID.asCID(path);\n\n  if (cid$1) {\n    return {\n      cid: cid$1,\n      toResolve: []\n    };\n  }\n\n  if (typeof path === 'string') {\n    if (path.indexOf('/ipfs/') === 0) {\n      path = path.substring(6);\n    }\n\n    const output = toPathComponents(path);\n    return {\n      cid: cid.CID.parse(output[0]),\n      toResolve: output.slice(1)\n    };\n  }\n\n  throw errCode__default['default'](new Error(`Unknown path type ${path}`), 'ERR_BAD_PATH');\n};\n\nasync function* walkPath(path, blockstore, options = {}) {\n  let {\n    cid,\n    toResolve\n  } = cidAndRest(path);\n  let name = cid.toString();\n  let entryPath = name;\n  const startingDepth = toResolve.length;\n\n  while (true) {\n    const result = await index(cid, name, entryPath, toResolve, startingDepth, blockstore, options);\n\n    if (!result.entry && !result.next) {\n      throw errCode__default['default'](new Error(`Could not resolve ${path}`), 'ERR_NOT_FOUND');\n    }\n\n    if (result.entry) {\n      yield result.entry;\n    }\n\n    if (!result.next) {\n      return;\n    }\n\n    toResolve = result.next.toResolve;\n    cid = result.next.cid;\n    name = result.next.name;\n    entryPath = result.next.path;\n  }\n}\n\nasync function exporter(path, blockstore, options = {}) {\n  const result = await last__default['default'](walkPath(path, blockstore, options));\n\n  if (!result) {\n    throw errCode__default['default'](new Error(`Could not resolve ${path}`), 'ERR_NOT_FOUND');\n  }\n\n  return result;\n}\n\nasync function* recursive(path, blockstore, options = {}) {\n  const node = await exporter(path, blockstore, options);\n\n  if (!node) {\n    return;\n  }\n\n  yield node;\n\n  if (node.type === 'directory') {\n    for await (const child of recurse(node, options)) {\n      yield child;\n    }\n  }\n\n  async function* recurse(node, options) {\n    for await (const file of node.content(options)) {\n      yield file;\n\n      if (file instanceof Uint8Array) {\n        continue;\n      }\n\n      if (file.type === 'directory') {\n        yield* recurse(file, options);\n      }\n    }\n  }\n}\n\nexports.exporter = exporter;\nexports.recursive = recursive;\nexports.walkPath = walkPath;","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/ipfs-unixfs-exporter/cjs/src/index.js"],"names":["Object","defineProperty","exports","value","errCode","require","cid","index","last","_interopDefaultLegacy","e","errCode__default","last__default","toPathComponents","path","trim","match","filter","Boolean","cidAndRest","Uint8Array","CID","decode","toResolve","cid$1","asCID","indexOf","substring","output","parse","slice","Error","walkPath","blockstore","options","name","toString","entryPath","startingDepth","length","result","entry","next","exporter","recursive","node","type","child","recurse","file","content"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AAEA,IAAIC,OAAO,GAAGC,OAAO,CAAC,UAAD,CAArB;;AACA,IAAIC,GAAG,GAAGD,OAAO,CAAC,kBAAD,CAAjB;;AACA,IAAIE,KAAK,GAAGF,OAAO,CAAC,sBAAD,CAAnB;;AACA,IAAIG,IAAI,GAAGH,OAAO,CAAC,SAAD,CAAlB;;AAEA,SAASI,qBAAT,CAAgCC,CAAhC,EAAmC;AAAE,SAAOA,CAAC,IAAI,OAAOA,CAAP,KAAa,QAAlB,IAA8B,aAAaA,CAA3C,GAA+CA,CAA/C,GAAmD;AAAE,eAAWA;AAAb,GAA1D;AAA6E;;AAElH,IAAIC,gBAAgB,GAAG,aAAaF,qBAAqB,CAACL,OAAD,CAAzD;;AACA,IAAIQ,aAAa,GAAG,aAAaH,qBAAqB,CAACD,IAAD,CAAtD;;AAEA,MAAMK,gBAAgB,GAAG,CAACC,IAAI,GAAG,EAAR,KAAe;AACtC,SAAO,CAACA,IAAI,CAACC,IAAL,GAAYC,KAAZ,CAAkB,kBAAlB,KAAyC,EAA1C,EAA8CC,MAA9C,CAAqDC,OAArD,CAAP;AACD,CAFD;;AAGA,MAAMC,UAAU,GAAGL,IAAI,IAAI;AACzB,MAAIA,IAAI,YAAYM,UAApB,EAAgC;AAC9B,WAAO;AACLd,MAAAA,GAAG,EAAEA,GAAG,CAACe,GAAJ,CAAQC,MAAR,CAAeR,IAAf,CADA;AAELS,MAAAA,SAAS,EAAE;AAFN,KAAP;AAID;;AACD,QAAMC,KAAK,GAAGlB,GAAG,CAACe,GAAJ,CAAQI,KAAR,CAAcX,IAAd,CAAd;;AACA,MAAIU,KAAJ,EAAW;AACT,WAAO;AACLlB,MAAAA,GAAG,EAAEkB,KADA;AAELD,MAAAA,SAAS,EAAE;AAFN,KAAP;AAID;;AACD,MAAI,OAAOT,IAAP,KAAgB,QAApB,EAA8B;AAC5B,QAAIA,IAAI,CAACY,OAAL,CAAa,QAAb,MAA2B,CAA/B,EAAkC;AAChCZ,MAAAA,IAAI,GAAGA,IAAI,CAACa,SAAL,CAAe,CAAf,CAAP;AACD;;AACD,UAAMC,MAAM,GAAGf,gBAAgB,CAACC,IAAD,CAA/B;AACA,WAAO;AACLR,MAAAA,GAAG,EAAEA,GAAG,CAACe,GAAJ,CAAQQ,KAAR,CAAcD,MAAM,CAAC,CAAD,CAApB,CADA;AAELL,MAAAA,SAAS,EAAEK,MAAM,CAACE,KAAP,CAAa,CAAb;AAFN,KAAP;AAID;;AACD,QAAMnB,gBAAgB,CAAC,SAAD,CAAhB,CAA4B,IAAIoB,KAAJ,CAAW,qBAAqBjB,IAAM,EAAtC,CAA5B,EAAsE,cAAtE,CAAN;AACD,CAzBD;;AA0BA,gBAAgBkB,QAAhB,CAAyBlB,IAAzB,EAA+BmB,UAA/B,EAA2CC,OAAO,GAAG,EAArD,EAAyD;AACvD,MAAI;AAAC5B,IAAAA,GAAD;AAAMiB,IAAAA;AAAN,MAAmBJ,UAAU,CAACL,IAAD,CAAjC;AACA,MAAIqB,IAAI,GAAG7B,GAAG,CAAC8B,QAAJ,EAAX;AACA,MAAIC,SAAS,GAAGF,IAAhB;AACA,QAAMG,aAAa,GAAGf,SAAS,CAACgB,MAAhC;;AACA,SAAO,IAAP,EAAa;AACX,UAAMC,MAAM,GAAG,MAAMjC,KAAK,CAACD,GAAD,EAAM6B,IAAN,EAAYE,SAAZ,EAAuBd,SAAvB,EAAkCe,aAAlC,EAAiDL,UAAjD,EAA6DC,OAA7D,CAA1B;;AACA,QAAI,CAACM,MAAM,CAACC,KAAR,IAAiB,CAACD,MAAM,CAACE,IAA7B,EAAmC;AACjC,YAAM/B,gBAAgB,CAAC,SAAD,CAAhB,CAA4B,IAAIoB,KAAJ,CAAW,qBAAqBjB,IAAM,EAAtC,CAA5B,EAAsE,eAAtE,CAAN;AACD;;AACD,QAAI0B,MAAM,CAACC,KAAX,EAAkB;AAChB,YAAMD,MAAM,CAACC,KAAb;AACD;;AACD,QAAI,CAACD,MAAM,CAACE,IAAZ,EAAkB;AAChB;AACD;;AACDnB,IAAAA,SAAS,GAAGiB,MAAM,CAACE,IAAP,CAAYnB,SAAxB;AACAjB,IAAAA,GAAG,GAAGkC,MAAM,CAACE,IAAP,CAAYpC,GAAlB;AACA6B,IAAAA,IAAI,GAAGK,MAAM,CAACE,IAAP,CAAYP,IAAnB;AACAE,IAAAA,SAAS,GAAGG,MAAM,CAACE,IAAP,CAAY5B,IAAxB;AACD;AACF;;AACD,eAAe6B,QAAf,CAAwB7B,IAAxB,EAA8BmB,UAA9B,EAA0CC,OAAO,GAAG,EAApD,EAAwD;AACtD,QAAMM,MAAM,GAAG,MAAM5B,aAAa,CAAC,SAAD,CAAb,CAAyBoB,QAAQ,CAAClB,IAAD,EAAOmB,UAAP,EAAmBC,OAAnB,CAAjC,CAArB;;AACA,MAAI,CAACM,MAAL,EAAa;AACX,UAAM7B,gBAAgB,CAAC,SAAD,CAAhB,CAA4B,IAAIoB,KAAJ,CAAW,qBAAqBjB,IAAM,EAAtC,CAA5B,EAAsE,eAAtE,CAAN;AACD;;AACD,SAAO0B,MAAP;AACD;;AACD,gBAAgBI,SAAhB,CAA0B9B,IAA1B,EAAgCmB,UAAhC,EAA4CC,OAAO,GAAG,EAAtD,EAA0D;AACxD,QAAMW,IAAI,GAAG,MAAMF,QAAQ,CAAC7B,IAAD,EAAOmB,UAAP,EAAmBC,OAAnB,CAA3B;;AACA,MAAI,CAACW,IAAL,EAAW;AACT;AACD;;AACD,QAAMA,IAAN;;AACA,MAAIA,IAAI,CAACC,IAAL,KAAc,WAAlB,EAA+B;AAC7B,eAAW,MAAMC,KAAjB,IAA0BC,OAAO,CAACH,IAAD,EAAOX,OAAP,CAAjC,EAAkD;AAChD,YAAMa,KAAN;AACD;AACF;;AACD,kBAAgBC,OAAhB,CAAwBH,IAAxB,EAA8BX,OAA9B,EAAuC;AACrC,eAAW,MAAMe,IAAjB,IAAyBJ,IAAI,CAACK,OAAL,CAAahB,OAAb,CAAzB,EAAgD;AAC9C,YAAMe,IAAN;;AACA,UAAIA,IAAI,YAAY7B,UAApB,EAAgC;AAC9B;AACD;;AACD,UAAI6B,IAAI,CAACH,IAAL,KAAc,WAAlB,EAA+B;AAC7B,eAAOE,OAAO,CAACC,IAAD,EAAOf,OAAP,CAAd;AACD;AACF;AACF;AACF;;AAEDhC,OAAO,CAACyC,QAAR,GAAmBA,QAAnB;AACAzC,OAAO,CAAC0C,SAAR,GAAoBA,SAApB;AACA1C,OAAO,CAAC8B,QAAR,GAAmBA,QAAnB","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar errCode = require('err-code');\nvar cid = require('multiformats/cid');\nvar index = require('./resolvers/index.js');\nvar last = require('it-last');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\nvar last__default = /*#__PURE__*/_interopDefaultLegacy(last);\n\nconst toPathComponents = (path = '') => {\n  return (path.trim().match(/([^\\\\^/]|\\\\\\/)+/g) || []).filter(Boolean);\n};\nconst cidAndRest = path => {\n  if (path instanceof Uint8Array) {\n    return {\n      cid: cid.CID.decode(path),\n      toResolve: []\n    };\n  }\n  const cid$1 = cid.CID.asCID(path);\n  if (cid$1) {\n    return {\n      cid: cid$1,\n      toResolve: []\n    };\n  }\n  if (typeof path === 'string') {\n    if (path.indexOf('/ipfs/') === 0) {\n      path = path.substring(6);\n    }\n    const output = toPathComponents(path);\n    return {\n      cid: cid.CID.parse(output[0]),\n      toResolve: output.slice(1)\n    };\n  }\n  throw errCode__default['default'](new Error(`Unknown path type ${ path }`), 'ERR_BAD_PATH');\n};\nasync function* walkPath(path, blockstore, options = {}) {\n  let {cid, toResolve} = cidAndRest(path);\n  let name = cid.toString();\n  let entryPath = name;\n  const startingDepth = toResolve.length;\n  while (true) {\n    const result = await index(cid, name, entryPath, toResolve, startingDepth, blockstore, options);\n    if (!result.entry && !result.next) {\n      throw errCode__default['default'](new Error(`Could not resolve ${ path }`), 'ERR_NOT_FOUND');\n    }\n    if (result.entry) {\n      yield result.entry;\n    }\n    if (!result.next) {\n      return;\n    }\n    toResolve = result.next.toResolve;\n    cid = result.next.cid;\n    name = result.next.name;\n    entryPath = result.next.path;\n  }\n}\nasync function exporter(path, blockstore, options = {}) {\n  const result = await last__default['default'](walkPath(path, blockstore, options));\n  if (!result) {\n    throw errCode__default['default'](new Error(`Could not resolve ${ path }`), 'ERR_NOT_FOUND');\n  }\n  return result;\n}\nasync function* recursive(path, blockstore, options = {}) {\n  const node = await exporter(path, blockstore, options);\n  if (!node) {\n    return;\n  }\n  yield node;\n  if (node.type === 'directory') {\n    for await (const child of recurse(node, options)) {\n      yield child;\n    }\n  }\n  async function* recurse(node, options) {\n    for await (const file of node.content(options)) {\n      yield file;\n      if (file instanceof Uint8Array) {\n        continue;\n      }\n      if (file.type === 'directory') {\n        yield* recurse(file, options);\n      }\n    }\n  }\n}\n\nexports.exporter = exporter;\nexports.recursive = recursive;\nexports.walkPath = walkPath;\n"]},"metadata":{},"sourceType":"script"}