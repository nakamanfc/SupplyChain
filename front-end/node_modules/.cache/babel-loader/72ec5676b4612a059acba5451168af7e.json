{"ast":null,"code":"'use strict';\n\nconst {\n  Multiaddr\n} = require('multiaddr');\n\nconst PeerId = require('peer-id');\n\nconst arrayEquals = require('libp2p-utils/src/array-equals');\n\nconst {\n  PeerRecord: Protobuf\n} = require('./peer-record');\n\nconst {\n  ENVELOPE_DOMAIN_PEER_RECORD,\n  ENVELOPE_PAYLOAD_TYPE_PEER_RECORD\n} = require('./consts');\n/**\n * @typedef {import('../../peer-store/address-book.js').Address} Address\n * @typedef {import('libp2p-interfaces/src/record/types').Record} Record\n */\n\n/**\n * @implements {Record}\n */\n\n\nclass PeerRecord {\n  /**\n   * The PeerRecord is used for distributing peer routing records across the network.\n   * It contains the peer's reachable listen addresses.\n   *\n   * @class\n   * @param {Object} params\n   * @param {PeerId} params.peerId\n   * @param {Multiaddr[]} params.multiaddrs - addresses of the associated peer.\n   * @param {number} [params.seqNumber] - monotonically-increasing sequence counter that's used to order PeerRecords in time.\n   */\n  constructor({\n    peerId,\n    multiaddrs = [],\n    seqNumber = Date.now()\n  }) {\n    this.domain = ENVELOPE_DOMAIN_PEER_RECORD;\n    this.codec = ENVELOPE_PAYLOAD_TYPE_PEER_RECORD;\n    this.peerId = peerId;\n    this.multiaddrs = multiaddrs;\n    this.seqNumber = seqNumber; // Cache\n\n    this._marshal = undefined;\n  }\n  /**\n   * Marshal a record to be used in an envelope.\n   *\n   * @returns {Uint8Array}\n   */\n\n\n  marshal() {\n    if (this._marshal) {\n      return this._marshal;\n    }\n\n    this._marshal = Protobuf.encode({\n      peerId: this.peerId.toBytes(),\n      seq: this.seqNumber,\n      addresses: this.multiaddrs.map(m => ({\n        multiaddr: m.bytes\n      }))\n    }).finish();\n    return this._marshal;\n  }\n  /**\n   * Returns true if `this` record equals the `other`.\n   *\n   * @param {unknown} other\n   * @returns {boolean}\n   */\n\n\n  equals(other) {\n    if (!(other instanceof PeerRecord)) {\n      return false;\n    } // Validate PeerId\n\n\n    if (!this.peerId.equals(other.peerId)) {\n      return false;\n    } // Validate seqNumber\n\n\n    if (this.seqNumber !== other.seqNumber) {\n      return false;\n    } // Validate multiaddrs\n\n\n    if (!arrayEquals(this.multiaddrs, other.multiaddrs)) {\n      return false;\n    }\n\n    return true;\n  }\n\n}\n/**\n * Unmarshal Peer Record Protobuf.\n *\n * @param {Uint8Array} buf - marshaled peer record.\n * @returns {PeerRecord}\n */\n\n\nPeerRecord.createFromProtobuf = buf => {\n  const peerRecord = Protobuf.decode(buf);\n  const peerId = PeerId.createFromBytes(peerRecord.peerId);\n  const multiaddrs = (peerRecord.addresses || []).map(a => new Multiaddr(a.multiaddr));\n  const seqNumber = Number(peerRecord.seq);\n  return new PeerRecord({\n    peerId,\n    multiaddrs,\n    seqNumber\n  });\n};\n\nPeerRecord.DOMAIN = ENVELOPE_DOMAIN_PEER_RECORD;\nmodule.exports = PeerRecord;","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/libp2p/src/record/peer-record/index.js"],"names":["Multiaddr","require","PeerId","arrayEquals","PeerRecord","Protobuf","ENVELOPE_DOMAIN_PEER_RECORD","ENVELOPE_PAYLOAD_TYPE_PEER_RECORD","constructor","peerId","multiaddrs","seqNumber","Date","now","domain","codec","_marshal","undefined","marshal","encode","toBytes","seq","addresses","map","m","multiaddr","bytes","finish","equals","other","createFromProtobuf","buf","peerRecord","decode","createFromBytes","a","Number","DOMAIN","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Multiaddr } = require('multiaddr')\nconst PeerId = require('peer-id')\nconst arrayEquals = require('libp2p-utils/src/array-equals')\n\nconst { PeerRecord: Protobuf } = require('./peer-record')\nconst {\n  ENVELOPE_DOMAIN_PEER_RECORD,\n  ENVELOPE_PAYLOAD_TYPE_PEER_RECORD\n} = require('./consts')\n\n/**\n * @typedef {import('../../peer-store/address-book.js').Address} Address\n * @typedef {import('libp2p-interfaces/src/record/types').Record} Record\n */\n\n/**\n * @implements {Record}\n */\nclass PeerRecord {\n  /**\n   * The PeerRecord is used for distributing peer routing records across the network.\n   * It contains the peer's reachable listen addresses.\n   *\n   * @class\n   * @param {Object} params\n   * @param {PeerId} params.peerId\n   * @param {Multiaddr[]} params.multiaddrs - addresses of the associated peer.\n   * @param {number} [params.seqNumber] - monotonically-increasing sequence counter that's used to order PeerRecords in time.\n   */\n  constructor ({ peerId, multiaddrs = [], seqNumber = Date.now() }) {\n    this.domain = ENVELOPE_DOMAIN_PEER_RECORD\n    this.codec = ENVELOPE_PAYLOAD_TYPE_PEER_RECORD\n\n    this.peerId = peerId\n    this.multiaddrs = multiaddrs\n    this.seqNumber = seqNumber\n\n    // Cache\n    this._marshal = undefined\n  }\n\n  /**\n   * Marshal a record to be used in an envelope.\n   *\n   * @returns {Uint8Array}\n   */\n  marshal () {\n    if (this._marshal) {\n      return this._marshal\n    }\n\n    this._marshal = Protobuf.encode({\n      peerId: this.peerId.toBytes(),\n      seq: this.seqNumber,\n      addresses: this.multiaddrs.map((m) => ({\n        multiaddr: m.bytes\n      }))\n    }).finish()\n\n    return this._marshal\n  }\n\n  /**\n   * Returns true if `this` record equals the `other`.\n   *\n   * @param {unknown} other\n   * @returns {boolean}\n   */\n  equals (other) {\n    if (!(other instanceof PeerRecord)) {\n      return false\n    }\n\n    // Validate PeerId\n    if (!this.peerId.equals(other.peerId)) {\n      return false\n    }\n\n    // Validate seqNumber\n    if (this.seqNumber !== other.seqNumber) {\n      return false\n    }\n\n    // Validate multiaddrs\n    if (!arrayEquals(this.multiaddrs, other.multiaddrs)) {\n      return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Unmarshal Peer Record Protobuf.\n *\n * @param {Uint8Array} buf - marshaled peer record.\n * @returns {PeerRecord}\n */\nPeerRecord.createFromProtobuf = (buf) => {\n  const peerRecord = Protobuf.decode(buf)\n\n  const peerId = PeerId.createFromBytes(peerRecord.peerId)\n  const multiaddrs = (peerRecord.addresses || []).map((a) => new Multiaddr(a.multiaddr))\n  const seqNumber = Number(peerRecord.seq)\n\n  return new PeerRecord({ peerId, multiaddrs, seqNumber })\n}\n\nPeerRecord.DOMAIN = ENVELOPE_DOMAIN_PEER_RECORD\n\nmodule.exports = PeerRecord\n"]},"metadata":{},"sourceType":"script"}