{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbstractHandshake = exports.MIN_NONCE = void 0;\n\nconst buffer_1 = require(\"buffer\");\n\nconst x25519 = __importStar(require(\"@stablelib/x25519\"));\n\nconst SHA256 = __importStar(require(\"@stablelib/sha256\"));\n\nconst chacha20poly1305_1 = require(\"@stablelib/chacha20poly1305\");\n\nconst utils_1 = require(\"../utils\");\n\nconst logger_1 = require(\"../logger\");\n\nexports.MIN_NONCE = 0;\n\nclass AbstractHandshake {\n  encryptWithAd(cs, ad, plaintext) {\n    const e = this.encrypt(cs.k, cs.n, ad, plaintext);\n    this.setNonce(cs, this.incrementNonce(cs.n));\n    return e;\n  }\n\n  decryptWithAd(cs, ad, ciphertext) {\n    const {\n      plaintext,\n      valid\n    } = this.decrypt(cs.k, cs.n, ad, ciphertext);\n    this.setNonce(cs, this.incrementNonce(cs.n));\n    return {\n      plaintext,\n      valid\n    };\n  } // Cipher state related\n\n\n  hasKey(cs) {\n    return !this.isEmptyKey(cs.k);\n  }\n\n  setNonce(cs, nonce) {\n    cs.n = nonce;\n  }\n\n  createEmptyKey() {\n    return buffer_1.Buffer.alloc(32);\n  }\n\n  isEmptyKey(k) {\n    const emptyKey = this.createEmptyKey();\n    return emptyKey.equals(k);\n  }\n\n  incrementNonce(n) {\n    return n + 1;\n  }\n\n  nonceToBytes(n) {\n    const nonce = buffer_1.Buffer.alloc(12);\n    nonce.writeUInt32LE(n, 4);\n    return nonce;\n  }\n\n  encrypt(k, n, ad, plaintext) {\n    const nonce = this.nonceToBytes(n);\n    const ctx = new chacha20poly1305_1.ChaCha20Poly1305(k);\n    const encryptedMessage = ctx.seal(nonce, plaintext, ad);\n    return buffer_1.Buffer.from(encryptedMessage.buffer, encryptedMessage.byteOffset, encryptedMessage.length);\n  }\n\n  encryptAndHash(ss, plaintext) {\n    let ciphertext;\n\n    if (this.hasKey(ss.cs)) {\n      ciphertext = this.encryptWithAd(ss.cs, ss.h, plaintext);\n    } else {\n      ciphertext = plaintext;\n    }\n\n    this.mixHash(ss, ciphertext);\n    return ciphertext;\n  }\n\n  decrypt(k, n, ad, ciphertext) {\n    const nonce = this.nonceToBytes(n);\n    const ctx = new chacha20poly1305_1.ChaCha20Poly1305(k);\n    const encryptedMessage = ctx.open(nonce, ciphertext, ad);\n\n    if (encryptedMessage) {\n      return {\n        plaintext: buffer_1.Buffer.from(encryptedMessage.buffer, encryptedMessage.byteOffset, encryptedMessage.length),\n        valid: true\n      };\n    } else {\n      return {\n        plaintext: buffer_1.Buffer.from(''),\n        valid: false\n      };\n    }\n  }\n\n  decryptAndHash(ss, ciphertext) {\n    let plaintext;\n    let valid = true;\n\n    if (this.hasKey(ss.cs)) {\n      ({\n        plaintext,\n        valid\n      } = this.decryptWithAd(ss.cs, ss.h, ciphertext));\n    } else {\n      plaintext = ciphertext;\n    }\n\n    this.mixHash(ss, ciphertext);\n    return {\n      plaintext,\n      valid\n    };\n  }\n\n  dh(privateKey, publicKey) {\n    try {\n      const derivedU8 = x25519.sharedKey(privateKey, publicKey);\n      const derived = buffer_1.Buffer.from(derivedU8.buffer, derivedU8.byteOffset, derivedU8.length);\n      const result = buffer_1.Buffer.alloc(32);\n      derived.copy(result);\n      return result;\n    } catch (e) {\n      logger_1.logger(e.message);\n      return buffer_1.Buffer.alloc(32);\n    }\n  }\n\n  mixHash(ss, data) {\n    ss.h = this.getHash(ss.h, data);\n  }\n\n  getHash(a, b) {\n    const hash = SHA256.hash(buffer_1.Buffer.from([...a, ...b]));\n    return buffer_1.Buffer.from(hash.buffer, hash.byteOffset, hash.length);\n  }\n\n  mixKey(ss, ikm) {\n    const [ck, tempK] = utils_1.getHkdf(ss.ck, ikm);\n    ss.cs = this.initializeKey(tempK);\n    ss.ck = ck;\n  }\n\n  initializeKey(k) {\n    const n = exports.MIN_NONCE;\n    return {\n      k,\n      n\n    };\n  } // Symmetric state related\n\n\n  initializeSymmetric(protocolName) {\n    const protocolNameBytes = buffer_1.Buffer.from(protocolName, 'utf-8');\n    const h = this.hashProtocolName(protocolNameBytes);\n    const ck = h;\n    const key = this.createEmptyKey();\n    const cs = this.initializeKey(key);\n    return {\n      cs,\n      ck,\n      h\n    };\n  }\n\n  hashProtocolName(protocolName) {\n    if (protocolName.length <= 32) {\n      const h = buffer_1.Buffer.alloc(32);\n      protocolName.copy(h);\n      return h;\n    } else {\n      return this.getHash(protocolName, buffer_1.Buffer.alloc(0));\n    }\n  }\n\n  split(ss) {\n    const [tempk1, tempk2] = utils_1.getHkdf(ss.ck, buffer_1.Buffer.alloc(0));\n    const cs1 = this.initializeKey(tempk1);\n    const cs2 = this.initializeKey(tempk2);\n    return {\n      cs1,\n      cs2\n    };\n  }\n\n  writeMessageRegular(cs, payload) {\n    const ciphertext = this.encryptWithAd(cs, buffer_1.Buffer.alloc(0), payload);\n    const ne = this.createEmptyKey();\n    const ns = buffer_1.Buffer.alloc(0);\n    return {\n      ne,\n      ns,\n      ciphertext\n    };\n  }\n\n  readMessageRegular(cs, message) {\n    return this.decryptWithAd(cs, buffer_1.Buffer.alloc(0), message.ciphertext);\n  }\n\n}\n\nexports.AbstractHandshake = AbstractHandshake;","map":{"version":3,"sources":["../../../src/handshakes/abstract-handshake.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AbstractHandshake = exports.MIN_NONCE = void 0;\nconst buffer_1 = require(\"buffer\");\nconst x25519 = __importStar(require(\"@stablelib/x25519\"));\nconst SHA256 = __importStar(require(\"@stablelib/sha256\"));\nconst chacha20poly1305_1 = require(\"@stablelib/chacha20poly1305\");\nconst utils_1 = require(\"../utils\");\nconst logger_1 = require(\"../logger\");\nexports.MIN_NONCE = 0;\nclass AbstractHandshake {\n    encryptWithAd(cs, ad, plaintext) {\n        const e = this.encrypt(cs.k, cs.n, ad, plaintext);\n        this.setNonce(cs, this.incrementNonce(cs.n));\n        return e;\n    }\n    decryptWithAd(cs, ad, ciphertext) {\n        const { plaintext, valid } = this.decrypt(cs.k, cs.n, ad, ciphertext);\n        this.setNonce(cs, this.incrementNonce(cs.n));\n        return { plaintext, valid };\n    }\n    // Cipher state related\n    hasKey(cs) {\n        return !this.isEmptyKey(cs.k);\n    }\n    setNonce(cs, nonce) {\n        cs.n = nonce;\n    }\n    createEmptyKey() {\n        return buffer_1.Buffer.alloc(32);\n    }\n    isEmptyKey(k) {\n        const emptyKey = this.createEmptyKey();\n        return emptyKey.equals(k);\n    }\n    incrementNonce(n) {\n        return n + 1;\n    }\n    nonceToBytes(n) {\n        const nonce = buffer_1.Buffer.alloc(12);\n        nonce.writeUInt32LE(n, 4);\n        return nonce;\n    }\n    encrypt(k, n, ad, plaintext) {\n        const nonce = this.nonceToBytes(n);\n        const ctx = new chacha20poly1305_1.ChaCha20Poly1305(k);\n        const encryptedMessage = ctx.seal(nonce, plaintext, ad);\n        return buffer_1.Buffer.from(encryptedMessage.buffer, encryptedMessage.byteOffset, encryptedMessage.length);\n    }\n    encryptAndHash(ss, plaintext) {\n        let ciphertext;\n        if (this.hasKey(ss.cs)) {\n            ciphertext = this.encryptWithAd(ss.cs, ss.h, plaintext);\n        }\n        else {\n            ciphertext = plaintext;\n        }\n        this.mixHash(ss, ciphertext);\n        return ciphertext;\n    }\n    decrypt(k, n, ad, ciphertext) {\n        const nonce = this.nonceToBytes(n);\n        const ctx = new chacha20poly1305_1.ChaCha20Poly1305(k);\n        const encryptedMessage = ctx.open(nonce, ciphertext, ad);\n        if (encryptedMessage) {\n            return {\n                plaintext: buffer_1.Buffer.from(encryptedMessage.buffer, encryptedMessage.byteOffset, encryptedMessage.length),\n                valid: true\n            };\n        }\n        else {\n            return {\n                plaintext: buffer_1.Buffer.from(''),\n                valid: false\n            };\n        }\n    }\n    decryptAndHash(ss, ciphertext) {\n        let plaintext;\n        let valid = true;\n        if (this.hasKey(ss.cs)) {\n            ({ plaintext, valid } = this.decryptWithAd(ss.cs, ss.h, ciphertext));\n        }\n        else {\n            plaintext = ciphertext;\n        }\n        this.mixHash(ss, ciphertext);\n        return { plaintext, valid };\n    }\n    dh(privateKey, publicKey) {\n        try {\n            const derivedU8 = x25519.sharedKey(privateKey, publicKey);\n            const derived = buffer_1.Buffer.from(derivedU8.buffer, derivedU8.byteOffset, derivedU8.length);\n            const result = buffer_1.Buffer.alloc(32);\n            derived.copy(result);\n            return result;\n        }\n        catch (e) {\n            logger_1.logger(e.message);\n            return buffer_1.Buffer.alloc(32);\n        }\n    }\n    mixHash(ss, data) {\n        ss.h = this.getHash(ss.h, data);\n    }\n    getHash(a, b) {\n        const hash = SHA256.hash(buffer_1.Buffer.from([...a, ...b]));\n        return buffer_1.Buffer.from(hash.buffer, hash.byteOffset, hash.length);\n    }\n    mixKey(ss, ikm) {\n        const [ck, tempK] = utils_1.getHkdf(ss.ck, ikm);\n        ss.cs = this.initializeKey(tempK);\n        ss.ck = ck;\n    }\n    initializeKey(k) {\n        const n = exports.MIN_NONCE;\n        return { k, n };\n    }\n    // Symmetric state related\n    initializeSymmetric(protocolName) {\n        const protocolNameBytes = buffer_1.Buffer.from(protocolName, 'utf-8');\n        const h = this.hashProtocolName(protocolNameBytes);\n        const ck = h;\n        const key = this.createEmptyKey();\n        const cs = this.initializeKey(key);\n        return { cs, ck, h };\n    }\n    hashProtocolName(protocolName) {\n        if (protocolName.length <= 32) {\n            const h = buffer_1.Buffer.alloc(32);\n            protocolName.copy(h);\n            return h;\n        }\n        else {\n            return this.getHash(protocolName, buffer_1.Buffer.alloc(0));\n        }\n    }\n    split(ss) {\n        const [tempk1, tempk2] = utils_1.getHkdf(ss.ck, buffer_1.Buffer.alloc(0));\n        const cs1 = this.initializeKey(tempk1);\n        const cs2 = this.initializeKey(tempk2);\n        return { cs1, cs2 };\n    }\n    writeMessageRegular(cs, payload) {\n        const ciphertext = this.encryptWithAd(cs, buffer_1.Buffer.alloc(0), payload);\n        const ne = this.createEmptyKey();\n        const ns = buffer_1.Buffer.alloc(0);\n        return { ne, ns, ciphertext };\n    }\n    readMessageRegular(cs, message) {\n        return this.decryptWithAd(cs, buffer_1.Buffer.alloc(0), message.ciphertext);\n    }\n}\nexports.AbstractHandshake = AbstractHandshake;\n//# sourceMappingURL=abstract-handshake.js.map"]},"metadata":{},"sourceType":"script"}