{"ast":null,"code":"const getIterator = require('get-iterator');\n\nmodule.exports = writable => async source => {\n  source = getIterator(source);\n\n  const maybeEndSource = source => {\n    if (typeof source.return === 'function') source.return();\n  };\n\n  let error = null;\n  let errCb = null;\n\n  const errorHandler = err => {\n    error = err;\n    if (errCb) errCb(err); // When the writable errors, try to end the source to exit iteration early\n\n    maybeEndSource(source);\n  };\n\n  let closeCb = null;\n  let closed = false;\n\n  const closeHandler = () => {\n    closed = true;\n    if (closeCb) closeCb();\n  };\n\n  let finishCb = null;\n  let finished = false;\n\n  const finishHandler = () => {\n    finished = true;\n    if (finishCb) finishCb();\n  };\n\n  let drainCb = null;\n\n  const drainHandler = () => {\n    if (drainCb) drainCb();\n  };\n\n  const waitForDrainOrClose = () => {\n    return new Promise((resolve, reject) => {\n      closeCb = drainCb = resolve;\n      errCb = reject;\n      writable.once('drain', drainHandler);\n    });\n  };\n\n  const waitForDone = () => {\n    // Immediately try to end the source\n    maybeEndSource(source);\n    return new Promise((resolve, reject) => {\n      if (closed || finished || error) return resolve();\n      finishCb = closeCb = resolve;\n      errCb = reject;\n    });\n  };\n\n  const cleanup = () => {\n    writable.removeListener('error', errorHandler);\n    writable.removeListener('close', closeHandler);\n    writable.removeListener('finish', finishHandler);\n    writable.removeListener('drain', drainHandler);\n  };\n\n  writable.once('error', errorHandler);\n  writable.once('close', closeHandler);\n  writable.once('finish', finishHandler);\n\n  try {\n    for await (const value of source) {\n      if (!writable.writable || writable.destroyed || error) break;\n\n      if (writable.write(value) === false) {\n        await waitForDrainOrClose();\n      }\n    }\n  } catch (err) {\n    // error is set by stream error handler so only destroy stream if source threw\n    if (!error) {\n      writable.destroy();\n    } // could we be obscuring an error here?\n\n\n    error = err;\n  }\n\n  try {\n    // We're done writing, end everything (n.b. stream may be destroyed at this point but then this is a no-op)\n    if (writable.writable) {\n      writable.end();\n    } // Wait until we close or finish. This supports halfClosed streams\n\n\n    await waitForDone(); // Notify the user an error occurred\n\n    if (error) throw error;\n  } finally {\n    // Clean up listeners\n    cleanup();\n  }\n};","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/stream-to-it/sink.js"],"names":["getIterator","require","module","exports","writable","source","maybeEndSource","return","error","errCb","errorHandler","err","closeCb","closed","closeHandler","finishCb","finished","finishHandler","drainCb","drainHandler","waitForDrainOrClose","Promise","resolve","reject","once","waitForDone","cleanup","removeListener","value","destroyed","write","destroy","end"],"mappings":"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","sourcesContent":["const getIterator = require('get-iterator')\n\nmodule.exports = writable => async source => {\n  source = getIterator(source)\n\n  const maybeEndSource = (source) => {\n    if (typeof source.return === 'function') source.return()\n  }\n\n  let error = null\n  let errCb = null\n  const errorHandler = (err) => {\n    error = err\n    if (errCb) errCb(err)\n    // When the writable errors, try to end the source to exit iteration early\n    maybeEndSource(source)\n  }\n\n  let closeCb = null\n  let closed = false\n  const closeHandler = () => {\n    closed = true\n    if (closeCb) closeCb()\n  }\n\n  let finishCb = null\n  let finished = false\n  const finishHandler = () => {\n    finished = true\n    if (finishCb) finishCb()\n  }\n\n  let drainCb = null\n  const drainHandler = () => {\n    if (drainCb) drainCb()\n  }\n\n  const waitForDrainOrClose = () => {\n    return new Promise((resolve, reject) => {\n      closeCb = drainCb = resolve\n      errCb = reject\n      writable.once('drain', drainHandler)\n    })\n  }\n\n  const waitForDone = () => {\n    // Immediately try to end the source\n    maybeEndSource(source)\n    return new Promise((resolve, reject) => {\n      if (closed || finished || error) return resolve()\n      finishCb = closeCb = resolve\n      errCb = reject\n    })\n  }\n\n  const cleanup = () => {\n    writable.removeListener('error', errorHandler)\n    writable.removeListener('close', closeHandler)\n    writable.removeListener('finish', finishHandler)\n    writable.removeListener('drain', drainHandler)\n  }\n\n  writable.once('error', errorHandler)\n  writable.once('close', closeHandler)\n  writable.once('finish', finishHandler)\n\n  try {\n    for await (const value of source) {\n      if (!writable.writable || writable.destroyed || error) break\n\n      if (writable.write(value) === false) {\n        await waitForDrainOrClose()\n      }\n    }\n  } catch (err) {\n    // error is set by stream error handler so only destroy stream if source threw\n    if (!error) {\n      writable.destroy()\n    }\n\n    // could we be obscuring an error here?\n    error = err\n  }\n\n  try {\n    // We're done writing, end everything (n.b. stream may be destroyed at this point but then this is a no-op)\n    if (writable.writable) {\n      writable.end()\n    }\n\n    // Wait until we close or finish. This supports halfClosed streams\n    await waitForDone()\n\n    // Notify the user an error occurred\n    if (error) throw error\n  } finally {\n    // Clean up listeners\n    cleanup()\n  }\n}\n"]},"metadata":{},"sourceType":"script"}