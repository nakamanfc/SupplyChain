{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.XXFallbackHandshake = void 0;\n\nconst buffer_1 = require(\"buffer\");\n\nconst handshake_xx_1 = require(\"./handshake-xx\");\n\nconst utils_1 = require(\"./utils\");\n\nconst logger_1 = require(\"./logger\");\n\nconst encoder_1 = require(\"./encoder\");\n\nclass XXFallbackHandshake extends handshake_xx_1.XXHandshake {\n  constructor(isInitiator, payload, prologue, staticKeypair, connection, initialMsg, remotePeer, ephemeralKeys, handshake) {\n    super(isInitiator, payload, prologue, staticKeypair, connection, remotePeer, handshake);\n\n    if (ephemeralKeys) {\n      this.ephemeralKeys = ephemeralKeys;\n    }\n\n    this.initialMsg = initialMsg;\n  } // stage 0\n  // eslint-disable-next-line require-await\n\n\n  async propose() {\n    if (this.isInitiator) {\n      this.xx.sendMessage(this.session, buffer_1.Buffer.alloc(0), this.ephemeralKeys);\n      logger_1.logger('XX Fallback Stage 0 - Initialized state as the first message was sent by initiator.');\n      logger_1.logLocalEphemeralKeys(this.session.hs.e);\n    } else {\n      logger_1.logger('XX Fallback Stage 0 - Responder decoding initial msg from IK.');\n      const receivedMessageBuffer = encoder_1.decode0(this.initialMsg);\n      const {\n        valid\n      } = this.xx.recvMessage(this.session, {\n        ne: receivedMessageBuffer.ne,\n        ns: buffer_1.Buffer.alloc(0),\n        ciphertext: buffer_1.Buffer.alloc(0)\n      });\n\n      if (!valid) {\n        throw new Error('xx fallback stage 0 decryption validation fail');\n      }\n\n      logger_1.logger('XX Fallback Stage 0 - Responder used received message from IK.');\n      logger_1.logRemoteEphemeralKey(this.session.hs.re);\n    }\n  } // stage 1\n\n\n  async exchange() {\n    if (this.isInitiator) {\n      const receivedMessageBuffer = encoder_1.decode1(this.initialMsg);\n      const {\n        plaintext,\n        valid\n      } = this.xx.recvMessage(this.session, receivedMessageBuffer);\n\n      if (!valid) {\n        throw new Error('xx fallback stage 1 decryption validation fail');\n      }\n\n      logger_1.logger('XX Fallback Stage 1 - Initiator used received message from IK.');\n      logger_1.logRemoteEphemeralKey(this.session.hs.re);\n      logger_1.logRemoteStaticKey(this.session.hs.rs);\n      logger_1.logger(\"Initiator going to check remote's signature...\");\n\n      try {\n        const decodedPayload = await utils_1.decodePayload(plaintext);\n        this.remotePeer = this.remotePeer || (await utils_1.getPeerIdFromPayload(decodedPayload));\n        await utils_1.verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);\n        this.setRemoteEarlyData(decodedPayload.data);\n      } catch (e) {\n        const err = e;\n        throw new Error(`Error occurred while verifying signed payload from responder: ${err.message}`);\n      }\n\n      logger_1.logger('All good with the signature!');\n    } else {\n      logger_1.logger('XX Fallback Stage 1 - Responder start');\n      await super.exchange();\n      logger_1.logger('XX Fallback Stage 1 - Responder end');\n    }\n  }\n\n}\n\nexports.XXFallbackHandshake = XXFallbackHandshake;","map":{"version":3,"sources":["../../src/handshake-xx-fallback.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.XXFallbackHandshake = void 0;\nconst buffer_1 = require(\"buffer\");\nconst handshake_xx_1 = require(\"./handshake-xx\");\nconst utils_1 = require(\"./utils\");\nconst logger_1 = require(\"./logger\");\nconst encoder_1 = require(\"./encoder\");\nclass XXFallbackHandshake extends handshake_xx_1.XXHandshake {\n    constructor(isInitiator, payload, prologue, staticKeypair, connection, initialMsg, remotePeer, ephemeralKeys, handshake) {\n        super(isInitiator, payload, prologue, staticKeypair, connection, remotePeer, handshake);\n        if (ephemeralKeys) {\n            this.ephemeralKeys = ephemeralKeys;\n        }\n        this.initialMsg = initialMsg;\n    }\n    // stage 0\n    // eslint-disable-next-line require-await\n    async propose() {\n        if (this.isInitiator) {\n            this.xx.sendMessage(this.session, buffer_1.Buffer.alloc(0), this.ephemeralKeys);\n            logger_1.logger('XX Fallback Stage 0 - Initialized state as the first message was sent by initiator.');\n            logger_1.logLocalEphemeralKeys(this.session.hs.e);\n        }\n        else {\n            logger_1.logger('XX Fallback Stage 0 - Responder decoding initial msg from IK.');\n            const receivedMessageBuffer = encoder_1.decode0(this.initialMsg);\n            const { valid } = this.xx.recvMessage(this.session, {\n                ne: receivedMessageBuffer.ne,\n                ns: buffer_1.Buffer.alloc(0),\n                ciphertext: buffer_1.Buffer.alloc(0)\n            });\n            if (!valid) {\n                throw new Error('xx fallback stage 0 decryption validation fail');\n            }\n            logger_1.logger('XX Fallback Stage 0 - Responder used received message from IK.');\n            logger_1.logRemoteEphemeralKey(this.session.hs.re);\n        }\n    }\n    // stage 1\n    async exchange() {\n        if (this.isInitiator) {\n            const receivedMessageBuffer = encoder_1.decode1(this.initialMsg);\n            const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);\n            if (!valid) {\n                throw new Error('xx fallback stage 1 decryption validation fail');\n            }\n            logger_1.logger('XX Fallback Stage 1 - Initiator used received message from IK.');\n            logger_1.logRemoteEphemeralKey(this.session.hs.re);\n            logger_1.logRemoteStaticKey(this.session.hs.rs);\n            logger_1.logger(\"Initiator going to check remote's signature...\");\n            try {\n                const decodedPayload = await utils_1.decodePayload(plaintext);\n                this.remotePeer = this.remotePeer || await utils_1.getPeerIdFromPayload(decodedPayload);\n                await utils_1.verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);\n                this.setRemoteEarlyData(decodedPayload.data);\n            }\n            catch (e) {\n                const err = e;\n                throw new Error(`Error occurred while verifying signed payload from responder: ${err.message}`);\n            }\n            logger_1.logger('All good with the signature!');\n        }\n        else {\n            logger_1.logger('XX Fallback Stage 1 - Responder start');\n            await super.exchange();\n            logger_1.logger('XX Fallback Stage 1 - Responder end');\n        }\n    }\n}\nexports.XXFallbackHandshake = XXFallbackHandshake;\n//# sourceMappingURL=handshake-xx-fallback.js.map"]},"metadata":{},"sourceType":"script"}