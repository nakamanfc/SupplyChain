{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.logCipherState = exports.logRemoteEphemeralKey = exports.logRemoteStaticKey = exports.logLocalEphemeralKeys = exports.logLocalStaticKeys = exports.logger = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst constants_1 = require(\"./constants\");\n\nexports.logger = debug_1.default('libp2p:noise');\nlet keyLogger;\n\nif (constants_1.DUMP_SESSION_KEYS) {\n  keyLogger = exports.logger;\n} else {\n  keyLogger = () => {};\n}\n\nfunction logLocalStaticKeys(s) {\n  keyLogger(`LOCAL_STATIC_PUBLIC_KEY ${s.publicKey.toString('hex')}`);\n  keyLogger(`LOCAL_STATIC_PRIVATE_KEY ${s.privateKey.toString('hex')}`);\n}\n\nexports.logLocalStaticKeys = logLocalStaticKeys;\n\nfunction logLocalEphemeralKeys(e) {\n  if (e) {\n    keyLogger(`LOCAL_PUBLIC_EPHEMERAL_KEY ${e.publicKey.toString('hex')}`);\n    keyLogger(`LOCAL_PRIVATE_EPHEMERAL_KEY ${e.privateKey.toString('hex')}`);\n  } else {\n    keyLogger('Missing local ephemeral keys.');\n  }\n}\n\nexports.logLocalEphemeralKeys = logLocalEphemeralKeys;\n\nfunction logRemoteStaticKey(rs) {\n  keyLogger(`REMOTE_STATIC_PUBLIC_KEY ${rs.toString('hex')}`);\n}\n\nexports.logRemoteStaticKey = logRemoteStaticKey;\n\nfunction logRemoteEphemeralKey(re) {\n  keyLogger(`REMOTE_EPHEMERAL_PUBLIC_KEY ${re.toString('hex')}`);\n}\n\nexports.logRemoteEphemeralKey = logRemoteEphemeralKey;\n\nfunction logCipherState(session) {\n  if (session.cs1 && session.cs2) {\n    keyLogger(`CIPHER_STATE_1 ${session.cs1.n} ${session.cs1.k.toString('hex')}`);\n    keyLogger(`CIPHER_STATE_2 ${session.cs2.n} ${session.cs2.k.toString('hex')}`);\n  } else {\n    keyLogger('Missing cipher state.');\n  }\n}\n\nexports.logCipherState = logCipherState;","map":{"version":3,"sources":["../../src/logger.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAAA,MAAA,OAAA,GAAA,eAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AACA,MAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AAIa,OAAA,CAAA,MAAA,GAAS,OAAA,CAAA,OAAA,CAAM,cAAN,CAAT;AAEb,IAAI,SAAJ;;AACA,IAAI,WAAA,CAAA,iBAAJ,EAAuB;AACrB,EAAA,SAAS,GAAG,OAAA,CAAA,MAAZ;AACD,CAFD,MAEO;AACL,EAAA,SAAS,GAAG,MAAK,CAAqB,CAAtC;AACD;;AAED,SAAgB,kBAAhB,CAAoC,CAApC,EAA8C;AAC5C,EAAA,SAAS,CAAC,2BAA2B,CAAC,CAAC,SAAF,CAAY,QAAZ,CAAqB,KAArB,CAA2B,EAAvD,CAAT;AACA,EAAA,SAAS,CAAC,4BAA4B,CAAC,CAAC,UAAF,CAAa,QAAb,CAAsB,KAAtB,CAA4B,EAAzD,CAAT;AACD;;AAHD,OAAA,CAAA,kBAAA,GAAA,kBAAA;;AAKA,SAAgB,qBAAhB,CAAuC,CAAvC,EAA2D;AACzD,MAAI,CAAJ,EAAO;AACL,IAAA,SAAS,CAAC,8BAA8B,CAAC,CAAC,SAAF,CAAY,QAAZ,CAAqB,KAArB,CAA2B,EAA1D,CAAT;AACA,IAAA,SAAS,CAAC,+BAA+B,CAAC,CAAC,UAAF,CAAa,QAAb,CAAsB,KAAtB,CAA4B,EAA5D,CAAT;AACD,GAHD,MAGO;AACL,IAAA,SAAS,CAAC,+BAAD,CAAT;AACD;AACF;;AAPD,OAAA,CAAA,qBAAA,GAAA,qBAAA;;AASA,SAAgB,kBAAhB,CAAoC,EAApC,EAA8C;AAC5C,EAAA,SAAS,CAAC,4BAA4B,EAAE,CAAC,QAAH,CAAY,KAAZ,CAAkB,EAA/C,CAAT;AACD;;AAFD,OAAA,CAAA,kBAAA,GAAA,kBAAA;;AAIA,SAAgB,qBAAhB,CAAuC,EAAvC,EAAiD;AAC/C,EAAA,SAAS,CAAC,+BAA+B,EAAE,CAAC,QAAH,CAAY,KAAZ,CAAkB,EAAlD,CAAT;AACD;;AAFD,OAAA,CAAA,qBAAA,GAAA,qBAAA;;AAIA,SAAgB,cAAhB,CAAgC,OAAhC,EAAqD;AACnD,MAAI,OAAO,CAAC,GAAR,IAAe,OAAO,CAAC,GAA3B,EAAgC;AAC9B,IAAA,SAAS,CAAC,kBAAkB,OAAO,CAAC,GAAR,CAAY,CAAC,IAAI,OAAO,CAAC,GAAR,CAAY,CAAZ,CAAc,QAAd,CAAuB,KAAvB,CAA6B,EAAjE,CAAT;AACA,IAAA,SAAS,CAAC,kBAAkB,OAAO,CAAC,GAAR,CAAY,CAAC,IAAI,OAAO,CAAC,GAAR,CAAY,CAAZ,CAAc,QAAd,CAAuB,KAAvB,CAA6B,EAAjE,CAAT;AACD,GAHD,MAGO;AACL,IAAA,SAAS,CAAC,uBAAD,CAAT;AACD;AACF;;AAPD,OAAA,CAAA,cAAA,GAAA,cAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.logCipherState = exports.logRemoteEphemeralKey = exports.logRemoteStaticKey = exports.logLocalEphemeralKeys = exports.logLocalStaticKeys = exports.logger = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst constants_1 = require(\"./constants\");\nexports.logger = debug_1.default('libp2p:noise');\nlet keyLogger;\nif (constants_1.DUMP_SESSION_KEYS) {\n    keyLogger = exports.logger;\n}\nelse {\n    keyLogger = () => { };\n}\nfunction logLocalStaticKeys(s) {\n    keyLogger(`LOCAL_STATIC_PUBLIC_KEY ${s.publicKey.toString('hex')}`);\n    keyLogger(`LOCAL_STATIC_PRIVATE_KEY ${s.privateKey.toString('hex')}`);\n}\nexports.logLocalStaticKeys = logLocalStaticKeys;\nfunction logLocalEphemeralKeys(e) {\n    if (e) {\n        keyLogger(`LOCAL_PUBLIC_EPHEMERAL_KEY ${e.publicKey.toString('hex')}`);\n        keyLogger(`LOCAL_PRIVATE_EPHEMERAL_KEY ${e.privateKey.toString('hex')}`);\n    }\n    else {\n        keyLogger('Missing local ephemeral keys.');\n    }\n}\nexports.logLocalEphemeralKeys = logLocalEphemeralKeys;\nfunction logRemoteStaticKey(rs) {\n    keyLogger(`REMOTE_STATIC_PUBLIC_KEY ${rs.toString('hex')}`);\n}\nexports.logRemoteStaticKey = logRemoteStaticKey;\nfunction logRemoteEphemeralKey(re) {\n    keyLogger(`REMOTE_EPHEMERAL_PUBLIC_KEY ${re.toString('hex')}`);\n}\nexports.logRemoteEphemeralKey = logRemoteEphemeralKey;\nfunction logCipherState(session) {\n    if (session.cs1 && session.cs2) {\n        keyLogger(`CIPHER_STATE_1 ${session.cs1.n} ${session.cs1.k.toString('hex')}`);\n        keyLogger(`CIPHER_STATE_2 ${session.cs2.n} ${session.cs2.k.toString('hex')}`);\n    }\n    else {\n        keyLogger('Missing cipher state.');\n    }\n}\nexports.logCipherState = logCipherState;\n//# sourceMappingURL=logger.js.map"]},"metadata":{},"sourceType":"script"}