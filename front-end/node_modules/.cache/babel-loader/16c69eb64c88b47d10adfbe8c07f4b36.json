{"ast":null,"code":"'use strict';\n\nconst {\n  exporter\n} = require('ipfs-unixfs-exporter');\n\nconst toMfsPath = require('./utils/to-mfs-path');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst map = require('it-map');\n/**\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {import('ipfs-core-types/src/files').MFSEntry} MFSEntry\n */\n\n/**\n * @param {import('ipfs-unixfs-exporter').UnixFSEntry} fsEntry\n */\n\n\nconst toOutput = fsEntry => {\n  /** @type {MFSEntry} */\n  const output = {\n    cid: fsEntry.cid,\n    name: fsEntry.name,\n    type: fsEntry.type === 'directory' ? 'directory' : 'file',\n    size: fsEntry.size\n  };\n\n  if (fsEntry.type === 'file' || fsEntry.type === 'directory') {\n    output.mode = fsEntry.unixfs.mode;\n    output.mtime = fsEntry.unixfs.mtime;\n  }\n\n  return output;\n};\n/**\n * @param {MfsContext} context\n */\n\n\nmodule.exports = context => {\n  /**\n   * @type {import('ipfs-core-types/src/files').API[\"ls\"]}\n   */\n  async function* mfsLs(path, options = {}) {\n    const mfsPath = await toMfsPath(context, path, options);\n    const fsEntry = await exporter(mfsPath.mfsPath, context.repo.blocks); // directory, perhaps sharded\n\n    if (fsEntry.type === 'directory') {\n      yield* map(fsEntry.content(options), toOutput);\n      return;\n    } // single file/node\n\n\n    yield toOutput(fsEntry);\n  }\n\n  return withTimeoutOption(mfsLs);\n};","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/ipfs-core/src/components/files/ls.js"],"names":["exporter","require","toMfsPath","withTimeoutOption","map","toOutput","fsEntry","output","cid","name","type","size","mode","unixfs","mtime","module","exports","context","mfsLs","path","options","mfsPath","repo","blocks","content"],"mappings":"AAAA;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAeC,OAAO,CAAC,sBAAD,CAA5B;;AACA,MAAMC,SAAS,GAAGD,OAAO,CAAC,qBAAD,CAAzB;;AACA,MAAME,iBAAiB,GAAGF,OAAO,CAAC,yCAAD,CAAjC;;AACA,MAAMG,GAAG,GAAGH,OAAO,CAAC,QAAD,CAAnB;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AACA,MAAMI,QAAQ,GAAIC,OAAD,IAAa;AAC5B;AACA,QAAMC,MAAM,GAAG;AACbC,IAAAA,GAAG,EAAEF,OAAO,CAACE,GADA;AAEbC,IAAAA,IAAI,EAAEH,OAAO,CAACG,IAFD;AAGbC,IAAAA,IAAI,EAAEJ,OAAO,CAACI,IAAR,KAAiB,WAAjB,GAA+B,WAA/B,GAA6C,MAHtC;AAIbC,IAAAA,IAAI,EAAEL,OAAO,CAACK;AAJD,GAAf;;AAOA,MAAIL,OAAO,CAACI,IAAR,KAAiB,MAAjB,IAA2BJ,OAAO,CAACI,IAAR,KAAiB,WAAhD,EAA6D;AAC3DH,IAAAA,MAAM,CAACK,IAAP,GAAcN,OAAO,CAACO,MAAR,CAAeD,IAA7B;AACAL,IAAAA,MAAM,CAACO,KAAP,GAAeR,OAAO,CAACO,MAAR,CAAeC,KAA9B;AACD;;AAED,SAAOP,MAAP;AACD,CAfD;AAiBA;AACA;AACA;;;AACAQ,MAAM,CAACC,OAAP,GAAkBC,OAAD,IAAa;AAC5B;AACF;AACA;AACE,kBAAiBC,KAAjB,CAAwBC,IAAxB,EAA8BC,OAAO,GAAG,EAAxC,EAA4C;AAC1C,UAAMC,OAAO,GAAG,MAAMnB,SAAS,CAACe,OAAD,EAAUE,IAAV,EAAgBC,OAAhB,CAA/B;AACA,UAAMd,OAAO,GAAG,MAAMN,QAAQ,CAACqB,OAAO,CAACA,OAAT,EAAkBJ,OAAO,CAACK,IAAR,CAAaC,MAA/B,CAA9B,CAF0C,CAI1C;;AACA,QAAIjB,OAAO,CAACI,IAAR,KAAiB,WAArB,EAAkC;AAChC,aAAQN,GAAG,CAACE,OAAO,CAACkB,OAAR,CAAgBJ,OAAhB,CAAD,EAA2Bf,QAA3B,CAAX;AAEA;AACD,KATyC,CAW1C;;;AACA,UAAMA,QAAQ,CAACC,OAAD,CAAd;AACD;;AAED,SAAOH,iBAAiB,CAACe,KAAD,CAAxB;AACD,CApBD","sourcesContent":["'use strict'\n\nconst { exporter } = require('ipfs-unixfs-exporter')\nconst toMfsPath = require('./utils/to-mfs-path')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\nconst map = require('it-map')\n\n/**\n * @typedef {import('./').MfsContext} MfsContext\n * @typedef {import('ipfs-core-types/src/files').MFSEntry} MFSEntry\n */\n\n/**\n * @param {import('ipfs-unixfs-exporter').UnixFSEntry} fsEntry\n */\nconst toOutput = (fsEntry) => {\n  /** @type {MFSEntry} */\n  const output = {\n    cid: fsEntry.cid,\n    name: fsEntry.name,\n    type: fsEntry.type === 'directory' ? 'directory' : 'file',\n    size: fsEntry.size\n  }\n\n  if (fsEntry.type === 'file' || fsEntry.type === 'directory') {\n    output.mode = fsEntry.unixfs.mode\n    output.mtime = fsEntry.unixfs.mtime\n  }\n\n  return output\n}\n\n/**\n * @param {MfsContext} context\n */\nmodule.exports = (context) => {\n  /**\n   * @type {import('ipfs-core-types/src/files').API[\"ls\"]}\n   */\n  async function * mfsLs (path, options = {}) {\n    const mfsPath = await toMfsPath(context, path, options)\n    const fsEntry = await exporter(mfsPath.mfsPath, context.repo.blocks)\n\n    // directory, perhaps sharded\n    if (fsEntry.type === 'directory') {\n      yield * map(fsEntry.content(options), toOutput)\n\n      return\n    }\n\n    // single file/node\n    yield toOutput(fsEntry)\n  }\n\n  return withTimeoutOption(mfsLs)\n}\n"]},"metadata":{},"sourceType":"script"}