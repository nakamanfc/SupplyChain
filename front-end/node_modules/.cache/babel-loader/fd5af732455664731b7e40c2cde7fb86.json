{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Heartbeat = void 0;\n\nconst constants = __importStar(require(\"./constants\"));\n\nconst get_gossip_peers_1 = require(\"./get-gossip-peers\");\n\nconst utils_1 = require(\"./utils\"); // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n\n\nclass Heartbeat {\n  /**\n   * @param {Object} gossipsub\n   * @constructor\n   */\n  constructor(gossipsub) {\n    this.gossipsub = gossipsub;\n  }\n\n  start() {\n    if (this._heartbeatTimer) {\n      return;\n    }\n\n    const heartbeat = this._heartbeat.bind(this);\n\n    const timeout = setTimeout(() => {\n      heartbeat();\n\n      this._heartbeatTimer.runPeriodically(heartbeat, constants.GossipsubHeartbeatInterval);\n    }, constants.GossipsubHeartbeatInitialDelay);\n    this._heartbeatTimer = {\n      _intervalId: undefined,\n      runPeriodically: (fn, period) => {\n        this._heartbeatTimer._intervalId = setInterval(fn, period);\n      },\n      cancel: () => {\n        clearTimeout(timeout);\n        clearInterval(this._heartbeatTimer._intervalId);\n      }\n    };\n  }\n  /**\n   * Unmounts the gossipsub protocol and shuts down every connection\n   * @override\n   * @returns {void}\n   */\n\n\n  stop() {\n    if (!this._heartbeatTimer) {\n      return;\n    }\n\n    this._heartbeatTimer.cancel();\n\n    this._heartbeatTimer = null;\n  }\n  /**\n   * Maintains the mesh and fanout maps in gossipsub.\n   *\n   * @returns {void}\n   */\n\n\n  _heartbeat() {\n    const {\n      D,\n      Dlo,\n      Dhi,\n      Dscore,\n      Dout\n    } = this.gossipsub._options;\n    this.gossipsub.heartbeatTicks++; // cache scores throught the heartbeat\n\n    const scores = new Map();\n\n    const getScore = id => {\n      let s = scores.get(id);\n\n      if (s === undefined) {\n        s = this.gossipsub.score.score(id);\n        scores.set(id, s);\n      }\n\n      return s;\n    }; // peer id => topic[]\n\n\n    const tograft = new Map(); // peer id => topic[]\n\n    const toprune = new Map(); // peer id => don't px\n\n    const noPX = new Map(); // clean up expired backoffs\n\n    this.gossipsub._clearBackoff(); // clean up peerhave/iasked counters\n\n\n    this.gossipsub.peerhave.clear();\n    this.gossipsub.iasked.clear(); // apply IWANT request penalties\n\n    this.gossipsub._applyIwantPenalties(); // ensure direct peers are connected\n\n\n    this.gossipsub._directConnect(); // maintain the mesh for topics we have joined\n\n\n    this.gossipsub.mesh.forEach((peers, topic) => {\n      // prune/graft helper functions (defined per topic)\n      const prunePeer = id => {\n        this.gossipsub.log('HEARTBEAT: Remove mesh link to %s in %s', id, topic); // update peer score\n\n        this.gossipsub.score.prune(id, topic); // add prune backoff record\n\n        this.gossipsub._addBackoff(id, topic); // remove peer from mesh\n\n\n        peers.delete(id); // add to toprune\n\n        const topics = toprune.get(id);\n\n        if (!topics) {\n          toprune.set(id, [topic]);\n        } else {\n          topics.push(topic);\n        }\n      };\n\n      const graftPeer = id => {\n        this.gossipsub.log('HEARTBEAT: Add mesh link to %s in %s', id, topic); // update peer score\n\n        this.gossipsub.score.graft(id, topic); // add peer to mesh\n\n        peers.add(id); // add to tograft\n\n        const topics = tograft.get(id);\n\n        if (!topics) {\n          tograft.set(id, [topic]);\n        } else {\n          topics.push(topic);\n        }\n      }; // drop all peers with negative score, without PX\n\n\n      peers.forEach(id => {\n        const score = getScore(id);\n\n        if (score < 0) {\n          this.gossipsub.log('HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s', id, score, topic);\n          prunePeer(id);\n          noPX.set(id, true);\n        }\n      }); // do we have enough peers?\n\n      if (peers.size < Dlo) {\n        const backoff = this.gossipsub.backoff.get(topic);\n        const ineed = D - peers.size;\n        const peersSet = get_gossip_peers_1.getGossipPeers(this.gossipsub, topic, ineed, id => {\n          // filter out mesh peers, direct peers, peers we are backing off, peers with negative score\n          return !peers.has(id) && !this.gossipsub.direct.has(id) && (!backoff || !backoff.has(id)) && getScore(id) >= 0;\n        });\n        peersSet.forEach(graftPeer);\n      } // do we have to many peers?\n\n\n      if (peers.size > Dhi) {\n        let peersArray = Array.from(peers); // sort by score\n\n        peersArray.sort((a, b) => getScore(b) - getScore(a)); // We keep the first D_score peers by score and the remaining up to D randomly\n        // under the constraint that we keep D_out peers in the mesh (if we have that many)\n\n        peersArray = peersArray.slice(0, Dscore).concat(utils_1.shuffle(peersArray.slice(Dscore))); // count the outbound peers we are keeping\n\n        let outbound = 0;\n        peersArray.slice(0, D).forEach(p => {\n          if (this.gossipsub.outbound.get(p)) {\n            outbound++;\n          }\n        }); // if it's less than D_out, bubble up some outbound peers from the random selection\n\n        if (outbound < Dout) {\n          const rotate = i => {\n            // rotate the peersArray to the right and put the ith peer in the front\n            const p = peersArray[i];\n\n            for (let j = i; j > 0; j--) {\n              peersArray[j] = peersArray[j - 1];\n            }\n\n            peersArray[0] = p;\n          }; // first bubble up all outbound peers already in the selection to the front\n\n\n          if (outbound > 0) {\n            let ihave = outbound;\n\n            for (let i = 1; i < D && ihave > 0; i++) {\n              if (this.gossipsub.outbound.get(peersArray[i])) {\n                rotate(i);\n                ihave--;\n              }\n            }\n          } // now bubble up enough outbound peers outside the selection to the front\n\n\n          let ineed = D - outbound;\n\n          for (let i = D; i < peersArray.length && ineed > 0; i++) {\n            if (this.gossipsub.outbound.get(peersArray[i])) {\n              rotate(i);\n              ineed--;\n            }\n          }\n        } // prune the excess peers\n\n\n        peersArray.slice(D).forEach(prunePeer);\n      } // do we have enough outbound peers?\n\n\n      if (peers.size >= Dlo) {\n        // count the outbound peers we have\n        let outbound = 0;\n        peers.forEach(p => {\n          if (this.gossipsub.outbound.get(p)) {\n            outbound++;\n          }\n        }); // if it's less than D_out, select some peers with outbound connections and graft them\n\n        if (outbound < Dout) {\n          const ineed = Dout - outbound;\n          const backoff = this.gossipsub.backoff.get(topic);\n          get_gossip_peers_1.getGossipPeers(this.gossipsub, topic, ineed, id => {\n            // filter our current mesh peers, direct peers, peers we are backing off, peers with negative score\n            return !peers.has(id) && !this.gossipsub.direct.has(id) && (!backoff || !backoff.has(id)) && getScore(id) >= 0;\n          }).forEach(graftPeer);\n        }\n      } // should we try to improve the mesh with opportunistic grafting?\n\n\n      if (this.gossipsub.heartbeatTicks % constants.GossipsubOpportunisticGraftTicks === 0 && peers.size > 1) {\n        // Opportunistic grafting works as follows: we check the median score of peers in the\n        // mesh; if this score is below the opportunisticGraftThreshold, we select a few peers at\n        // random with score over the median.\n        // The intention is to (slowly) improve an underperforming mesh by introducing good\n        // scoring peers that may have been gossiping at us. This allows us to get out of sticky\n        // situations where we are stuck with poor peers and also recover from churn of good peers.\n        // now compute the median peer score in the mesh\n        const peersList = Array.from(peers).sort((a, b) => getScore(a) - getScore(b));\n        const medianIndex = peers.size / 2;\n        const medianScore = getScore(peersList[medianIndex]); // if the median score is below the threshold, select a better peer (if any) and GRAFT\n\n        if (medianScore < this.gossipsub._options.scoreThresholds.opportunisticGraftThreshold) {\n          const backoff = this.gossipsub.backoff.get(topic);\n          const peersToGraft = get_gossip_peers_1.getGossipPeers(this.gossipsub, topic, constants.GossipsubOpportunisticGraftPeers, id => {\n            // filter out current mesh peers, direct peers, peers we are backing off, peers below or at threshold\n            return peers.has(id) && !this.gossipsub.direct.has(id) && (!backoff || !backoff.has(id)) && getScore(id) > medianScore;\n          });\n          peersToGraft.forEach(id => {\n            this.gossipsub.log('HEARTBEAT: Opportunistically graft peer %s on topic %s', id, topic);\n            graftPeer(id);\n          });\n        }\n      } // 2nd arg are mesh peers excluded from gossip. We have already pushed\n      // messages to them, so its redundant to gossip IHAVEs.\n\n\n      this.gossipsub._emitGossip(topic, peers);\n    }); // expire fanout for topics we haven't published to in a while\n\n    const now = this.gossipsub._now();\n\n    this.gossipsub.lastpub.forEach((lastpb, topic) => {\n      if (lastpb + constants.GossipsubFanoutTTL < now) {\n        this.gossipsub.fanout.delete(topic);\n        this.gossipsub.lastpub.delete(topic);\n      }\n    }); // maintain our fanout for topics we are publishing but we have not joined\n\n    this.gossipsub.fanout.forEach((fanoutPeers, topic) => {\n      // checks whether our peers are still in the topic and have a score above the publish threshold\n      const topicPeers = this.gossipsub.topics.get(topic);\n      fanoutPeers.forEach(id => {\n        if (!topicPeers.has(id) || getScore(id) < this.gossipsub._options.scoreThresholds.publishThreshold) {\n          fanoutPeers.delete(id);\n        }\n      }); // do we need more peers?\n\n      if (fanoutPeers.size < D) {\n        const ineed = D - fanoutPeers.size;\n        const peersSet = get_gossip_peers_1.getGossipPeers(this.gossipsub, topic, ineed, id => {\n          // filter out existing fanout peers, direct peers, and peers with score above the publish threshold\n          return !fanoutPeers.has(id) && !this.gossipsub.direct.has(id) && getScore(id) >= this.gossipsub._options.scoreThresholds.publishThreshold;\n        });\n        peersSet.forEach(id => {\n          fanoutPeers.add(id);\n        });\n      } // 2nd arg are fanout peers excluded from gossip.\n      // We have already pushed messages to them, so its redundant to gossip IHAVEs\n\n\n      this.gossipsub._emitGossip(topic, fanoutPeers);\n    }); // send coalesced GRAFT/PRUNE messages (will piggyback gossip)\n\n    this.gossipsub._sendGraftPrune(tograft, toprune, noPX); // flush pending gossip that wasn't piggybacked above\n\n\n    this.gossipsub._flush(); // advance the message history window\n\n\n    this.gossipsub.messageCache.shift();\n    this.gossipsub.emit('gossipsub:heartbeat');\n  }\n\n}\n\nexports.Heartbeat = Heartbeat;","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/libp2p-gossipsub/src/heartbeat.js"],"names":["__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__importStar","mod","__esModule","result","prototype","hasOwnProperty","call","exports","Heartbeat","constants","require","get_gossip_peers_1","utils_1","constructor","gossipsub","start","_heartbeatTimer","heartbeat","_heartbeat","bind","timeout","setTimeout","runPeriodically","GossipsubHeartbeatInterval","GossipsubHeartbeatInitialDelay","_intervalId","fn","period","setInterval","cancel","clearTimeout","clearInterval","stop","D","Dlo","Dhi","Dscore","Dout","_options","heartbeatTicks","scores","Map","getScore","id","s","score","set","tograft","toprune","noPX","_clearBackoff","peerhave","clear","iasked","_applyIwantPenalties","_directConnect","mesh","forEach","peers","topic","prunePeer","log","prune","_addBackoff","delete","topics","push","graftPeer","graft","add","size","backoff","ineed","peersSet","getGossipPeers","has","direct","peersArray","Array","from","sort","a","b","slice","concat","shuffle","outbound","p","rotate","i","j","ihave","length","GossipsubOpportunisticGraftTicks","peersList","medianIndex","medianScore","scoreThresholds","opportunisticGraftThreshold","peersToGraft","GossipsubOpportunisticGraftPeers","_emitGossip","now","_now","lastpub","lastpb","GossipsubFanoutTTL","fanout","fanoutPeers","topicPeers","publishThreshold","_sendGraftPrune","_flush","messageCache","shift","emit"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Heartbeat = void 0;\nconst constants = __importStar(require(\"./constants\"));\nconst get_gossip_peers_1 = require(\"./get-gossip-peers\");\nconst utils_1 = require(\"./utils\");\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\nclass Heartbeat {\n    /**\n     * @param {Object} gossipsub\n     * @constructor\n     */\n    constructor(gossipsub) {\n        this.gossipsub = gossipsub;\n    }\n    start() {\n        if (this._heartbeatTimer) {\n            return;\n        }\n        const heartbeat = this._heartbeat.bind(this);\n        const timeout = setTimeout(() => {\n            heartbeat();\n            this._heartbeatTimer.runPeriodically(heartbeat, constants.GossipsubHeartbeatInterval);\n        }, constants.GossipsubHeartbeatInitialDelay);\n        this._heartbeatTimer = {\n            _intervalId: undefined,\n            runPeriodically: (fn, period) => {\n                this._heartbeatTimer._intervalId = setInterval(fn, period);\n            },\n            cancel: () => {\n                clearTimeout(timeout);\n                clearInterval(this._heartbeatTimer._intervalId);\n            }\n        };\n    }\n    /**\n     * Unmounts the gossipsub protocol and shuts down every connection\n     * @override\n     * @returns {void}\n     */\n    stop() {\n        if (!this._heartbeatTimer) {\n            return;\n        }\n        this._heartbeatTimer.cancel();\n        this._heartbeatTimer = null;\n    }\n    /**\n     * Maintains the mesh and fanout maps in gossipsub.\n     *\n     * @returns {void}\n     */\n    _heartbeat() {\n        const { D, Dlo, Dhi, Dscore, Dout } = this.gossipsub._options;\n        this.gossipsub.heartbeatTicks++;\n        // cache scores throught the heartbeat\n        const scores = new Map();\n        const getScore = (id) => {\n            let s = scores.get(id);\n            if (s === undefined) {\n                s = this.gossipsub.score.score(id);\n                scores.set(id, s);\n            }\n            return s;\n        };\n        // peer id => topic[]\n        const tograft = new Map();\n        // peer id => topic[]\n        const toprune = new Map();\n        // peer id => don't px\n        const noPX = new Map();\n        // clean up expired backoffs\n        this.gossipsub._clearBackoff();\n        // clean up peerhave/iasked counters\n        this.gossipsub.peerhave.clear();\n        this.gossipsub.iasked.clear();\n        // apply IWANT request penalties\n        this.gossipsub._applyIwantPenalties();\n        // ensure direct peers are connected\n        this.gossipsub._directConnect();\n        // maintain the mesh for topics we have joined\n        this.gossipsub.mesh.forEach((peers, topic) => {\n            // prune/graft helper functions (defined per topic)\n            const prunePeer = (id) => {\n                this.gossipsub.log('HEARTBEAT: Remove mesh link to %s in %s', id, topic);\n                // update peer score\n                this.gossipsub.score.prune(id, topic);\n                // add prune backoff record\n                this.gossipsub._addBackoff(id, topic);\n                // remove peer from mesh\n                peers.delete(id);\n                // add to toprune\n                const topics = toprune.get(id);\n                if (!topics) {\n                    toprune.set(id, [topic]);\n                }\n                else {\n                    topics.push(topic);\n                }\n            };\n            const graftPeer = (id) => {\n                this.gossipsub.log('HEARTBEAT: Add mesh link to %s in %s', id, topic);\n                // update peer score\n                this.gossipsub.score.graft(id, topic);\n                // add peer to mesh\n                peers.add(id);\n                // add to tograft\n                const topics = tograft.get(id);\n                if (!topics) {\n                    tograft.set(id, [topic]);\n                }\n                else {\n                    topics.push(topic);\n                }\n            };\n            // drop all peers with negative score, without PX\n            peers.forEach(id => {\n                const score = getScore(id);\n                if (score < 0) {\n                    this.gossipsub.log('HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s', id, score, topic);\n                    prunePeer(id);\n                    noPX.set(id, true);\n                }\n            });\n            // do we have enough peers?\n            if (peers.size < Dlo) {\n                const backoff = this.gossipsub.backoff.get(topic);\n                const ineed = D - peers.size;\n                const peersSet = get_gossip_peers_1.getGossipPeers(this.gossipsub, topic, ineed, id => {\n                    // filter out mesh peers, direct peers, peers we are backing off, peers with negative score\n                    return !peers.has(id) && !this.gossipsub.direct.has(id) && (!backoff || !backoff.has(id)) && getScore(id) >= 0;\n                });\n                peersSet.forEach(graftPeer);\n            }\n            // do we have to many peers?\n            if (peers.size > Dhi) {\n                let peersArray = Array.from(peers);\n                // sort by score\n                peersArray.sort((a, b) => getScore(b) - getScore(a));\n                // We keep the first D_score peers by score and the remaining up to D randomly\n                // under the constraint that we keep D_out peers in the mesh (if we have that many)\n                peersArray = peersArray.slice(0, Dscore).concat(utils_1.shuffle(peersArray.slice(Dscore)));\n                // count the outbound peers we are keeping\n                let outbound = 0;\n                peersArray.slice(0, D).forEach(p => {\n                    if (this.gossipsub.outbound.get(p)) {\n                        outbound++;\n                    }\n                });\n                // if it's less than D_out, bubble up some outbound peers from the random selection\n                if (outbound < Dout) {\n                    const rotate = (i) => {\n                        // rotate the peersArray to the right and put the ith peer in the front\n                        const p = peersArray[i];\n                        for (let j = i; j > 0; j--) {\n                            peersArray[j] = peersArray[j - 1];\n                        }\n                        peersArray[0] = p;\n                    };\n                    // first bubble up all outbound peers already in the selection to the front\n                    if (outbound > 0) {\n                        let ihave = outbound;\n                        for (let i = 1; i < D && ihave > 0; i++) {\n                            if (this.gossipsub.outbound.get(peersArray[i])) {\n                                rotate(i);\n                                ihave--;\n                            }\n                        }\n                    }\n                    // now bubble up enough outbound peers outside the selection to the front\n                    let ineed = D - outbound;\n                    for (let i = D; i < peersArray.length && ineed > 0; i++) {\n                        if (this.gossipsub.outbound.get(peersArray[i])) {\n                            rotate(i);\n                            ineed--;\n                        }\n                    }\n                }\n                // prune the excess peers\n                peersArray.slice(D).forEach(prunePeer);\n            }\n            // do we have enough outbound peers?\n            if (peers.size >= Dlo) {\n                // count the outbound peers we have\n                let outbound = 0;\n                peers.forEach(p => {\n                    if (this.gossipsub.outbound.get(p)) {\n                        outbound++;\n                    }\n                });\n                // if it's less than D_out, select some peers with outbound connections and graft them\n                if (outbound < Dout) {\n                    const ineed = Dout - outbound;\n                    const backoff = this.gossipsub.backoff.get(topic);\n                    get_gossip_peers_1.getGossipPeers(this.gossipsub, topic, ineed, (id) => {\n                        // filter our current mesh peers, direct peers, peers we are backing off, peers with negative score\n                        return !peers.has(id) && !this.gossipsub.direct.has(id) && (!backoff || !backoff.has(id)) && getScore(id) >= 0;\n                    }).forEach(graftPeer);\n                }\n            }\n            // should we try to improve the mesh with opportunistic grafting?\n            if (this.gossipsub.heartbeatTicks % constants.GossipsubOpportunisticGraftTicks === 0 && peers.size > 1) {\n                // Opportunistic grafting works as follows: we check the median score of peers in the\n                // mesh; if this score is below the opportunisticGraftThreshold, we select a few peers at\n                // random with score over the median.\n                // The intention is to (slowly) improve an underperforming mesh by introducing good\n                // scoring peers that may have been gossiping at us. This allows us to get out of sticky\n                // situations where we are stuck with poor peers and also recover from churn of good peers.\n                // now compute the median peer score in the mesh\n                const peersList = Array.from(peers)\n                    .sort((a, b) => getScore(a) - getScore(b));\n                const medianIndex = peers.size / 2;\n                const medianScore = getScore(peersList[medianIndex]);\n                // if the median score is below the threshold, select a better peer (if any) and GRAFT\n                if (medianScore < this.gossipsub._options.scoreThresholds.opportunisticGraftThreshold) {\n                    const backoff = this.gossipsub.backoff.get(topic);\n                    const peersToGraft = get_gossip_peers_1.getGossipPeers(this.gossipsub, topic, constants.GossipsubOpportunisticGraftPeers, (id) => {\n                        // filter out current mesh peers, direct peers, peers we are backing off, peers below or at threshold\n                        return peers.has(id) && !this.gossipsub.direct.has(id) && (!backoff || !backoff.has(id)) && getScore(id) > medianScore;\n                    });\n                    peersToGraft.forEach(id => {\n                        this.gossipsub.log('HEARTBEAT: Opportunistically graft peer %s on topic %s', id, topic);\n                        graftPeer(id);\n                    });\n                }\n            }\n            // 2nd arg are mesh peers excluded from gossip. We have already pushed\n            // messages to them, so its redundant to gossip IHAVEs.\n            this.gossipsub._emitGossip(topic, peers);\n        });\n        // expire fanout for topics we haven't published to in a while\n        const now = this.gossipsub._now();\n        this.gossipsub.lastpub.forEach((lastpb, topic) => {\n            if ((lastpb + constants.GossipsubFanoutTTL) < now) {\n                this.gossipsub.fanout.delete(topic);\n                this.gossipsub.lastpub.delete(topic);\n            }\n        });\n        // maintain our fanout for topics we are publishing but we have not joined\n        this.gossipsub.fanout.forEach((fanoutPeers, topic) => {\n            // checks whether our peers are still in the topic and have a score above the publish threshold\n            const topicPeers = this.gossipsub.topics.get(topic);\n            fanoutPeers.forEach(id => {\n                if (!topicPeers.has(id) ||\n                    getScore(id) < this.gossipsub._options.scoreThresholds.publishThreshold) {\n                    fanoutPeers.delete(id);\n                }\n            });\n            // do we need more peers?\n            if (fanoutPeers.size < D) {\n                const ineed = D - fanoutPeers.size;\n                const peersSet = get_gossip_peers_1.getGossipPeers(this.gossipsub, topic, ineed, (id) => {\n                    // filter out existing fanout peers, direct peers, and peers with score above the publish threshold\n                    return !fanoutPeers.has(id) &&\n                        !this.gossipsub.direct.has(id) &&\n                        getScore(id) >= this.gossipsub._options.scoreThresholds.publishThreshold;\n                });\n                peersSet.forEach(id => {\n                    fanoutPeers.add(id);\n                });\n            }\n            // 2nd arg are fanout peers excluded from gossip.\n            // We have already pushed messages to them, so its redundant to gossip IHAVEs\n            this.gossipsub._emitGossip(topic, fanoutPeers);\n        });\n        // send coalesced GRAFT/PRUNE messages (will piggyback gossip)\n        this.gossipsub._sendGraftPrune(tograft, toprune, noPX);\n        // flush pending gossip that wasn't piggybacked above\n        this.gossipsub._flush();\n        // advance the message history window\n        this.gossipsub.messageCache.shift();\n        this.gossipsub.emit('gossipsub:heartbeat');\n    }\n}\nexports.Heartbeat = Heartbeat;\n"]},"metadata":{},"sourceType":"script"}