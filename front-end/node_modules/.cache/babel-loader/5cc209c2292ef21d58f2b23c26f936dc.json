{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IKHandshake = void 0;\n\nconst ik_1 = require(\"./handshakes/ik\");\n\nconst buffer_1 = require(\"buffer\");\n\nconst encoder_1 = require(\"./encoder\");\n\nconst utils_1 = require(\"./utils\");\n\nconst errors_1 = require(\"./errors\");\n\nconst logger_1 = require(\"./logger\");\n\nclass IKHandshake {\n  constructor(isInitiator, payload, prologue, staticKeypair, connection, remoteStaticKey, remotePeer, handshake) {\n    this.isInitiator = isInitiator;\n    this.payload = buffer_1.Buffer.from(payload);\n    this.prologue = prologue;\n    this.staticKeypair = staticKeypair;\n    this.connection = connection;\n\n    if (remotePeer) {\n      this.remotePeer = remotePeer;\n    }\n\n    this.ik = handshake !== null && handshake !== void 0 ? handshake : new ik_1.IK();\n    this.session = this.ik.initSession(this.isInitiator, this.prologue, this.staticKeypair, remoteStaticKey);\n    this.remoteEarlyData = buffer_1.Buffer.alloc(0);\n  }\n\n  async stage0() {\n    logger_1.logLocalStaticKeys(this.session.hs.s);\n    logger_1.logRemoteStaticKey(this.session.hs.rs);\n\n    if (this.isInitiator) {\n      logger_1.logger('IK Stage 0 - Initiator sending message...');\n      const messageBuffer = this.ik.sendMessage(this.session, this.payload);\n      this.connection.writeLP(encoder_1.encode1(messageBuffer));\n      logger_1.logger('IK Stage 0 - Initiator sent message.');\n      logger_1.logLocalEphemeralKeys(this.session.hs.e);\n    } else {\n      logger_1.logger('IK Stage 0 - Responder receiving message...');\n      const receivedMsg = await this.connection.readLP();\n\n      try {\n        const receivedMessageBuffer = encoder_1.decode1(receivedMsg.slice());\n        const {\n          plaintext,\n          valid\n        } = this.ik.recvMessage(this.session, receivedMessageBuffer);\n\n        if (!valid) {\n          throw new Error('ik handshake stage 0 decryption validation fail');\n        }\n\n        logger_1.logger('IK Stage 0 - Responder got message, going to verify payload.');\n        const decodedPayload = await utils_1.decodePayload(plaintext);\n        this.remotePeer = this.remotePeer || (await utils_1.getPeerIdFromPayload(decodedPayload));\n        await utils_1.verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);\n        this.setRemoteEarlyData(decodedPayload.data);\n        logger_1.logger('IK Stage 0 - Responder successfully verified payload!');\n        logger_1.logRemoteEphemeralKey(this.session.hs.re);\n      } catch (e) {\n        const err = e;\n        logger_1.logger('Responder breaking up with IK handshake in stage 0.');\n        throw new errors_1.FailedIKError(receivedMsg, `Error occurred while verifying initiator's signed payload: ${err.message}`);\n      }\n    }\n  }\n\n  async stage1() {\n    if (this.isInitiator) {\n      logger_1.logger('IK Stage 1 - Initiator receiving message...');\n      const receivedMsg = (await this.connection.readLP()).slice();\n      const receivedMessageBuffer = encoder_1.decode0(buffer_1.Buffer.from(receivedMsg));\n      const {\n        plaintext,\n        valid\n      } = this.ik.recvMessage(this.session, receivedMessageBuffer);\n      logger_1.logger('IK Stage 1 - Initiator got message, going to verify payload.');\n\n      try {\n        if (!valid) {\n          throw new Error('ik stage 1 decryption validation fail');\n        }\n\n        const decodedPayload = await utils_1.decodePayload(plaintext);\n        this.remotePeer = this.remotePeer || (await utils_1.getPeerIdFromPayload(decodedPayload));\n        await utils_1.verifySignedPayload(receivedMessageBuffer.ns.slice(0, 32), decodedPayload, this.remotePeer);\n        this.setRemoteEarlyData(decodedPayload.data);\n        logger_1.logger('IK Stage 1 - Initiator successfully verified payload!');\n        logger_1.logRemoteEphemeralKey(this.session.hs.re);\n      } catch (e) {\n        const err = e;\n        logger_1.logger('Initiator breaking up with IK handshake in stage 1.');\n        throw new errors_1.FailedIKError(receivedMsg, `Error occurred while verifying responder's signed payload: ${err.message}`);\n      }\n    } else {\n      logger_1.logger('IK Stage 1 - Responder sending message...');\n      const messageBuffer = this.ik.sendMessage(this.session, this.payload);\n      this.connection.writeLP(encoder_1.encode0(messageBuffer));\n      logger_1.logger('IK Stage 1 - Responder sent message...');\n      logger_1.logLocalEphemeralKeys(this.session.hs.e);\n    }\n\n    logger_1.logCipherState(this.session);\n  }\n\n  decrypt(ciphertext, session) {\n    const cs = this.getCS(session, false);\n    return this.ik.decryptWithAd(cs, buffer_1.Buffer.alloc(0), ciphertext);\n  }\n\n  encrypt(plaintext, session) {\n    const cs = this.getCS(session);\n    return this.ik.encryptWithAd(cs, buffer_1.Buffer.alloc(0), plaintext);\n  }\n\n  getLocalEphemeralKeys() {\n    if (!this.session.hs.e) {\n      throw new Error('Ephemeral keys do not exist.');\n    }\n\n    return this.session.hs.e;\n  }\n\n  getCS(session, encryption = true) {\n    if (!session.cs1 || !session.cs2) {\n      throw new Error('Handshake not completed properly, cipher state does not exist.');\n    }\n\n    if (this.isInitiator) {\n      return encryption ? session.cs1 : session.cs2;\n    } else {\n      return encryption ? session.cs2 : session.cs1;\n    }\n  }\n\n  setRemoteEarlyData(data) {\n    if (data) {\n      this.remoteEarlyData = buffer_1.Buffer.from(data.buffer, data.byteOffset, data.length);\n    }\n  }\n\n}\n\nexports.IKHandshake = IKHandshake;","map":{"version":3,"sources":["../../src/handshake-ik.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IKHandshake = void 0;\nconst ik_1 = require(\"./handshakes/ik\");\nconst buffer_1 = require(\"buffer\");\nconst encoder_1 = require(\"./encoder\");\nconst utils_1 = require(\"./utils\");\nconst errors_1 = require(\"./errors\");\nconst logger_1 = require(\"./logger\");\nclass IKHandshake {\n    constructor(isInitiator, payload, prologue, staticKeypair, connection, remoteStaticKey, remotePeer, handshake) {\n        this.isInitiator = isInitiator;\n        this.payload = buffer_1.Buffer.from(payload);\n        this.prologue = prologue;\n        this.staticKeypair = staticKeypair;\n        this.connection = connection;\n        if (remotePeer) {\n            this.remotePeer = remotePeer;\n        }\n        this.ik = handshake !== null && handshake !== void 0 ? handshake : new ik_1.IK();\n        this.session = this.ik.initSession(this.isInitiator, this.prologue, this.staticKeypair, remoteStaticKey);\n        this.remoteEarlyData = buffer_1.Buffer.alloc(0);\n    }\n    async stage0() {\n        logger_1.logLocalStaticKeys(this.session.hs.s);\n        logger_1.logRemoteStaticKey(this.session.hs.rs);\n        if (this.isInitiator) {\n            logger_1.logger('IK Stage 0 - Initiator sending message...');\n            const messageBuffer = this.ik.sendMessage(this.session, this.payload);\n            this.connection.writeLP(encoder_1.encode1(messageBuffer));\n            logger_1.logger('IK Stage 0 - Initiator sent message.');\n            logger_1.logLocalEphemeralKeys(this.session.hs.e);\n        }\n        else {\n            logger_1.logger('IK Stage 0 - Responder receiving message...');\n            const receivedMsg = await this.connection.readLP();\n            try {\n                const receivedMessageBuffer = encoder_1.decode1(receivedMsg.slice());\n                const { plaintext, valid } = this.ik.recvMessage(this.session, receivedMessageBuffer);\n                if (!valid) {\n                    throw new Error('ik handshake stage 0 decryption validation fail');\n                }\n                logger_1.logger('IK Stage 0 - Responder got message, going to verify payload.');\n                const decodedPayload = await utils_1.decodePayload(plaintext);\n                this.remotePeer = this.remotePeer || await utils_1.getPeerIdFromPayload(decodedPayload);\n                await utils_1.verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);\n                this.setRemoteEarlyData(decodedPayload.data);\n                logger_1.logger('IK Stage 0 - Responder successfully verified payload!');\n                logger_1.logRemoteEphemeralKey(this.session.hs.re);\n            }\n            catch (e) {\n                const err = e;\n                logger_1.logger('Responder breaking up with IK handshake in stage 0.');\n                throw new errors_1.FailedIKError(receivedMsg, `Error occurred while verifying initiator's signed payload: ${err.message}`);\n            }\n        }\n    }\n    async stage1() {\n        if (this.isInitiator) {\n            logger_1.logger('IK Stage 1 - Initiator receiving message...');\n            const receivedMsg = (await this.connection.readLP()).slice();\n            const receivedMessageBuffer = encoder_1.decode0(buffer_1.Buffer.from(receivedMsg));\n            const { plaintext, valid } = this.ik.recvMessage(this.session, receivedMessageBuffer);\n            logger_1.logger('IK Stage 1 - Initiator got message, going to verify payload.');\n            try {\n                if (!valid) {\n                    throw new Error('ik stage 1 decryption validation fail');\n                }\n                const decodedPayload = await utils_1.decodePayload(plaintext);\n                this.remotePeer = this.remotePeer || await utils_1.getPeerIdFromPayload(decodedPayload);\n                await utils_1.verifySignedPayload(receivedMessageBuffer.ns.slice(0, 32), decodedPayload, this.remotePeer);\n                this.setRemoteEarlyData(decodedPayload.data);\n                logger_1.logger('IK Stage 1 - Initiator successfully verified payload!');\n                logger_1.logRemoteEphemeralKey(this.session.hs.re);\n            }\n            catch (e) {\n                const err = e;\n                logger_1.logger('Initiator breaking up with IK handshake in stage 1.');\n                throw new errors_1.FailedIKError(receivedMsg, `Error occurred while verifying responder's signed payload: ${err.message}`);\n            }\n        }\n        else {\n            logger_1.logger('IK Stage 1 - Responder sending message...');\n            const messageBuffer = this.ik.sendMessage(this.session, this.payload);\n            this.connection.writeLP(encoder_1.encode0(messageBuffer));\n            logger_1.logger('IK Stage 1 - Responder sent message...');\n            logger_1.logLocalEphemeralKeys(this.session.hs.e);\n        }\n        logger_1.logCipherState(this.session);\n    }\n    decrypt(ciphertext, session) {\n        const cs = this.getCS(session, false);\n        return this.ik.decryptWithAd(cs, buffer_1.Buffer.alloc(0), ciphertext);\n    }\n    encrypt(plaintext, session) {\n        const cs = this.getCS(session);\n        return this.ik.encryptWithAd(cs, buffer_1.Buffer.alloc(0), plaintext);\n    }\n    getLocalEphemeralKeys() {\n        if (!this.session.hs.e) {\n            throw new Error('Ephemeral keys do not exist.');\n        }\n        return this.session.hs.e;\n    }\n    getCS(session, encryption = true) {\n        if (!session.cs1 || !session.cs2) {\n            throw new Error('Handshake not completed properly, cipher state does not exist.');\n        }\n        if (this.isInitiator) {\n            return encryption ? session.cs1 : session.cs2;\n        }\n        else {\n            return encryption ? session.cs2 : session.cs1;\n        }\n    }\n    setRemoteEarlyData(data) {\n        if (data) {\n            this.remoteEarlyData = buffer_1.Buffer.from(data.buffer, data.byteOffset, data.length);\n        }\n    }\n}\nexports.IKHandshake = IKHandshake;\n//# sourceMappingURL=handshake-ik.js.map"]},"metadata":{},"sourceType":"script"}