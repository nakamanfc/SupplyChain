{"ast":null,"code":"'use strict';\n\nvar extractDataFromBlock = require('../../../utils/extract-data-from-block.js');\n\nvar validateOffsetAndLength = require('../../../utils/validate-offset-and-length.js');\n\nvar ipfsUnixfs = require('ipfs-unixfs');\n\nvar errCode = require('err-code');\n\nvar dagPb = require('@ipld/dag-pb');\n\nvar dagCbor = require('@ipld/dag-cbor');\n\nvar raw = require('multiformats/codecs/raw');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n\n  n['default'] = e;\n  return Object.freeze(n);\n}\n\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\n\nvar dagPb__namespace = /*#__PURE__*/_interopNamespace(dagPb);\n\nvar dagCbor__namespace = /*#__PURE__*/_interopNamespace(dagCbor);\n\nvar raw__namespace = /*#__PURE__*/_interopNamespace(raw);\n\nasync function* emitBytes(blockstore, node, start, end, streamPosition = 0, options) {\n  if (node instanceof Uint8Array) {\n    const buf = extractDataFromBlock(node, streamPosition, start, end);\n\n    if (buf.length) {\n      yield buf;\n    }\n\n    streamPosition += buf.length;\n    return streamPosition;\n  }\n\n  if (node.Data == null) {\n    throw errCode__default['default'](new Error('no data in PBNode'), 'ERR_NOT_UNIXFS');\n  }\n\n  let file;\n\n  try {\n    file = ipfsUnixfs.UnixFS.unmarshal(node.Data);\n  } catch (err) {\n    throw errCode__default['default'](err, 'ERR_NOT_UNIXFS');\n  }\n\n  if (file.data && file.data.length) {\n    const buf = extractDataFromBlock(file.data, streamPosition, start, end);\n\n    if (buf.length) {\n      yield buf;\n    }\n\n    streamPosition += file.data.length;\n  }\n\n  let childStart = streamPosition;\n\n  for (let i = 0; i < node.Links.length; i++) {\n    const childLink = node.Links[i];\n    const childEnd = streamPosition + file.blockSizes[i];\n\n    if (start >= childStart && start < childEnd || end > childStart && end <= childEnd || start < childStart && end > childEnd) {\n      const block = await blockstore.get(childLink.Hash, {\n        signal: options.signal\n      });\n      let child;\n\n      switch (childLink.Hash.code) {\n        case dagPb__namespace.code:\n          child = await dagPb__namespace.decode(block);\n          break;\n\n        case raw__namespace.code:\n          child = block;\n          break;\n\n        case dagCbor__namespace.code:\n          child = await dagCbor__namespace.decode(block);\n          break;\n\n        default:\n          throw Error(`Unsupported codec: ${childLink.Hash.code}`);\n      }\n\n      for await (const buf of emitBytes(blockstore, child, start, end, streamPosition, options)) {\n        streamPosition += buf.length;\n        yield buf;\n      }\n    }\n\n    streamPosition = childEnd;\n    childStart = childEnd + 1;\n  }\n}\n\nconst fileContent = (cid, node, unixfs, path, resolve, depth, blockstore) => {\n  function yieldFileContent(options = {}) {\n    const fileSize = unixfs.fileSize();\n\n    if (fileSize === undefined) {\n      throw new Error('File was a directory');\n    }\n\n    const {\n      offset,\n      length\n    } = validateOffsetAndLength(fileSize, options.offset, options.length);\n    const start = offset;\n    const end = offset + length;\n    return emitBytes(blockstore, node, start, end, 0, options);\n  }\n\n  return yieldFileContent;\n};\n\nmodule.exports = fileContent;","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/ipfs-unixfs-exporter/cjs/src/resolvers/unixfs-v1/content/file.js"],"names":["extractDataFromBlock","require","validateOffsetAndLength","ipfsUnixfs","errCode","dagPb","dagCbor","raw","_interopDefaultLegacy","e","_interopNamespace","__esModule","n","Object","create","keys","forEach","k","d","getOwnPropertyDescriptor","defineProperty","get","enumerable","freeze","errCode__default","dagPb__namespace","dagCbor__namespace","raw__namespace","emitBytes","blockstore","node","start","end","streamPosition","options","Uint8Array","buf","length","Data","Error","file","UnixFS","unmarshal","err","data","childStart","i","Links","childLink","childEnd","blockSizes","block","Hash","signal","child","code","decode","fileContent","cid","unixfs","path","resolve","depth","yieldFileContent","fileSize","undefined","offset","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar extractDataFromBlock = require('../../../utils/extract-data-from-block.js');\nvar validateOffsetAndLength = require('../../../utils/validate-offset-and-length.js');\nvar ipfsUnixfs = require('ipfs-unixfs');\nvar errCode = require('err-code');\nvar dagPb = require('@ipld/dag-pb');\nvar dagCbor = require('@ipld/dag-cbor');\nvar raw = require('multiformats/codecs/raw');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n  n['default'] = e;\n  return Object.freeze(n);\n}\n\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\nvar dagPb__namespace = /*#__PURE__*/_interopNamespace(dagPb);\nvar dagCbor__namespace = /*#__PURE__*/_interopNamespace(dagCbor);\nvar raw__namespace = /*#__PURE__*/_interopNamespace(raw);\n\nasync function* emitBytes(blockstore, node, start, end, streamPosition = 0, options) {\n  if (node instanceof Uint8Array) {\n    const buf = extractDataFromBlock(node, streamPosition, start, end);\n    if (buf.length) {\n      yield buf;\n    }\n    streamPosition += buf.length;\n    return streamPosition;\n  }\n  if (node.Data == null) {\n    throw errCode__default['default'](new Error('no data in PBNode'), 'ERR_NOT_UNIXFS');\n  }\n  let file;\n  try {\n    file = ipfsUnixfs.UnixFS.unmarshal(node.Data);\n  } catch (err) {\n    throw errCode__default['default'](err, 'ERR_NOT_UNIXFS');\n  }\n  if (file.data && file.data.length) {\n    const buf = extractDataFromBlock(file.data, streamPosition, start, end);\n    if (buf.length) {\n      yield buf;\n    }\n    streamPosition += file.data.length;\n  }\n  let childStart = streamPosition;\n  for (let i = 0; i < node.Links.length; i++) {\n    const childLink = node.Links[i];\n    const childEnd = streamPosition + file.blockSizes[i];\n    if (start >= childStart && start < childEnd || end > childStart && end <= childEnd || start < childStart && end > childEnd) {\n      const block = await blockstore.get(childLink.Hash, { signal: options.signal });\n      let child;\n      switch (childLink.Hash.code) {\n      case dagPb__namespace.code:\n        child = await dagPb__namespace.decode(block);\n        break;\n      case raw__namespace.code:\n        child = block;\n        break;\n      case dagCbor__namespace.code:\n        child = await dagCbor__namespace.decode(block);\n        break;\n      default:\n        throw Error(`Unsupported codec: ${ childLink.Hash.code }`);\n      }\n      for await (const buf of emitBytes(blockstore, child, start, end, streamPosition, options)) {\n        streamPosition += buf.length;\n        yield buf;\n      }\n    }\n    streamPosition = childEnd;\n    childStart = childEnd + 1;\n  }\n}\nconst fileContent = (cid, node, unixfs, path, resolve, depth, blockstore) => {\n  function yieldFileContent(options = {}) {\n    const fileSize = unixfs.fileSize();\n    if (fileSize === undefined) {\n      throw new Error('File was a directory');\n    }\n    const {offset, length} = validateOffsetAndLength(fileSize, options.offset, options.length);\n    const start = offset;\n    const end = offset + length;\n    return emitBytes(blockstore, node, start, end, 0, options);\n  }\n  return yieldFileContent;\n};\n\nmodule.exports = fileContent;\n"]},"metadata":{},"sourceType":"script"}