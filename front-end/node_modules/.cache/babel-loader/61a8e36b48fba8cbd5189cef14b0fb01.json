{"ast":null,"code":"'use strict';\n\nconst PeerId = require('peer-id');\n\nconst {\n  Key,\n  Errors\n} = require('interface-datastore');\n\nconst errcode = require('err-code');\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('ipfs:ipns:publisher'), {\n  error: debug('ipfs:ipns:publisher:error')\n});\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst {\n  equals: uint8ArrayEquals\n} = require('uint8arrays/equals');\n\nconst ipns = require('ipns');\n/**\n * @typedef {import('libp2p-crypto').PrivateKey} PrivateKey\n * @typedef {import('libp2p-crypto').PublicKey} PublicKey\n * @typedef {import('ipns').IPNSEntry} IPNSEntry\n */\n\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code;\nconst defaultRecordLifetime = 60 * 60 * 1000; // IpnsPublisher is capable of publishing and resolving names to the IPFS routing system.\n\nclass IpnsPublisher {\n  /**\n   * @param {import('ipfs-core-types/src/utils').BufferStore} routing\n   * @param {import('interface-datastore').Datastore} datastore\n   */\n  constructor(routing, datastore) {\n    this._routing = routing;\n    this._datastore = datastore;\n  }\n  /**\n   * Publish record with a eol\n   *\n   * @param {PrivateKey} privKey\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   */\n\n\n  async publishWithEOL(privKey, value, lifetime) {\n    if (!privKey || !privKey.bytes) {\n      throw errcode(new Error('invalid private key'), 'ERR_INVALID_PRIVATE_KEY');\n    }\n\n    const peerId = await PeerId.createFromPrivKey(privKey.bytes);\n    const record = await this._updateOrCreateRecord(privKey, value, lifetime, peerId);\n    return this._putRecordToRouting(record, peerId);\n  }\n  /**\n   * Accepts a keypair, as well as a value (ipfsPath), and publishes it out to the routing system\n   *\n   * @param {PrivateKey} privKey\n   * @param {Uint8Array} value\n   */\n\n\n  publish(privKey, value) {\n    return this.publishWithEOL(privKey, value, defaultRecordLifetime);\n  }\n  /**\n   * @param {IPNSEntry} record\n   * @param {PeerId} peerId\n   */\n\n\n  async _putRecordToRouting(record, peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      const errMsg = 'peerId received is not valid';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID');\n    } // @ts-ignore - accessing private property isn't allowed\n\n\n    const publicKey = peerId._pubKey;\n    const embedPublicKeyRecord = await ipns.embedPublicKey(publicKey, record);\n    const keys = ipns.getIdKeys(peerId.toBytes());\n    await this._publishEntry(keys.routingKey, embedPublicKeyRecord || record); // Publish the public key to support old go-ipfs nodes that are looking for it in the routing\n    // We will be able to deprecate this part in the future, since the public keys will be only\n    // in IPNS record and the peerId.\n\n    await this._publishPublicKey(keys.routingPubKey, publicKey);\n    return embedPublicKeyRecord || record;\n  }\n  /**\n   * @param {Key} key\n   * @param {IPNSEntry} entry\n   */\n\n\n  async _publishEntry(key, entry) {\n    if (!(key instanceof Key)) {\n      const errMsg = 'datastore key does not have a valid format';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n    }\n\n    let entryData;\n\n    try {\n      // Marshal record\n      entryData = ipns.marshal(entry);\n    } catch (err) {\n      log.error(err);\n      throw err;\n    } // Add record to routing (buffer key)\n\n\n    try {\n      const res = await this._routing.put(key.uint8Array(), entryData);\n      log(`ipns record for ${uint8ArrayToString(key.uint8Array(), 'base64')} was stored in the routing`);\n      return res;\n    } catch (err) {\n      const errMsg = `ipns record for ${uint8ArrayToString(key.uint8Array(), 'base64')} could not be stored in the routing`;\n      log.error(errMsg);\n      log.error(err);\n      throw errcode(new Error(errMsg), 'ERR_PUTTING_TO_ROUTING');\n    }\n  }\n  /**\n   * @param {Key} key\n   * @param {PublicKey} publicKey\n   */\n\n\n  async _publishPublicKey(key, publicKey) {\n    if (!(key instanceof Key)) {\n      const errMsg = 'datastore key does not have a valid format';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n    }\n\n    if (!publicKey || !publicKey.bytes) {\n      const errMsg = 'one or more of the provided parameters are not defined';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_UNDEFINED_PARAMETER');\n    } // Add public key to routing (buffer key)\n\n\n    try {\n      const res = await this._routing.put(key.uint8Array(), publicKey.bytes);\n      log(`public key for ${uint8ArrayToString(key.uint8Array(), 'base64')} was stored in the routing`);\n      return res;\n    } catch (err) {\n      const errMsg = `public key for ${uint8ArrayToString(key.uint8Array(), 'base64')} could not be stored in the routing`;\n      log.error(errMsg);\n      log.error(err);\n      throw errcode(new Error(errMsg), 'ERR_PUTTING_TO_ROUTING');\n    }\n  }\n  /**\n   * Returns the record this node has published corresponding to the given peer ID.\n   *\n   * If `checkRouting` is true and we have no existing record, this method will check the routing system for any existing records.\n   *\n   * @param {PeerId} peerId\n   * @param {object} options\n   * @param {boolean} [options.checkRouting]\n   */\n\n\n  async _getPublished(peerId, options = {}) {\n    if (!PeerId.isPeerId(peerId)) {\n      const errMsg = 'peerId received is not valid';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID');\n    }\n\n    const checkRouting = options.checkRouting !== false;\n\n    try {\n      const dsVal = await this._datastore.get(ipns.getLocalKey(peerId.id)); // unmarshal data\n\n      return this._unmarshalData(dsVal);\n    } catch (err) {\n      if (err.code !== ERR_NOT_FOUND) {\n        const errMsg = `unexpected error getting the ipns record ${peerId.id} from datastore`;\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_UNEXPECTED_DATASTORE_RESPONSE');\n      }\n\n      if (!checkRouting) {\n        throw errcode(err, 'ERR_NOT_FOUND_AND_CHECK_ROUTING_NOT_ENABLED');\n      } // Try to get from routing\n\n\n      try {\n        const keys = ipns.getIdKeys(peerId.toBytes());\n        const res = await this._routing.get(keys.routingKey.uint8Array()); // unmarshal data\n\n        return this._unmarshalData(res);\n      } catch (err) {\n        log.error(err);\n        throw err;\n      }\n    }\n  }\n  /**\n   * @param {Uint8Array} data\n   */\n\n\n  _unmarshalData(data) {\n    try {\n      return ipns.unmarshal(data);\n    } catch (err) {\n      throw errcode(err, 'ERR_INVALID_RECORD_DATA');\n    }\n  }\n  /**\n   * @param {PrivateKey} privKey\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   * @param {PeerId} peerId\n   */\n\n\n  async _updateOrCreateRecord(privKey, value, lifetime, peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      const errMsg = 'peerId received is not valid';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID');\n    }\n\n    const getPublishedOptions = {\n      checkRouting: true\n    };\n    let record;\n\n    try {\n      record = await this._getPublished(peerId, getPublishedOptions);\n    } catch (err) {\n      if (err.code !== ERR_NOT_FOUND) {\n        const errMsg = `unexpected error when determining the last published IPNS record for ${peerId.id} ${err.stack}`;\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_DETERMINING_PUBLISHED_RECORD');\n      }\n    } // Determinate the record sequence number\n\n\n    let seqNumber = 0n;\n\n    if (record && record.sequence !== undefined) {\n      seqNumber = !uint8ArrayEquals(record.value, value) ? BigInt(record.sequence) + 1n : BigInt(record.sequence);\n    }\n\n    let entryData;\n\n    try {\n      // Create record\n      entryData = await ipns.create(privKey, value, seqNumber, lifetime);\n    } catch (err) {\n      const errMsg = `ipns record for ${value} could not be created`;\n      log.error(err);\n      throw errcode(new Error(errMsg), 'ERR_CREATING_IPNS_RECORD');\n    } // TODO IMPROVEMENT - set ttl (still experimental feature for go)\n\n\n    try {\n      // Marshal record\n      const data = ipns.marshal(entryData); // Store the new record\n\n      await this._datastore.put(ipns.getLocalKey(peerId.id), data);\n      log(`ipns record for ${uint8ArrayToString(value, 'base32')} was stored in the datastore`);\n      return entryData;\n    } catch (err) {\n      const errMsg = `ipns record for ${value} could not be stored in the datastore`;\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_STORING_IN_DATASTORE');\n    }\n  }\n\n}\n\nIpnsPublisher.defaultRecordLifetime = defaultRecordLifetime;\nexports = module.exports = IpnsPublisher;","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/ipfs-core/src/ipns/publisher.js"],"names":["PeerId","require","Key","Errors","errcode","debug","log","Object","assign","error","toString","uint8ArrayToString","equals","uint8ArrayEquals","ipns","ERR_NOT_FOUND","notFoundError","code","defaultRecordLifetime","IpnsPublisher","constructor","routing","datastore","_routing","_datastore","publishWithEOL","privKey","value","lifetime","bytes","Error","peerId","createFromPrivKey","record","_updateOrCreateRecord","_putRecordToRouting","publish","isPeerId","errMsg","publicKey","_pubKey","embedPublicKeyRecord","embedPublicKey","keys","getIdKeys","toBytes","_publishEntry","routingKey","_publishPublicKey","routingPubKey","key","entry","entryData","marshal","err","res","put","uint8Array","_getPublished","options","checkRouting","dsVal","get","getLocalKey","id","_unmarshalData","data","unmarshal","getPublishedOptions","stack","seqNumber","sequence","undefined","BigInt","create","exports","module"],"mappings":"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","sourcesContent":["'use strict'\n\nconst PeerId = require('peer-id')\nconst { Key, Errors } = require('interface-datastore')\nconst errcode = require('err-code')\nconst debug = require('debug')\nconst log = Object.assign(debug('ipfs:ipns:publisher'), {\n  error: debug('ipfs:ipns:publisher:error')\n})\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst { equals: uint8ArrayEquals } = require('uint8arrays/equals')\n\nconst ipns = require('ipns')\n\n/**\n * @typedef {import('libp2p-crypto').PrivateKey} PrivateKey\n * @typedef {import('libp2p-crypto').PublicKey} PublicKey\n * @typedef {import('ipns').IPNSEntry} IPNSEntry\n */\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code\nconst defaultRecordLifetime = 60 * 60 * 1000\n\n// IpnsPublisher is capable of publishing and resolving names to the IPFS routing system.\nclass IpnsPublisher {\n  /**\n   * @param {import('ipfs-core-types/src/utils').BufferStore} routing\n   * @param {import('interface-datastore').Datastore} datastore\n   */\n  constructor (routing, datastore) {\n    this._routing = routing\n    this._datastore = datastore\n  }\n\n  /**\n   * Publish record with a eol\n   *\n   * @param {PrivateKey} privKey\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   */\n  async publishWithEOL (privKey, value, lifetime) {\n    if (!privKey || !privKey.bytes) {\n      throw errcode(new Error('invalid private key'), 'ERR_INVALID_PRIVATE_KEY')\n    }\n\n    const peerId = await PeerId.createFromPrivKey(privKey.bytes)\n    const record = await this._updateOrCreateRecord(privKey, value, lifetime, peerId)\n\n    return this._putRecordToRouting(record, peerId)\n  }\n\n  /**\n   * Accepts a keypair, as well as a value (ipfsPath), and publishes it out to the routing system\n   *\n   * @param {PrivateKey} privKey\n   * @param {Uint8Array} value\n   */\n  publish (privKey, value) {\n    return this.publishWithEOL(privKey, value, defaultRecordLifetime)\n  }\n\n  /**\n   * @param {IPNSEntry} record\n   * @param {PeerId} peerId\n   */\n  async _putRecordToRouting (record, peerId) {\n    if (!(PeerId.isPeerId(peerId))) {\n      const errMsg = 'peerId received is not valid'\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID')\n    }\n\n    // @ts-ignore - accessing private property isn't allowed\n    const publicKey = peerId._pubKey\n    const embedPublicKeyRecord = await ipns.embedPublicKey(publicKey, record)\n    const keys = ipns.getIdKeys(peerId.toBytes())\n\n    await this._publishEntry(keys.routingKey, embedPublicKeyRecord || record)\n\n    // Publish the public key to support old go-ipfs nodes that are looking for it in the routing\n    // We will be able to deprecate this part in the future, since the public keys will be only\n    // in IPNS record and the peerId.\n    await this._publishPublicKey(keys.routingPubKey, publicKey)\n\n    return embedPublicKeyRecord || record\n  }\n\n  /**\n   * @param {Key} key\n   * @param {IPNSEntry} entry\n   */\n  async _publishEntry (key, entry) {\n    if (!(key instanceof Key)) {\n      const errMsg = 'datastore key does not have a valid format'\n\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY')\n    }\n\n    let entryData\n    try {\n      // Marshal record\n      entryData = ipns.marshal(entry)\n    } catch (err) {\n      log.error(err)\n\n      throw err\n    }\n\n    // Add record to routing (buffer key)\n    try {\n      const res = await this._routing.put(key.uint8Array(), entryData)\n      log(`ipns record for ${uint8ArrayToString(key.uint8Array(), 'base64')} was stored in the routing`)\n\n      return res\n    } catch (err) {\n      const errMsg = `ipns record for ${uint8ArrayToString(key.uint8Array(), 'base64')} could not be stored in the routing`\n      log.error(errMsg)\n      log.error(err)\n\n      throw errcode(new Error(errMsg), 'ERR_PUTTING_TO_ROUTING')\n    }\n  }\n\n  /**\n   * @param {Key} key\n   * @param {PublicKey} publicKey\n   */\n  async _publishPublicKey (key, publicKey) {\n    if (!(key instanceof Key)) {\n      const errMsg = 'datastore key does not have a valid format'\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY')\n    }\n\n    if (!publicKey || !publicKey.bytes) {\n      const errMsg = 'one or more of the provided parameters are not defined'\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_UNDEFINED_PARAMETER')\n    }\n\n    // Add public key to routing (buffer key)\n    try {\n      const res = await this._routing.put(key.uint8Array(), publicKey.bytes)\n      log(`public key for ${uint8ArrayToString(key.uint8Array(), 'base64')} was stored in the routing`)\n\n      return res\n    } catch (err) {\n      const errMsg = `public key for ${uint8ArrayToString(key.uint8Array(), 'base64')} could not be stored in the routing`\n      log.error(errMsg)\n      log.error(err)\n\n      throw errcode(new Error(errMsg), 'ERR_PUTTING_TO_ROUTING')\n    }\n  }\n\n  /**\n   * Returns the record this node has published corresponding to the given peer ID.\n   *\n   * If `checkRouting` is true and we have no existing record, this method will check the routing system for any existing records.\n   *\n   * @param {PeerId} peerId\n   * @param {object} options\n   * @param {boolean} [options.checkRouting]\n   */\n  async _getPublished (peerId, options = {}) {\n    if (!(PeerId.isPeerId(peerId))) {\n      const errMsg = 'peerId received is not valid'\n\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID')\n    }\n\n    const checkRouting = options.checkRouting !== false\n\n    try {\n      const dsVal = await this._datastore.get(ipns.getLocalKey(peerId.id))\n\n      // unmarshal data\n      return this._unmarshalData(dsVal)\n    } catch (err) {\n      if (err.code !== ERR_NOT_FOUND) {\n        const errMsg = `unexpected error getting the ipns record ${peerId.id} from datastore`\n        log.error(errMsg)\n\n        throw errcode(new Error(errMsg), 'ERR_UNEXPECTED_DATASTORE_RESPONSE')\n      }\n\n      if (!checkRouting) {\n        throw errcode(err, 'ERR_NOT_FOUND_AND_CHECK_ROUTING_NOT_ENABLED')\n      }\n\n      // Try to get from routing\n      try {\n        const keys = ipns.getIdKeys(peerId.toBytes())\n        const res = await this._routing.get(keys.routingKey.uint8Array())\n\n        // unmarshal data\n        return this._unmarshalData(res)\n      } catch (err) {\n        log.error(err)\n\n        throw err\n      }\n    }\n  }\n\n  /**\n   * @param {Uint8Array} data\n   */\n  _unmarshalData (data) {\n    try {\n      return ipns.unmarshal(data)\n    } catch (err) {\n      throw errcode(err, 'ERR_INVALID_RECORD_DATA')\n    }\n  }\n\n  /**\n   * @param {PrivateKey} privKey\n   * @param {Uint8Array} value\n   * @param {number} lifetime\n   * @param {PeerId} peerId\n   */\n  async _updateOrCreateRecord (privKey, value, lifetime, peerId) {\n    if (!(PeerId.isPeerId(peerId))) {\n      const errMsg = 'peerId received is not valid'\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID')\n    }\n\n    const getPublishedOptions = {\n      checkRouting: true\n    }\n\n    let record\n\n    try {\n      record = await this._getPublished(peerId, getPublishedOptions)\n    } catch (err) {\n      if (err.code !== ERR_NOT_FOUND) {\n        const errMsg = `unexpected error when determining the last published IPNS record for ${peerId.id} ${err.stack}`\n        log.error(errMsg)\n\n        throw errcode(new Error(errMsg), 'ERR_DETERMINING_PUBLISHED_RECORD')\n      }\n    }\n\n    // Determinate the record sequence number\n    let seqNumber = 0n\n\n    if (record && record.sequence !== undefined) {\n      seqNumber = !uint8ArrayEquals(record.value, value) ? BigInt(record.sequence) + 1n : BigInt(record.sequence)\n    }\n\n    let entryData\n\n    try {\n      // Create record\n      entryData = await ipns.create(privKey, value, seqNumber, lifetime)\n    } catch (err) {\n      const errMsg = `ipns record for ${value} could not be created`\n\n      log.error(err)\n      throw errcode(new Error(errMsg), 'ERR_CREATING_IPNS_RECORD')\n    }\n\n    // TODO IMPROVEMENT - set ttl (still experimental feature for go)\n\n    try {\n      // Marshal record\n      const data = ipns.marshal(entryData)\n\n      // Store the new record\n      await this._datastore.put(ipns.getLocalKey(peerId.id), data)\n\n      log(`ipns record for ${uint8ArrayToString(value, 'base32')} was stored in the datastore`)\n\n      return entryData\n    } catch (err) {\n      const errMsg = `ipns record for ${value} could not be stored in the datastore`\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_STORING_IN_DATASTORE')\n    }\n  }\n}\n\nIpnsPublisher.defaultRecordLifetime = defaultRecordLifetime\nexports = module.exports = IpnsPublisher\n"]},"metadata":{},"sourceType":"script"}