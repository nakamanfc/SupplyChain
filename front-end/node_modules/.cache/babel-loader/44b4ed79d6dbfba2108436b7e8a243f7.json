{"ast":null,"code":"'use strict';\n\nconst {\n  concat\n} = require('uint8arrays/concat');\n\nconst {\n  fromString\n} = require('uint8arrays/from-string');\n\nconst webcrypto = require('../webcrypto'); // Based off of code from https://github.com/luke-park/SecureCompatibleEncryptionExamples\n\n/**\n *\n * @param {object} [options]\n * @param {string} [options.algorithm=AES-GCM]\n * @param {number} [options.nonceLength=12]\n * @param {number} [options.keyLength=16]\n * @param {string} [options.digest=sha256]\n * @param {number} [options.saltLength=16]\n * @param {number} [options.iterations=32767]\n * @returns {*}\n */\n\n\nfunction create({\n  algorithm = 'AES-GCM',\n  nonceLength = 12,\n  keyLength = 16,\n  digest = 'SHA-256',\n  saltLength = 16,\n  iterations = 32767\n} = {}) {\n  const crypto = webcrypto.get();\n  keyLength *= 8; // Browser crypto uses bits instead of bytes\n\n  /**\n   * Uses the provided password to derive a pbkdf2 key. The key\n   * will then be used to encrypt the data.\n   *\n   * @param {Uint8Array} data - The data to decrypt\n   * @param {string} password - A plain password\n   * @returns {Promise<Uint8Array>}\n   */\n\n  async function encrypt(data, password) {\n    // eslint-disable-line require-await\n    const salt = crypto.getRandomValues(new Uint8Array(saltLength));\n    const nonce = crypto.getRandomValues(new Uint8Array(nonceLength));\n    const aesGcm = {\n      name: algorithm,\n      iv: nonce\n    }; // Derive a key using PBKDF2.\n\n    const deriveParams = {\n      name: 'PBKDF2',\n      salt,\n      iterations,\n      hash: {\n        name: digest\n      }\n    };\n    const rawKey = await crypto.subtle.importKey('raw', fromString(password), {\n      name: 'PBKDF2'\n    }, false, ['deriveKey', 'deriveBits']);\n    const cryptoKey = await crypto.subtle.deriveKey(deriveParams, rawKey, {\n      name: algorithm,\n      length: keyLength\n    }, true, ['encrypt']); // Encrypt the string.\n\n    const ciphertext = await crypto.subtle.encrypt(aesGcm, cryptoKey, data);\n    return concat([salt, aesGcm.iv, new Uint8Array(ciphertext)]);\n  }\n  /**\n   * Uses the provided password to derive a pbkdf2 key. The key\n   * will then be used to decrypt the data. The options used to create\n   * this decryption cipher must be the same as those used to create\n   * the encryption cipher.\n   *\n   * @param {Uint8Array} data - The data to decrypt\n   * @param {string} password - A plain password\n   * @returns {Promise<Uint8Array>}\n   */\n\n\n  async function decrypt(data, password) {\n    const salt = data.slice(0, saltLength);\n    const nonce = data.slice(saltLength, saltLength + nonceLength);\n    const ciphertext = data.slice(saltLength + nonceLength);\n    const aesGcm = {\n      name: algorithm,\n      iv: nonce\n    }; // Derive the key using PBKDF2.\n\n    const deriveParams = {\n      name: 'PBKDF2',\n      salt,\n      iterations,\n      hash: {\n        name: digest\n      }\n    };\n    const rawKey = await crypto.subtle.importKey('raw', fromString(password), {\n      name: 'PBKDF2'\n    }, false, ['deriveKey', 'deriveBits']);\n    const cryptoKey = await crypto.subtle.deriveKey(deriveParams, rawKey, {\n      name: algorithm,\n      length: keyLength\n    }, true, ['decrypt']); // Decrypt the string.\n\n    const plaintext = await crypto.subtle.decrypt(aesGcm, cryptoKey, ciphertext);\n    return new Uint8Array(plaintext);\n  }\n\n  return {\n    encrypt,\n    decrypt\n  };\n}\n\nmodule.exports = {\n  create\n};","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/libp2p-crypto/src/ciphers/aes-gcm.browser.js"],"names":["concat","require","fromString","webcrypto","create","algorithm","nonceLength","keyLength","digest","saltLength","iterations","crypto","get","encrypt","data","password","salt","getRandomValues","Uint8Array","nonce","aesGcm","name","iv","deriveParams","hash","rawKey","subtle","importKey","cryptoKey","deriveKey","length","ciphertext","decrypt","slice","plaintext","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { concat } = require('uint8arrays/concat')\nconst { fromString } = require('uint8arrays/from-string')\n\nconst webcrypto = require('../webcrypto')\n\n// Based off of code from https://github.com/luke-park/SecureCompatibleEncryptionExamples\n\n/**\n *\n * @param {object} [options]\n * @param {string} [options.algorithm=AES-GCM]\n * @param {number} [options.nonceLength=12]\n * @param {number} [options.keyLength=16]\n * @param {string} [options.digest=sha256]\n * @param {number} [options.saltLength=16]\n * @param {number} [options.iterations=32767]\n * @returns {*}\n */\nfunction create ({\n  algorithm = 'AES-GCM',\n  nonceLength = 12,\n  keyLength = 16,\n  digest = 'SHA-256',\n  saltLength = 16,\n  iterations = 32767\n} = {}) {\n  const crypto = webcrypto.get()\n  keyLength *= 8 // Browser crypto uses bits instead of bytes\n\n  /**\n   * Uses the provided password to derive a pbkdf2 key. The key\n   * will then be used to encrypt the data.\n   *\n   * @param {Uint8Array} data - The data to decrypt\n   * @param {string} password - A plain password\n   * @returns {Promise<Uint8Array>}\n   */\n  async function encrypt (data, password) { // eslint-disable-line require-await\n    const salt = crypto.getRandomValues(new Uint8Array(saltLength))\n    const nonce = crypto.getRandomValues(new Uint8Array(nonceLength))\n    const aesGcm = { name: algorithm, iv: nonce }\n\n    // Derive a key using PBKDF2.\n    const deriveParams = { name: 'PBKDF2', salt, iterations, hash: { name: digest } }\n    const rawKey = await crypto.subtle.importKey('raw', fromString(password), { name: 'PBKDF2' }, false, ['deriveKey', 'deriveBits'])\n    const cryptoKey = await crypto.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ['encrypt'])\n\n    // Encrypt the string.\n    const ciphertext = await crypto.subtle.encrypt(aesGcm, cryptoKey, data)\n    return concat([salt, aesGcm.iv, new Uint8Array(ciphertext)])\n  }\n\n  /**\n   * Uses the provided password to derive a pbkdf2 key. The key\n   * will then be used to decrypt the data. The options used to create\n   * this decryption cipher must be the same as those used to create\n   * the encryption cipher.\n   *\n   * @param {Uint8Array} data - The data to decrypt\n   * @param {string} password - A plain password\n   * @returns {Promise<Uint8Array>}\n   */\n  async function decrypt (data, password) {\n    const salt = data.slice(0, saltLength)\n    const nonce = data.slice(saltLength, saltLength + nonceLength)\n    const ciphertext = data.slice(saltLength + nonceLength)\n    const aesGcm = { name: algorithm, iv: nonce }\n\n    // Derive the key using PBKDF2.\n    const deriveParams = { name: 'PBKDF2', salt, iterations, hash: { name: digest } }\n    const rawKey = await crypto.subtle.importKey('raw', fromString(password), { name: 'PBKDF2' }, false, ['deriveKey', 'deriveBits'])\n    const cryptoKey = await crypto.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ['decrypt'])\n\n    // Decrypt the string.\n    const plaintext = await crypto.subtle.decrypt(aesGcm, cryptoKey, ciphertext)\n    return new Uint8Array(plaintext)\n  }\n\n  return {\n    encrypt,\n    decrypt\n  }\n}\n\nmodule.exports = {\n  create\n}\n"]},"metadata":{},"sourceType":"script"}