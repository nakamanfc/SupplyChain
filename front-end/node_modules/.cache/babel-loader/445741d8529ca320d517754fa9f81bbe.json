{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isValidPublicKey = exports.getHkdf = exports.verifySignedPayload = exports.getHandshakePayload = exports.decodePayload = exports.getPeerIdFromPayload = exports.signPayload = exports.createHandshakePayload = exports.getPayload = exports.generateKeypair = void 0;\n\nconst hkdf_1 = require(\"@stablelib/hkdf\");\n\nconst sha256_1 = require(\"@stablelib/sha256\");\n\nconst x25519 = __importStar(require(\"@stablelib/x25519\"));\n\nconst buffer_1 = require(\"buffer\");\n\nconst peer_id_1 = __importDefault(require(\"peer-id\"));\n\nconst libp2p_crypto_1 = require(\"libp2p-crypto\");\n\nconst payload_1 = require(\"./proto/payload\");\n\nconst equals_1 = require(\"uint8arrays/equals\");\n\nconst NoiseHandshakePayloadProto = payload_1.pb.NoiseHandshakePayload;\n\nfunction generateKeypair() {\n  const keypair = x25519.generateKeyPair();\n  return {\n    publicKey: buffer_1.Buffer.from(keypair.publicKey.buffer, keypair.publicKey.byteOffset, keypair.publicKey.length),\n    privateKey: buffer_1.Buffer.from(keypair.secretKey.buffer, keypair.secretKey.byteOffset, keypair.secretKey.length)\n  };\n}\n\nexports.generateKeypair = generateKeypair;\n\nasync function getPayload(localPeer, staticPublicKey, earlyData) {\n  const signedPayload = await signPayload(localPeer, getHandshakePayload(staticPublicKey));\n  const earlyDataPayload = earlyData !== null && earlyData !== void 0 ? earlyData : buffer_1.Buffer.alloc(0);\n  return createHandshakePayload(localPeer.marshalPubKey(), signedPayload, earlyDataPayload);\n}\n\nexports.getPayload = getPayload;\n\nfunction createHandshakePayload(libp2pPublicKey, signedPayload, earlyData) {\n  const payloadInit = NoiseHandshakePayloadProto.create({\n    identityKey: buffer_1.Buffer.from(libp2pPublicKey),\n    identitySig: signedPayload,\n    data: earlyData !== null && earlyData !== void 0 ? earlyData : null\n  });\n  return buffer_1.Buffer.from(NoiseHandshakePayloadProto.encode(payloadInit).finish());\n}\n\nexports.createHandshakePayload = createHandshakePayload;\n\nasync function signPayload(peerId, payload) {\n  return buffer_1.Buffer.from(await peerId.privKey.sign(payload));\n}\n\nexports.signPayload = signPayload;\n\nasync function getPeerIdFromPayload(payload) {\n  return await peer_id_1.default.createFromPubKey(buffer_1.Buffer.from(payload.identityKey));\n}\n\nexports.getPeerIdFromPayload = getPeerIdFromPayload;\n\nfunction decodePayload(payload) {\n  return NoiseHandshakePayloadProto.toObject(NoiseHandshakePayloadProto.decode(buffer_1.Buffer.from(payload)));\n}\n\nexports.decodePayload = decodePayload;\n\nfunction getHandshakePayload(publicKey) {\n  return buffer_1.Buffer.concat([buffer_1.Buffer.from('noise-libp2p-static-key:'), publicKey]);\n}\n\nexports.getHandshakePayload = getHandshakePayload;\n\nasync function isValidPeerId(peerId, publicKeyProtobuf) {\n  const generatedPeerId = await peer_id_1.default.createFromPubKey(publicKeyProtobuf);\n  return equals_1.equals(generatedPeerId.id, peerId);\n}\n/**\n * Verifies signed payload, throws on any irregularities.\n *\n * @param {bytes} noiseStaticKey - owner's noise static key\n * @param {bytes} payload - decoded payload\n * @param {PeerId} remotePeer - owner's libp2p peer ID\n * @returns {Promise<PeerId>} - peer ID of payload owner\n */\n\n\nasync function verifySignedPayload(noiseStaticKey, payload, remotePeer) {\n  const identityKey = buffer_1.Buffer.from(payload.identityKey);\n\n  if (!(await isValidPeerId(remotePeer.id, identityKey))) {\n    throw new Error(\"Peer ID doesn't match libp2p public key.\");\n  }\n\n  const generatedPayload = getHandshakePayload(noiseStaticKey); // Unmarshaling from PublicKey protobuf\n\n  const publicKey = libp2p_crypto_1.keys.unmarshalPublicKey(identityKey); // TODO remove this after libp2p-crypto ships proper types\n  // eslint-disable-next-line @typescript-eslint/no-misused-promises\n\n  if (!payload.identitySig || !publicKey.verify(generatedPayload, buffer_1.Buffer.from(payload.identitySig))) {\n    throw new Error(\"Static key doesn't match to peer that signed payload!\");\n  }\n\n  return await peer_id_1.default.createFromPubKey(identityKey);\n}\n\nexports.verifySignedPayload = verifySignedPayload;\n\nfunction getHkdf(ck, ikm) {\n  const hkdf = new hkdf_1.HKDF(sha256_1.SHA256, ikm, ck);\n  const okmU8Array = hkdf.expand(96);\n  const okm = buffer_1.Buffer.from(okmU8Array.buffer, okmU8Array.byteOffset, okmU8Array.length);\n  const k1 = okm.slice(0, 32);\n  const k2 = okm.slice(32, 64);\n  const k3 = okm.slice(64, 96);\n  return [k1, k2, k3];\n}\n\nexports.getHkdf = getHkdf;\n\nfunction isValidPublicKey(pk) {\n  if (!buffer_1.Buffer.isBuffer(pk)) {\n    return false;\n  }\n\n  if (pk.length !== 32) {\n    return false;\n  }\n\n  return true;\n}\n\nexports.isValidPublicKey = isValidPublicKey;","map":{"version":3,"sources":["../../src/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isValidPublicKey = exports.getHkdf = exports.verifySignedPayload = exports.getHandshakePayload = exports.decodePayload = exports.getPeerIdFromPayload = exports.signPayload = exports.createHandshakePayload = exports.getPayload = exports.generateKeypair = void 0;\nconst hkdf_1 = require(\"@stablelib/hkdf\");\nconst sha256_1 = require(\"@stablelib/sha256\");\nconst x25519 = __importStar(require(\"@stablelib/x25519\"));\nconst buffer_1 = require(\"buffer\");\nconst peer_id_1 = __importDefault(require(\"peer-id\"));\nconst libp2p_crypto_1 = require(\"libp2p-crypto\");\nconst payload_1 = require(\"./proto/payload\");\nconst equals_1 = require(\"uint8arrays/equals\");\nconst NoiseHandshakePayloadProto = payload_1.pb.NoiseHandshakePayload;\nfunction generateKeypair() {\n    const keypair = x25519.generateKeyPair();\n    return {\n        publicKey: buffer_1.Buffer.from(keypair.publicKey.buffer, keypair.publicKey.byteOffset, keypair.publicKey.length),\n        privateKey: buffer_1.Buffer.from(keypair.secretKey.buffer, keypair.secretKey.byteOffset, keypair.secretKey.length)\n    };\n}\nexports.generateKeypair = generateKeypair;\nasync function getPayload(localPeer, staticPublicKey, earlyData) {\n    const signedPayload = await signPayload(localPeer, getHandshakePayload(staticPublicKey));\n    const earlyDataPayload = earlyData !== null && earlyData !== void 0 ? earlyData : buffer_1.Buffer.alloc(0);\n    return createHandshakePayload(localPeer.marshalPubKey(), signedPayload, earlyDataPayload);\n}\nexports.getPayload = getPayload;\nfunction createHandshakePayload(libp2pPublicKey, signedPayload, earlyData) {\n    const payloadInit = NoiseHandshakePayloadProto.create({\n        identityKey: buffer_1.Buffer.from(libp2pPublicKey),\n        identitySig: signedPayload,\n        data: earlyData !== null && earlyData !== void 0 ? earlyData : null\n    });\n    return buffer_1.Buffer.from(NoiseHandshakePayloadProto.encode(payloadInit).finish());\n}\nexports.createHandshakePayload = createHandshakePayload;\nasync function signPayload(peerId, payload) {\n    return buffer_1.Buffer.from(await peerId.privKey.sign(payload));\n}\nexports.signPayload = signPayload;\nasync function getPeerIdFromPayload(payload) {\n    return await peer_id_1.default.createFromPubKey(buffer_1.Buffer.from(payload.identityKey));\n}\nexports.getPeerIdFromPayload = getPeerIdFromPayload;\nfunction decodePayload(payload) {\n    return NoiseHandshakePayloadProto.toObject(NoiseHandshakePayloadProto.decode(buffer_1.Buffer.from(payload)));\n}\nexports.decodePayload = decodePayload;\nfunction getHandshakePayload(publicKey) {\n    return buffer_1.Buffer.concat([buffer_1.Buffer.from('noise-libp2p-static-key:'), publicKey]);\n}\nexports.getHandshakePayload = getHandshakePayload;\nasync function isValidPeerId(peerId, publicKeyProtobuf) {\n    const generatedPeerId = await peer_id_1.default.createFromPubKey(publicKeyProtobuf);\n    return equals_1.equals(generatedPeerId.id, peerId);\n}\n/**\n * Verifies signed payload, throws on any irregularities.\n *\n * @param {bytes} noiseStaticKey - owner's noise static key\n * @param {bytes} payload - decoded payload\n * @param {PeerId} remotePeer - owner's libp2p peer ID\n * @returns {Promise<PeerId>} - peer ID of payload owner\n */\nasync function verifySignedPayload(noiseStaticKey, payload, remotePeer) {\n    const identityKey = buffer_1.Buffer.from(payload.identityKey);\n    if (!(await isValidPeerId(remotePeer.id, identityKey))) {\n        throw new Error(\"Peer ID doesn't match libp2p public key.\");\n    }\n    const generatedPayload = getHandshakePayload(noiseStaticKey);\n    // Unmarshaling from PublicKey protobuf\n    const publicKey = libp2p_crypto_1.keys.unmarshalPublicKey(identityKey);\n    // TODO remove this after libp2p-crypto ships proper types\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    if (!payload.identitySig || !publicKey.verify(generatedPayload, buffer_1.Buffer.from(payload.identitySig))) {\n        throw new Error(\"Static key doesn't match to peer that signed payload!\");\n    }\n    return await peer_id_1.default.createFromPubKey(identityKey);\n}\nexports.verifySignedPayload = verifySignedPayload;\nfunction getHkdf(ck, ikm) {\n    const hkdf = new hkdf_1.HKDF(sha256_1.SHA256, ikm, ck);\n    const okmU8Array = hkdf.expand(96);\n    const okm = buffer_1.Buffer.from(okmU8Array.buffer, okmU8Array.byteOffset, okmU8Array.length);\n    const k1 = okm.slice(0, 32);\n    const k2 = okm.slice(32, 64);\n    const k3 = okm.slice(64, 96);\n    return [k1, k2, k3];\n}\nexports.getHkdf = getHkdf;\nfunction isValidPublicKey(pk) {\n    if (!buffer_1.Buffer.isBuffer(pk)) {\n        return false;\n    }\n    if (pk.length !== 32) {\n        return false;\n    }\n    return true;\n}\nexports.isValidPublicKey = isValidPublicKey;\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}