{"ast":null,"code":"'use strict';\n\nconst Key = require('interface-datastore').Key;\n\nconst KeytransformDatastore = require('./keytransform');\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').KeyQuery} KeyQuery\n * @typedef {import('interface-datastore').Options} Options\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('./types').KeyTransform} KeyTransform\n */\n\n/**\n * Wraps a given datastore into a keytransform which\n * makes a given prefix transparent.\n *\n * For example, if the prefix is `new Key(/hello)` a call\n * to `store.put(new Key('/world'), mydata)` would store the data under\n * `/hello/world`.\n *\n */\n\n\nclass NamespaceDatastore extends KeytransformDatastore {\n  /**\n   * @param {Datastore} child\n   * @param {Key} prefix\n   */\n  constructor(child, prefix) {\n    super(child, {\n      convert(key) {\n        return prefix.child(key);\n      },\n\n      invert(key) {\n        if (prefix.toString() === '/') {\n          return key;\n        }\n\n        if (!prefix.isAncestorOf(key)) {\n          throw new Error(`Expected prefix: (${prefix.toString()}) in key: ${key.toString()}`);\n        }\n\n        return new Key(key.toString().slice(prefix.toString().length), false);\n      }\n\n    });\n    this.prefix = prefix;\n  }\n  /**\n   * @param {Query} q\n   * @param {Options} [options]\n   */\n\n\n  query(q, options) {\n    if (q.prefix && this.prefix.toString() !== '/') {\n      return super.query(Object.assign({}, q, {\n        prefix: this.prefix.child(new Key(q.prefix)).toString()\n      }));\n    }\n\n    return super.query(q, options);\n  }\n  /**\n   * @param {KeyQuery} q\n   * @param {Options} [options]\n   */\n\n\n  queryKeys(q, options) {\n    if (q.prefix && this.prefix.toString() !== '/') {\n      return super.queryKeys(Object.assign({}, q, {\n        prefix: this.prefix.child(new Key(q.prefix)).toString()\n      }));\n    }\n\n    return super.queryKeys(q, options);\n  }\n\n}\n\nmodule.exports = NamespaceDatastore;","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/datastore-core/src/namespace.js"],"names":["Key","require","KeytransformDatastore","NamespaceDatastore","constructor","child","prefix","convert","key","invert","toString","isAncestorOf","Error","slice","length","query","q","options","Object","assign","queryKeys","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,GAAG,GAAGC,OAAO,CAAC,qBAAD,CAAP,CAA+BD,GAA3C;;AACA,MAAME,qBAAqB,GAAGD,OAAO,CAAC,gBAAD,CAArC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAME,kBAAN,SAAiCD,qBAAjC,CAAuD;AACrD;AACF;AACA;AACA;AACEE,EAAAA,WAAW,CAAEC,KAAF,EAASC,MAAT,EAAiB;AAC1B,UAAMD,KAAN,EAAa;AACXE,MAAAA,OAAO,CAAEC,GAAF,EAAO;AACZ,eAAOF,MAAM,CAACD,KAAP,CAAaG,GAAb,CAAP;AACD,OAHU;;AAIXC,MAAAA,MAAM,CAAED,GAAF,EAAO;AACX,YAAIF,MAAM,CAACI,QAAP,OAAsB,GAA1B,EAA+B;AAC7B,iBAAOF,GAAP;AACD;;AAED,YAAI,CAACF,MAAM,CAACK,YAAP,CAAoBH,GAApB,CAAL,EAA+B;AAC7B,gBAAM,IAAII,KAAJ,CAAW,qBAAoBN,MAAM,CAACI,QAAP,EAAkB,aAAYF,GAAG,CAACE,QAAJ,EAAe,EAA5E,CAAN;AACD;;AAED,eAAO,IAAIV,GAAJ,CAAQQ,GAAG,CAACE,QAAJ,GAAeG,KAAf,CAAqBP,MAAM,CAACI,QAAP,GAAkBI,MAAvC,CAAR,EAAwD,KAAxD,CAAP;AACD;;AAdU,KAAb;AAiBA,SAAKR,MAAL,GAAcA,MAAd;AACD;AAED;AACF;AACA;AACA;;;AACES,EAAAA,KAAK,CAAEC,CAAF,EAAKC,OAAL,EAAc;AACjB,QAAID,CAAC,CAACV,MAAF,IAAY,KAAKA,MAAL,CAAYI,QAAZ,OAA2B,GAA3C,EAAgD;AAC9C,aAAO,MAAMK,KAAN,CAAYG,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBH,CAAlB,EAAqB;AACtCV,QAAAA,MAAM,EAAE,KAAKA,MAAL,CAAYD,KAAZ,CAAkB,IAAIL,GAAJ,CAAQgB,CAAC,CAACV,MAAV,CAAlB,EAAqCI,QAArC;AAD8B,OAArB,CAAZ,CAAP;AAGD;;AACD,WAAO,MAAMK,KAAN,CAAYC,CAAZ,EAAeC,OAAf,CAAP;AACD;AAED;AACF;AACA;AACA;;;AACEG,EAAAA,SAAS,CAAEJ,CAAF,EAAKC,OAAL,EAAc;AACrB,QAAID,CAAC,CAACV,MAAF,IAAY,KAAKA,MAAL,CAAYI,QAAZ,OAA2B,GAA3C,EAAgD;AAC9C,aAAO,MAAMU,SAAN,CAAgBF,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBH,CAAlB,EAAqB;AAC1CV,QAAAA,MAAM,EAAE,KAAKA,MAAL,CAAYD,KAAZ,CAAkB,IAAIL,GAAJ,CAAQgB,CAAC,CAACV,MAAV,CAAlB,EAAqCI,QAArC;AADkC,OAArB,CAAhB,CAAP;AAGD;;AACD,WAAO,MAAMU,SAAN,CAAgBJ,CAAhB,EAAmBC,OAAnB,CAAP;AACD;;AAlDoD;;AAqDvDI,MAAM,CAACC,OAAP,GAAiBnB,kBAAjB","sourcesContent":["'use strict'\n\nconst Key = require('interface-datastore').Key\nconst KeytransformDatastore = require('./keytransform')\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').KeyQuery} KeyQuery\n * @typedef {import('interface-datastore').Options} Options\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('./types').KeyTransform} KeyTransform\n */\n\n/**\n * Wraps a given datastore into a keytransform which\n * makes a given prefix transparent.\n *\n * For example, if the prefix is `new Key(/hello)` a call\n * to `store.put(new Key('/world'), mydata)` would store the data under\n * `/hello/world`.\n *\n */\nclass NamespaceDatastore extends KeytransformDatastore {\n  /**\n   * @param {Datastore} child\n   * @param {Key} prefix\n   */\n  constructor (child, prefix) {\n    super(child, {\n      convert (key) {\n        return prefix.child(key)\n      },\n      invert (key) {\n        if (prefix.toString() === '/') {\n          return key\n        }\n\n        if (!prefix.isAncestorOf(key)) {\n          throw new Error(`Expected prefix: (${prefix.toString()}) in key: ${key.toString()}`)\n        }\n\n        return new Key(key.toString().slice(prefix.toString().length), false)\n      }\n    })\n\n    this.prefix = prefix\n  }\n\n  /**\n   * @param {Query} q\n   * @param {Options} [options]\n   */\n  query (q, options) {\n    if (q.prefix && this.prefix.toString() !== '/') {\n      return super.query(Object.assign({}, q, {\n        prefix: this.prefix.child(new Key(q.prefix)).toString()\n      }))\n    }\n    return super.query(q, options)\n  }\n\n  /**\n   * @param {KeyQuery} q\n   * @param {Options} [options]\n   */\n  queryKeys (q, options) {\n    if (q.prefix && this.prefix.toString() !== '/') {\n      return super.queryKeys(Object.assign({}, q, {\n        prefix: this.prefix.child(new Key(q.prefix)).toString()\n      }))\n    }\n    return super.queryKeys(q, options)\n  }\n}\n\nmodule.exports = NamespaceDatastore\n"]},"metadata":{},"sourceType":"script"}