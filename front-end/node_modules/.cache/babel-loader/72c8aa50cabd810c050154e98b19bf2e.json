{"ast":null,"code":"'use strict';\n\nvar dir = require('./dir.js');\n\nvar index = require('./file/index.js');\n\nvar errCode = require('err-code');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nfunction _interopNamespaceDefaultOnly(e) {\n  return Object.freeze({\n    __proto__: null,\n    'default': e\n  });\n}\n\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\n\nfunction isIterable(thing) {\n  return Symbol.iterator in thing;\n}\n\nfunction isAsyncIterable(thing) {\n  return Symbol.asyncIterator in thing;\n}\n\nfunction contentAsAsyncIterable(content) {\n  try {\n    if (content instanceof Uint8Array) {\n      return async function* () {\n        yield content;\n      }();\n    } else if (isIterable(content)) {\n      return async function* () {\n        yield* content;\n      }();\n    } else if (isAsyncIterable(content)) {\n      return content;\n    }\n  } catch {\n    throw errCode__default['default'](new Error('Content was invalid'), 'ERR_INVALID_CONTENT');\n  }\n\n  throw errCode__default['default'](new Error('Content was invalid'), 'ERR_INVALID_CONTENT');\n}\n\nasync function* dagBuilder(source, blockstore, options) {\n  for await (const entry of source) {\n    if (entry.path) {\n      if (entry.path.substring(0, 2) === './') {\n        options.wrapWithDirectory = true;\n      }\n\n      entry.path = entry.path.split('/').filter(path => path && path !== '.').join('/');\n    }\n\n    if (entry.content) {\n      let chunker;\n\n      if (typeof options.chunker === 'function') {\n        chunker = options.chunker;\n      } else if (options.chunker === 'rabin') {\n        chunker = (await Promise.resolve().then(function () {\n          return /*#__PURE__*/_interopNamespaceDefaultOnly(require('../chunker/rabin.js'));\n        })).default;\n      } else {\n        chunker = (await Promise.resolve().then(function () {\n          return /*#__PURE__*/_interopNamespaceDefaultOnly(require('../chunker/fixed-size.js'));\n        })).default;\n      }\n\n      let chunkValidator;\n\n      if (typeof options.chunkValidator === 'function') {\n        chunkValidator = options.chunkValidator;\n      } else {\n        chunkValidator = (await Promise.resolve().then(function () {\n          return /*#__PURE__*/_interopNamespaceDefaultOnly(require('./validate-chunks.js'));\n        })).default;\n      }\n\n      const file = {\n        path: entry.path,\n        mtime: entry.mtime,\n        mode: entry.mode,\n        content: chunker(chunkValidator(contentAsAsyncIterable(entry.content), options), options)\n      };\n      yield () => index(file, blockstore, options);\n    } else if (entry.path) {\n      const dir$1 = {\n        path: entry.path,\n        mtime: entry.mtime,\n        mode: entry.mode\n      };\n      yield () => dir(dir$1, blockstore, options);\n    } else {\n      throw new Error('Import candidate must have content or path or both');\n    }\n  }\n}\n\nmodule.exports = dagBuilder;","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/ipfs-unixfs-importer/cjs/src/dag-builder/index.js"],"names":["dir","require","index","errCode","_interopDefaultLegacy","e","_interopNamespaceDefaultOnly","Object","freeze","__proto__","errCode__default","isIterable","thing","Symbol","iterator","isAsyncIterable","asyncIterator","contentAsAsyncIterable","content","Uint8Array","Error","dagBuilder","source","blockstore","options","entry","path","substring","wrapWithDirectory","split","filter","join","chunker","Promise","resolve","then","default","chunkValidator","file","mtime","mode","dir$1","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar dir = require('./dir.js');\nvar index = require('./file/index.js');\nvar errCode = require('err-code');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nfunction _interopNamespaceDefaultOnly(e) {\n  return Object.freeze({__proto__: null, 'default': e});\n}\n\nvar errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);\n\nfunction isIterable(thing) {\n  return Symbol.iterator in thing;\n}\nfunction isAsyncIterable(thing) {\n  return Symbol.asyncIterator in thing;\n}\nfunction contentAsAsyncIterable(content) {\n  try {\n    if (content instanceof Uint8Array) {\n      return async function* () {\n        yield content;\n      }();\n    } else if (isIterable(content)) {\n      return async function* () {\n        yield* content;\n      }();\n    } else if (isAsyncIterable(content)) {\n      return content;\n    }\n  } catch {\n    throw errCode__default['default'](new Error('Content was invalid'), 'ERR_INVALID_CONTENT');\n  }\n  throw errCode__default['default'](new Error('Content was invalid'), 'ERR_INVALID_CONTENT');\n}\nasync function* dagBuilder(source, blockstore, options) {\n  for await (const entry of source) {\n    if (entry.path) {\n      if (entry.path.substring(0, 2) === './') {\n        options.wrapWithDirectory = true;\n      }\n      entry.path = entry.path.split('/').filter(path => path && path !== '.').join('/');\n    }\n    if (entry.content) {\n      let chunker;\n      if (typeof options.chunker === 'function') {\n        chunker = options.chunker;\n      } else if (options.chunker === 'rabin') {\n        chunker = (await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespaceDefaultOnly(require('../chunker/rabin.js')); })).default;\n      } else {\n        chunker = (await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespaceDefaultOnly(require('../chunker/fixed-size.js')); })).default;\n      }\n      let chunkValidator;\n      if (typeof options.chunkValidator === 'function') {\n        chunkValidator = options.chunkValidator;\n      } else {\n        chunkValidator = (await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespaceDefaultOnly(require('./validate-chunks.js')); })).default;\n      }\n      const file = {\n        path: entry.path,\n        mtime: entry.mtime,\n        mode: entry.mode,\n        content: chunker(chunkValidator(contentAsAsyncIterable(entry.content), options), options)\n      };\n      yield () => index(file, blockstore, options);\n    } else if (entry.path) {\n      const dir$1 = {\n        path: entry.path,\n        mtime: entry.mtime,\n        mode: entry.mode\n      };\n      yield () => dir(dir$1, blockstore, options);\n    } else {\n      throw new Error('Import candidate must have content or path or both');\n    }\n  }\n}\n\nmodule.exports = dagBuilder;\n"]},"metadata":{},"sourceType":"script"}