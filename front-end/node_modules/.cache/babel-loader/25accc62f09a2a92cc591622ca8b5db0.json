{"ast":null,"code":"'use strict';\n\nconst {\n  encode,\n  prepare\n} = require('@ipld/dag-pb');\n\nconst {\n  UnixFS\n} = require('ipfs-unixfs');\n\nconst persist = require('./persist');\n\nconst {\n  createHAMT,\n  Bucket\n} = require('hamt-sharding');\n\nconst {\n  hamtHashCode,\n  hamtHashFn,\n  hamtBucketBits\n} = require('./hamt-constants');\n/**\n * @typedef {import('ipfs-unixfs-importer').ImporterOptions} ImporterOptions\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('ipfs-unixfs').Mtime} Mtime\n *\n * @typedef {object} ImportResult\n * @property {CID} cid\n * @property {import('@ipld/dag-pb').PBNode} node\n * @property {number} size\n *\n * @typedef {object} DirContents\n * @property {CID} [cid]\n * @property {number} [size]\n *\n * @typedef {object} DirOptions\n * @property {Mtime} [mtime]\n * @property {number} [mode]\n * @property {import('multiformats/codecs/interface').BlockCodec<any, any>} [codec]\n * @property {import('multiformats/cid').CIDVersion} [cidVersion]\n * @property {boolean} [onlyHash]\n * @property {AbortSignal} [signal]\n */\n\n/**\n * @typedef {object} DirProps\n * @property {boolean} root\n * @property {boolean} dir\n * @property {string} path\n * @property {boolean} dirty\n * @property {boolean} flat\n * @property {Dir} [parent]\n * @property {string} [parentKey]\n * @property {import('ipfs-unixfs').UnixFS} [unixfs]\n * @property {number} [mode]\n * @property {import('ipfs-unixfs').Mtime} [mtime]\n */\n\n\nclass Dir {\n  /**\n   * @param {DirProps} props\n   * @param {DirOptions} options\n   */\n  constructor(props, options) {\n    this.options = options || {};\n    this.root = props.root;\n    this.dir = props.dir;\n    this.path = props.path;\n    this.dirty = props.dirty;\n    this.flat = props.flat;\n    this.parent = props.parent;\n    this.parentKey = props.parentKey;\n    this.unixfs = props.unixfs;\n    this.mode = props.mode;\n    this.mtime = props.mtime;\n    /** @type {CID | undefined} */\n\n    this.cid = undefined;\n    /** @type {number | undefined} */\n\n    this.size = undefined;\n  }\n  /**\n   * @param {string} name\n   * @param {DirContents} value\n   */\n\n\n  async put(name, value) {}\n  /**\n   * @param {string} name\n   * @returns {Promise<DirContents | undefined>}\n   */\n\n\n  get(name) {\n    return Promise.resolve(this);\n  }\n  /**\n   * @returns {AsyncIterable<{ key: string, child: DirContents}>}\n   */\n\n\n  async *eachChildSeries() {}\n  /**\n   * @param {Blockstore} blockstore\n   * @returns {AsyncIterable<ImportResult>}\n   */\n\n\n  async *flush(blockstore) {}\n\n}\n\nclass DirSharded extends Dir {\n  /**\n   * @param {DirProps} props\n   * @param {DirOptions} options\n   */\n  constructor(props, options) {\n    super(props, options);\n    /** @type {Bucket<DirContents>} */\n\n    this._bucket = createHAMT({\n      hashFn: hamtHashFn,\n      bits: hamtBucketBits\n    });\n  }\n  /**\n   * @param {string} name\n   * @param {DirContents} value\n   */\n\n\n  async put(name, value) {\n    await this._bucket.put(name, value);\n  }\n  /**\n   * @param {string} name\n   */\n\n\n  get(name) {\n    return this._bucket.get(name);\n  }\n\n  childCount() {\n    return this._bucket.leafCount();\n  }\n\n  directChildrenCount() {\n    return this._bucket.childrenCount();\n  }\n\n  onlyChild() {\n    return this._bucket.onlyChild();\n  }\n\n  async *eachChildSeries() {\n    for await (const {\n      key,\n      value\n    } of this._bucket.eachLeafSeries()) {\n      yield {\n        key,\n        child: value\n      };\n    }\n  }\n  /**\n   * @param {Blockstore} blockstore\n   * @returns {AsyncIterable<ImportResult>}\n   */\n\n\n  async *flush(blockstore) {\n    yield* flush(this._bucket, blockstore, this, this.options);\n  }\n\n}\n\nmodule.exports = DirSharded;\n/**\n * @param {Bucket<?>} bucket\n * @param {Blockstore} blockstore\n * @param {*} shardRoot\n * @param {DirOptions} options\n * @returns {AsyncIterable<ImportResult>}\n */\n\nasync function* flush(bucket, blockstore, shardRoot, options) {\n  const children = bucket._children;\n  const links = [];\n  let childrenSize = 0;\n\n  for (let i = 0; i < children.length; i++) {\n    const child = children.get(i);\n\n    if (!child) {\n      continue;\n    }\n\n    const labelPrefix = i.toString(16).toUpperCase().padStart(2, '0');\n\n    if (child instanceof Bucket) {\n      let shard;\n\n      for await (const subShard of await flush(child, blockstore, null, options)) {\n        shard = subShard;\n      }\n\n      if (!shard) {\n        throw new Error('Could not flush sharded directory, no subshard found');\n      }\n\n      links.push({\n        Name: labelPrefix,\n        Tsize: shard.size,\n        Hash: shard.cid\n      });\n      childrenSize += shard.size;\n    } else if (typeof child.value.flush === 'function') {\n      const dir = child.value;\n      let flushedDir;\n\n      for await (const entry of dir.flush(blockstore)) {\n        flushedDir = entry;\n        yield flushedDir;\n      }\n\n      const label = labelPrefix + child.key;\n      links.push({\n        Name: label,\n        Tsize: flushedDir.size,\n        Hash: flushedDir.cid\n      });\n      childrenSize += flushedDir.size;\n    } else {\n      const value = child.value;\n\n      if (!value.cid) {\n        continue;\n      }\n\n      const label = labelPrefix + child.key;\n      const size = value.size;\n      links.push({\n        Name: label,\n        Tsize: size,\n        Hash: value.cid\n      });\n      childrenSize += size;\n    }\n  } // go-ipfs uses little endian, that's why we have to\n  // reverse the bit field before storing it\n\n\n  const data = Uint8Array.from(children.bitField().reverse());\n  const dir = new UnixFS({\n    type: 'hamt-sharded-directory',\n    data,\n    fanout: bucket.tableSize(),\n    hashType: hamtHashCode,\n    mtime: shardRoot && shardRoot.mtime,\n    mode: shardRoot && shardRoot.mode\n  });\n  const node = {\n    Data: dir.marshal(),\n    Links: links\n  };\n  const buffer = encode(prepare(node));\n  const cid = await persist(buffer, blockstore, options);\n  const size = buffer.length + childrenSize;\n  yield {\n    cid,\n    node,\n    size\n  };\n}","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/ipfs-core/src/components/files/utils/dir-sharded.js"],"names":["encode","prepare","require","UnixFS","persist","createHAMT","Bucket","hamtHashCode","hamtHashFn","hamtBucketBits","Dir","constructor","props","options","root","dir","path","dirty","flat","parent","parentKey","unixfs","mode","mtime","cid","undefined","size","put","name","value","get","Promise","resolve","eachChildSeries","flush","blockstore","DirSharded","_bucket","hashFn","bits","childCount","leafCount","directChildrenCount","childrenCount","onlyChild","key","eachLeafSeries","child","module","exports","bucket","shardRoot","children","_children","links","childrenSize","i","length","labelPrefix","toString","toUpperCase","padStart","shard","subShard","Error","push","Name","Tsize","Hash","flushedDir","entry","label","data","Uint8Array","from","bitField","reverse","type","fanout","tableSize","hashType","node","Data","marshal","Links","buffer"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { encode, prepare } = require('@ipld/dag-pb')\nconst { UnixFS } = require('ipfs-unixfs')\nconst persist = require('./persist')\nconst { createHAMT, Bucket } = require('hamt-sharding')\nconst {\n  hamtHashCode,\n  hamtHashFn,\n  hamtBucketBits\n} = require('./hamt-constants')\n\n/**\n * @typedef {import('ipfs-unixfs-importer').ImporterOptions} ImporterOptions\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('ipfs-unixfs').Mtime} Mtime\n *\n * @typedef {object} ImportResult\n * @property {CID} cid\n * @property {import('@ipld/dag-pb').PBNode} node\n * @property {number} size\n *\n * @typedef {object} DirContents\n * @property {CID} [cid]\n * @property {number} [size]\n *\n * @typedef {object} DirOptions\n * @property {Mtime} [mtime]\n * @property {number} [mode]\n * @property {import('multiformats/codecs/interface').BlockCodec<any, any>} [codec]\n * @property {import('multiformats/cid').CIDVersion} [cidVersion]\n * @property {boolean} [onlyHash]\n * @property {AbortSignal} [signal]\n */\n\n/**\n * @typedef {object} DirProps\n * @property {boolean} root\n * @property {boolean} dir\n * @property {string} path\n * @property {boolean} dirty\n * @property {boolean} flat\n * @property {Dir} [parent]\n * @property {string} [parentKey]\n * @property {import('ipfs-unixfs').UnixFS} [unixfs]\n * @property {number} [mode]\n * @property {import('ipfs-unixfs').Mtime} [mtime]\n */\nclass Dir {\n  /**\n   * @param {DirProps} props\n   * @param {DirOptions} options\n   */\n  constructor (props, options) {\n    this.options = options || {}\n    this.root = props.root\n    this.dir = props.dir\n    this.path = props.path\n    this.dirty = props.dirty\n    this.flat = props.flat\n    this.parent = props.parent\n    this.parentKey = props.parentKey\n    this.unixfs = props.unixfs\n    this.mode = props.mode\n    this.mtime = props.mtime\n    /** @type {CID | undefined} */\n    this.cid = undefined\n    /** @type {number | undefined} */\n    this.size = undefined\n  }\n\n  /**\n   * @param {string} name\n   * @param {DirContents} value\n   */\n  async put (name, value) { }\n  /**\n   * @param {string} name\n   * @returns {Promise<DirContents | undefined>}\n   */\n  get (name) {\n    return Promise.resolve(this)\n  }\n\n  /**\n   * @returns {AsyncIterable<{ key: string, child: DirContents}>}\n   */\n  async * eachChildSeries () { }\n  /**\n   * @param {Blockstore} blockstore\n   * @returns {AsyncIterable<ImportResult>}\n   */\n  async * flush (blockstore) { }\n}\n\nclass DirSharded extends Dir {\n  /**\n   * @param {DirProps} props\n   * @param {DirOptions} options\n   */\n  constructor (props, options) {\n    super(props, options)\n\n    /** @type {Bucket<DirContents>} */\n    this._bucket = createHAMT({\n      hashFn: hamtHashFn,\n      bits: hamtBucketBits\n    })\n  }\n\n  /**\n   * @param {string} name\n   * @param {DirContents} value\n   */\n  async put (name, value) {\n    await this._bucket.put(name, value)\n  }\n\n  /**\n   * @param {string} name\n   */\n  get (name) {\n    return this._bucket.get(name)\n  }\n\n  childCount () {\n    return this._bucket.leafCount()\n  }\n\n  directChildrenCount () {\n    return this._bucket.childrenCount()\n  }\n\n  onlyChild () {\n    return this._bucket.onlyChild()\n  }\n\n  async * eachChildSeries () {\n    for await (const { key, value } of this._bucket.eachLeafSeries()) {\n      yield {\n        key,\n        child: value\n      }\n    }\n  }\n\n  /**\n   * @param {Blockstore} blockstore\n   * @returns {AsyncIterable<ImportResult>}\n   */\n  async * flush (blockstore) {\n    yield * flush(this._bucket, blockstore, this, this.options)\n  }\n}\n\nmodule.exports = DirSharded\n\n/**\n * @param {Bucket<?>} bucket\n * @param {Blockstore} blockstore\n * @param {*} shardRoot\n * @param {DirOptions} options\n * @returns {AsyncIterable<ImportResult>}\n */\nasync function * flush (bucket, blockstore, shardRoot, options) {\n  const children = bucket._children\n  const links = []\n  let childrenSize = 0\n\n  for (let i = 0; i < children.length; i++) {\n    const child = children.get(i)\n\n    if (!child) {\n      continue\n    }\n\n    const labelPrefix = i.toString(16).toUpperCase().padStart(2, '0')\n\n    if (child instanceof Bucket) {\n      let shard\n\n      for await (const subShard of await flush(child, blockstore, null, options)) {\n        shard = subShard\n      }\n\n      if (!shard) {\n        throw new Error('Could not flush sharded directory, no subshard found')\n      }\n\n      links.push({\n        Name: labelPrefix,\n        Tsize: shard.size,\n        Hash: shard.cid\n      })\n      childrenSize += shard.size\n    } else if (typeof child.value.flush === 'function') {\n      const dir = child.value\n      let flushedDir\n\n      for await (const entry of dir.flush(blockstore)) {\n        flushedDir = entry\n\n        yield flushedDir\n      }\n\n      const label = labelPrefix + child.key\n      links.push({\n        Name: label,\n        Tsize: flushedDir.size,\n        Hash: flushedDir.cid\n      })\n\n      childrenSize += flushedDir.size\n    } else {\n      const value = child.value\n\n      if (!value.cid) {\n        continue\n      }\n\n      const label = labelPrefix + child.key\n      const size = value.size\n\n      links.push({\n        Name: label,\n        Tsize: size,\n        Hash: value.cid\n      })\n      childrenSize += size\n    }\n  }\n\n  // go-ipfs uses little endian, that's why we have to\n  // reverse the bit field before storing it\n  const data = Uint8Array.from(children.bitField().reverse())\n  const dir = new UnixFS({\n    type: 'hamt-sharded-directory',\n    data,\n    fanout: bucket.tableSize(),\n    hashType: hamtHashCode,\n    mtime: shardRoot && shardRoot.mtime,\n    mode: shardRoot && shardRoot.mode\n  })\n\n  const node = {\n    Data: dir.marshal(),\n    Links: links\n  }\n  const buffer = encode(prepare(node))\n  const cid = await persist(buffer, blockstore, options)\n  const size = buffer.length + childrenSize\n\n  yield {\n    cid,\n    node,\n    size\n  }\n}\n"]},"metadata":{},"sourceType":"script"}