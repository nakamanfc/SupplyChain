{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer'); // @ts-ignore\n\n\nconst BufferList = require('bl/BufferList');\n\nconst varintDecode = require('./varint-decode'); // Maximum length of the length section of the message\n\n\nconst MAX_LENGTH_LENGTH = 8; // Varint.encode(Number.MAX_SAFE_INTEGER).length\n// Maximum length of the data section of the message\n\nconst MAX_DATA_LENGTH = 1024 * 1024 * 4;\nconst Empty = Buffer.alloc(0);\nconst ReadModes = {\n  LENGTH: 'readLength',\n  DATA: 'readData'\n};\nconst ReadHandlers = {\n  /**\n   * @param {BufferList} chunk\n   * @param {BufferList} buffer\n   * @param {import('./types').ReadState | undefined} state\n   * @param {import('./types').DecoderOptions} options\n   * @returns {import('./types').ReadResult}\n   */\n  [ReadModes.LENGTH]: (chunk, buffer, state, options) => {\n    // console.log(ReadModes.LENGTH, chunk.length)\n    buffer = buffer.append(chunk);\n    let dataLength;\n\n    try {\n      dataLength = options.lengthDecoder(buffer);\n    } catch (err) {\n      if (buffer.length > options.maxLengthLength) {\n        throw Object.assign(err, {\n          message: 'message length too long',\n          code: 'ERR_MSG_LENGTH_TOO_LONG'\n        });\n      }\n\n      if (err instanceof RangeError) {\n        return {\n          mode: ReadModes.LENGTH,\n          buffer,\n          chunk: undefined,\n          state: undefined,\n          data: undefined\n        };\n      }\n\n      throw err;\n    }\n\n    if (dataLength > options.maxDataLength) {\n      throw Object.assign(new Error('message data too long'), {\n        code: 'ERR_MSG_DATA_TOO_LONG'\n      });\n    }\n\n    chunk = buffer.shallowSlice(options.lengthDecoder.bytes);\n    buffer = new BufferList();\n    if (options.onLength) options.onLength(dataLength);\n\n    if (dataLength <= 0) {\n      if (options.onData) options.onData(Empty);\n      return {\n        mode: ReadModes.LENGTH,\n        chunk,\n        buffer,\n        data: Empty\n      };\n    }\n\n    return {\n      mode: ReadModes.DATA,\n      chunk,\n      buffer,\n      state: {\n        dataLength\n      },\n      data: undefined\n    };\n  },\n\n  /**\n   * @param {BufferList} chunk\n   * @param {BufferList} buffer\n   * @param {import('./types').ReadState | undefined} state\n   * @param {import('./types').DecoderOptions} options\n   * @returns {import('./types').ReadResult}\n   */\n  [ReadModes.DATA]: (chunk, buffer, state, options) => {\n    // console.log(ReadModes.DATA, chunk.length)\n    buffer = buffer.append(chunk);\n\n    if (!state) {\n      throw new Error('state is required');\n    }\n\n    if (buffer.length < state.dataLength) {\n      return {\n        mode: ReadModes.DATA,\n        buffer,\n        state,\n        chunk: undefined,\n        data: undefined\n      };\n    }\n\n    const {\n      dataLength\n    } = state;\n    const data = buffer.shallowSlice(0, dataLength);\n    const nextChunk = buffer.length > dataLength ? buffer.shallowSlice(dataLength) : undefined;\n    buffer = new BufferList();\n    if (options.onData) options.onData(data);\n    return {\n      mode: ReadModes.LENGTH,\n      chunk: nextChunk,\n      buffer,\n      state: undefined,\n      data\n    };\n  }\n};\n/**\n * @param {any} [options]\n */\n\nfunction decode(options) {\n  options = options || {};\n  /**\n   * @type {import('./types').DecoderOptions}\n   */\n\n  const opts = {\n    lengthDecoder: options.lengthDecoder || varintDecode,\n    maxLengthLength: options.maxLengthLength || MAX_LENGTH_LENGTH,\n    maxDataLength: options.maxDataLength || MAX_DATA_LENGTH,\n    onLength: options.onLength,\n    onData: options.onData\n  };\n  /**\n   * @param {AsyncIterable<BufferList>} source\n   */\n\n  const decoder = async function* (source) {\n    let buffer = new BufferList();\n    let mode = ReadModes.LENGTH; // current parsing mode\n\n    let state; // accumulated state for the current mode\n\n    for await (const chunk of source) {\n      /** @type {BufferList | undefined} */\n      let nextChunk = chunk; // Each chunk may contain multiple messages - keep calling handler for the\n      // current parsing mode until all handlers have consumed the chunk.\n\n      while (nextChunk) {\n        const result = ReadHandlers[mode](nextChunk, buffer, state, opts);\n        mode = result.mode;\n        nextChunk = result.chunk;\n        buffer = result.buffer;\n        state = result.state;\n\n        if (result.data) {\n          yield result.data;\n        }\n      }\n    }\n\n    if (buffer.length) {\n      throw Object.assign(new Error('unexpected end of input'), {\n        code: 'ERR_UNEXPECTED_EOF'\n      });\n    }\n  };\n\n  return decoder;\n}\n/**\n * @param {*} reader\n * @param {import('./types').DecoderOptions} [options]\n * @returns\n */\n\n\ndecode.fromReader = (reader, options) => {\n  let byteLength = 1; // Read single byte chunks until the length is known\n\n  const varByteSource = {\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n\n    next: async () => {\n      try {\n        return await reader.next(byteLength);\n      } catch (err) {\n        if (err.code === 'ERR_UNDER_READ') {\n          return {\n            done: true,\n            value: null\n          };\n        }\n\n        throw err;\n      } finally {\n        // Reset the byteLength so we continue to check for varints\n        byteLength = 1;\n      }\n    }\n  };\n  /**\n   * Once the length has been parsed, read chunk for that length\n   *\n   * @param {number} l\n   */\n\n  const onLength = l => {\n    byteLength = l;\n  };\n\n  return decode({ ...(options || {}),\n    onLength\n  })(varByteSource);\n};\n\nmodule.exports = decode;\nmodule.exports.MAX_LENGTH_LENGTH = MAX_LENGTH_LENGTH;\nmodule.exports.MAX_DATA_LENGTH = MAX_DATA_LENGTH;","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/it-length-prefixed/src/decode.js"],"names":["Buffer","require","BufferList","varintDecode","MAX_LENGTH_LENGTH","MAX_DATA_LENGTH","Empty","alloc","ReadModes","LENGTH","DATA","ReadHandlers","chunk","buffer","state","options","append","dataLength","lengthDecoder","err","length","maxLengthLength","Object","assign","message","code","RangeError","mode","undefined","data","maxDataLength","Error","shallowSlice","bytes","onLength","onData","nextChunk","decode","opts","decoder","source","result","fromReader","reader","byteLength","varByteSource","Symbol","asyncIterator","next","done","value","l","module","exports"],"mappings":"AAAA;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAaC,OAAO,CAAC,QAAD,CAA1B,C,CACA;;;AACA,MAAMC,UAAU,GAAGD,OAAO,CAAC,eAAD,CAA1B;;AACA,MAAME,YAAY,GAAGF,OAAO,CAAC,iBAAD,CAA5B,C,CAEA;;;AACA,MAAMG,iBAAiB,GAAG,CAA1B,C,CAA4B;AAC5B;;AACA,MAAMC,eAAe,GAAG,OAAO,IAAP,GAAc,CAAtC;AAEA,MAAMC,KAAK,GAAGN,MAAM,CAACO,KAAP,CAAa,CAAb,CAAd;AACA,MAAMC,SAAS,GAAG;AAAEC,EAAAA,MAAM,EAAE,YAAV;AAAwBC,EAAAA,IAAI,EAAE;AAA9B,CAAlB;AAEA,MAAMC,YAAY,GAAG;AACnB;AACF;AACA;AACA;AACA;AACA;AACA;AACE,GAACH,SAAS,CAACC,MAAX,GAAoB,CAACG,KAAD,EAAQC,MAAR,EAAgBC,KAAhB,EAAuBC,OAAvB,KAAmC;AACrD;AACAF,IAAAA,MAAM,GAAGA,MAAM,CAACG,MAAP,CAAcJ,KAAd,CAAT;AAEA,QAAIK,UAAJ;;AACA,QAAI;AACFA,MAAAA,UAAU,GAAGF,OAAO,CAACG,aAAR,CAAsBL,MAAtB,CAAb;AACD,KAFD,CAEE,OAAOM,GAAP,EAAY;AACZ,UAAIN,MAAM,CAACO,MAAP,GAAgBL,OAAO,CAACM,eAA5B,EAA6C;AAC3C,cAAMC,MAAM,CAACC,MAAP,CAAcJ,GAAd,EAAmB;AAAEK,UAAAA,OAAO,EAAE,yBAAX;AAAsCC,UAAAA,IAAI,EAAE;AAA5C,SAAnB,CAAN;AACD;;AACD,UAAIN,GAAG,YAAYO,UAAnB,EAA+B;AAC7B,eAAO;AAAEC,UAAAA,IAAI,EAAEnB,SAAS,CAACC,MAAlB;AAA0BI,UAAAA,MAA1B;AAAkCD,UAAAA,KAAK,EAAEgB,SAAzC;AAAoDd,UAAAA,KAAK,EAAEc,SAA3D;AAAsEC,UAAAA,IAAI,EAAED;AAA5E,SAAP;AACD;;AACD,YAAMT,GAAN;AACD;;AAED,QAAIF,UAAU,GAAGF,OAAO,CAACe,aAAzB,EAAwC;AACtC,YAAMR,MAAM,CAACC,MAAP,CAAc,IAAIQ,KAAJ,CAAU,uBAAV,CAAd,EAAkD;AAAEN,QAAAA,IAAI,EAAE;AAAR,OAAlD,CAAN;AACD;;AAEDb,IAAAA,KAAK,GAAGC,MAAM,CAACmB,YAAP,CAAoBjB,OAAO,CAACG,aAAR,CAAsBe,KAA1C,CAAR;AACApB,IAAAA,MAAM,GAAG,IAAIX,UAAJ,EAAT;AAEA,QAAIa,OAAO,CAACmB,QAAZ,EAAsBnB,OAAO,CAACmB,QAAR,CAAiBjB,UAAjB;;AAEtB,QAAIA,UAAU,IAAI,CAAlB,EAAqB;AACnB,UAAIF,OAAO,CAACoB,MAAZ,EAAoBpB,OAAO,CAACoB,MAAR,CAAe7B,KAAf;AACpB,aAAO;AAAEqB,QAAAA,IAAI,EAAEnB,SAAS,CAACC,MAAlB;AAA0BG,QAAAA,KAA1B;AAAiCC,QAAAA,MAAjC;AAAyCgB,QAAAA,IAAI,EAAEvB;AAA/C,OAAP;AACD;;AAED,WAAO;AAAEqB,MAAAA,IAAI,EAAEnB,SAAS,CAACE,IAAlB;AAAwBE,MAAAA,KAAxB;AAA+BC,MAAAA,MAA/B;AAAuCC,MAAAA,KAAK,EAAE;AAAEG,QAAAA;AAAF,OAA9C;AAA8DY,MAAAA,IAAI,EAAED;AAApE,KAAP;AACD,GAxCkB;;AA0CnB;AACF;AACA;AACA;AACA;AACA;AACA;AACE,GAACpB,SAAS,CAACE,IAAX,GAAkB,CAACE,KAAD,EAAQC,MAAR,EAAgBC,KAAhB,EAAuBC,OAAvB,KAAmC;AACnD;AACAF,IAAAA,MAAM,GAAGA,MAAM,CAACG,MAAP,CAAcJ,KAAd,CAAT;;AAEA,QAAI,CAACE,KAAL,EAAY;AACV,YAAM,IAAIiB,KAAJ,CAAU,mBAAV,CAAN;AACD;;AAED,QAAIlB,MAAM,CAACO,MAAP,GAAgBN,KAAK,CAACG,UAA1B,EAAsC;AACpC,aAAO;AAAEU,QAAAA,IAAI,EAAEnB,SAAS,CAACE,IAAlB;AAAwBG,QAAAA,MAAxB;AAAgCC,QAAAA,KAAhC;AAAuCF,QAAAA,KAAK,EAAEgB,SAA9C;AAAyDC,QAAAA,IAAI,EAAED;AAA/D,OAAP;AACD;;AAED,UAAM;AAAEX,MAAAA;AAAF,QAAiBH,KAAvB;AACA,UAAMe,IAAI,GAAGhB,MAAM,CAACmB,YAAP,CAAoB,CAApB,EAAuBf,UAAvB,CAAb;AAEA,UAAMmB,SAAS,GAAGvB,MAAM,CAACO,MAAP,GAAgBH,UAAhB,GAA6BJ,MAAM,CAACmB,YAAP,CAAoBf,UAApB,CAA7B,GAA+DW,SAAjF;AACAf,IAAAA,MAAM,GAAG,IAAIX,UAAJ,EAAT;AAEA,QAAIa,OAAO,CAACoB,MAAZ,EAAoBpB,OAAO,CAACoB,MAAR,CAAeN,IAAf;AACpB,WAAO;AAAEF,MAAAA,IAAI,EAAEnB,SAAS,CAACC,MAAlB;AAA0BG,MAAAA,KAAK,EAAEwB,SAAjC;AAA4CvB,MAAAA,MAA5C;AAAoDC,MAAAA,KAAK,EAAEc,SAA3D;AAAsEC,MAAAA;AAAtE,KAAP;AACD;AArEkB,CAArB;AAwEA;AACA;AACA;;AACA,SAASQ,MAAT,CAAiBtB,OAAjB,EAA0B;AACxBA,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AAEA;AACF;AACA;;AACE,QAAMuB,IAAI,GAAG;AACXpB,IAAAA,aAAa,EAAEH,OAAO,CAACG,aAAR,IAAyBf,YAD7B;AAEXkB,IAAAA,eAAe,EAAEN,OAAO,CAACM,eAAR,IAA2BjB,iBAFjC;AAGX0B,IAAAA,aAAa,EAAEf,OAAO,CAACe,aAAR,IAAyBzB,eAH7B;AAIX6B,IAAAA,QAAQ,EAAEnB,OAAO,CAACmB,QAJP;AAKXC,IAAAA,MAAM,EAAEpB,OAAO,CAACoB;AALL,GAAb;AAQA;AACF;AACA;;AACE,QAAMI,OAAO,GAAG,iBAAkBC,MAAlB,EAA0B;AACxC,QAAI3B,MAAM,GAAG,IAAIX,UAAJ,EAAb;AACA,QAAIyB,IAAI,GAAGnB,SAAS,CAACC,MAArB,CAFwC,CAEZ;;AAC5B,QAAIK,KAAJ,CAHwC,CAG9B;;AAEV,eAAW,MAAMF,KAAjB,IAA0B4B,MAA1B,EAAkC;AAChC;AACA,UAAIJ,SAAS,GAAGxB,KAAhB,CAFgC,CAIhC;AACA;;AACA,aAAOwB,SAAP,EAAkB;AAChB,cAAMK,MAAM,GAAG9B,YAAY,CAACgB,IAAD,CAAZ,CAAmBS,SAAnB,EAA8BvB,MAA9B,EAAsCC,KAAtC,EAA6CwB,IAA7C,CAAf;AAEAX,QAAAA,IAAI,GAAGc,MAAM,CAACd,IAAd;AACAS,QAAAA,SAAS,GAAGK,MAAM,CAAC7B,KAAnB;AACAC,QAAAA,MAAM,GAAG4B,MAAM,CAAC5B,MAAhB;AACAC,QAAAA,KAAK,GAAG2B,MAAM,CAAC3B,KAAf;;AAEA,YAAI2B,MAAM,CAACZ,IAAX,EAAiB;AACf,gBAAMY,MAAM,CAACZ,IAAb;AACD;AACF;AACF;;AAED,QAAIhB,MAAM,CAACO,MAAX,EAAmB;AACjB,YAAME,MAAM,CAACC,MAAP,CAAc,IAAIQ,KAAJ,CAAU,yBAAV,CAAd,EAAoD;AAAEN,QAAAA,IAAI,EAAE;AAAR,OAApD,CAAN;AACD;AACF,GA5BD;;AA8BA,SAAOc,OAAP;AACD;AAED;AACA;AACA;AACA;AACA;;;AACAF,MAAM,CAACK,UAAP,GAAoB,CAACC,MAAD,EAAS5B,OAAT,KAAqB;AACvC,MAAI6B,UAAU,GAAG,CAAjB,CADuC,CACpB;;AAEnB,QAAMC,aAAa,GAAG;AACpB,KAACC,MAAM,CAACC,aAAR,IAA0B;AAAE,aAAO,IAAP;AAAa,KADrB;;AAEpBC,IAAAA,IAAI,EAAE,YAAY;AAChB,UAAI;AACF,eAAO,MAAML,MAAM,CAACK,IAAP,CAAYJ,UAAZ,CAAb;AACD,OAFD,CAEE,OAAOzB,GAAP,EAAY;AACZ,YAAIA,GAAG,CAACM,IAAJ,KAAa,gBAAjB,EAAmC;AACjC,iBAAO;AAAEwB,YAAAA,IAAI,EAAE,IAAR;AAAcC,YAAAA,KAAK,EAAE;AAArB,WAAP;AACD;;AACD,cAAM/B,GAAN;AACD,OAPD,SAOU;AACR;AACAyB,QAAAA,UAAU,GAAG,CAAb;AACD;AACF;AAdmB,GAAtB;AAiBA;AACF;AACA;AACA;AACA;;AACE,QAAMV,QAAQ,GAAGiB,CAAC,IAAI;AAAEP,IAAAA,UAAU,GAAGO,CAAb;AAAgB,GAAxC;;AACA,SAAOd,MAAM,CAAC,EACZ,IAAItB,OAAO,IAAI,EAAf,CADY;AAEZmB,IAAAA;AAFY,GAAD,CAAN,CAGJW,aAHI,CAAP;AAID,CA9BD;;AAgCAO,MAAM,CAACC,OAAP,GAAiBhB,MAAjB;AACAe,MAAM,CAACC,OAAP,CAAejD,iBAAf,GAAmCA,iBAAnC;AACAgD,MAAM,CAACC,OAAP,CAAehD,eAAf,GAAiCA,eAAjC","sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\n// @ts-ignore\nconst BufferList = require('bl/BufferList')\nconst varintDecode = require('./varint-decode')\n\n// Maximum length of the length section of the message\nconst MAX_LENGTH_LENGTH = 8 // Varint.encode(Number.MAX_SAFE_INTEGER).length\n// Maximum length of the data section of the message\nconst MAX_DATA_LENGTH = 1024 * 1024 * 4\n\nconst Empty = Buffer.alloc(0)\nconst ReadModes = { LENGTH: 'readLength', DATA: 'readData' }\n\nconst ReadHandlers = {\n  /**\n   * @param {BufferList} chunk\n   * @param {BufferList} buffer\n   * @param {import('./types').ReadState | undefined} state\n   * @param {import('./types').DecoderOptions} options\n   * @returns {import('./types').ReadResult}\n   */\n  [ReadModes.LENGTH]: (chunk, buffer, state, options) => {\n    // console.log(ReadModes.LENGTH, chunk.length)\n    buffer = buffer.append(chunk)\n\n    let dataLength\n    try {\n      dataLength = options.lengthDecoder(buffer)\n    } catch (err) {\n      if (buffer.length > options.maxLengthLength) {\n        throw Object.assign(err, { message: 'message length too long', code: 'ERR_MSG_LENGTH_TOO_LONG' })\n      }\n      if (err instanceof RangeError) {\n        return { mode: ReadModes.LENGTH, buffer, chunk: undefined, state: undefined, data: undefined }\n      }\n      throw err\n    }\n\n    if (dataLength > options.maxDataLength) {\n      throw Object.assign(new Error('message data too long'), { code: 'ERR_MSG_DATA_TOO_LONG' })\n    }\n\n    chunk = buffer.shallowSlice(options.lengthDecoder.bytes)\n    buffer = new BufferList()\n\n    if (options.onLength) options.onLength(dataLength)\n\n    if (dataLength <= 0) {\n      if (options.onData) options.onData(Empty)\n      return { mode: ReadModes.LENGTH, chunk, buffer, data: Empty }\n    }\n\n    return { mode: ReadModes.DATA, chunk, buffer, state: { dataLength }, data: undefined }\n  },\n\n  /**\n   * @param {BufferList} chunk\n   * @param {BufferList} buffer\n   * @param {import('./types').ReadState | undefined} state\n   * @param {import('./types').DecoderOptions} options\n   * @returns {import('./types').ReadResult}\n   */\n  [ReadModes.DATA]: (chunk, buffer, state, options) => {\n    // console.log(ReadModes.DATA, chunk.length)\n    buffer = buffer.append(chunk)\n\n    if (!state) {\n      throw new Error('state is required')\n    }\n\n    if (buffer.length < state.dataLength) {\n      return { mode: ReadModes.DATA, buffer, state, chunk: undefined, data: undefined }\n    }\n\n    const { dataLength } = state\n    const data = buffer.shallowSlice(0, dataLength)\n\n    const nextChunk = buffer.length > dataLength ? buffer.shallowSlice(dataLength) : undefined\n    buffer = new BufferList()\n\n    if (options.onData) options.onData(data)\n    return { mode: ReadModes.LENGTH, chunk: nextChunk, buffer, state: undefined, data }\n  }\n}\n\n/**\n * @param {any} [options]\n */\nfunction decode (options) {\n  options = options || {}\n\n  /**\n   * @type {import('./types').DecoderOptions}\n   */\n  const opts = {\n    lengthDecoder: options.lengthDecoder || varintDecode,\n    maxLengthLength: options.maxLengthLength || MAX_LENGTH_LENGTH,\n    maxDataLength: options.maxDataLength || MAX_DATA_LENGTH,\n    onLength: options.onLength,\n    onData: options.onData\n  }\n\n  /**\n   * @param {AsyncIterable<BufferList>} source\n   */\n  const decoder = async function * (source) {\n    let buffer = new BufferList()\n    let mode = ReadModes.LENGTH // current parsing mode\n    let state // accumulated state for the current mode\n\n    for await (const chunk of source) {\n      /** @type {BufferList | undefined} */\n      let nextChunk = chunk\n\n      // Each chunk may contain multiple messages - keep calling handler for the\n      // current parsing mode until all handlers have consumed the chunk.\n      while (nextChunk) {\n        const result = ReadHandlers[mode](nextChunk, buffer, state, opts)\n\n        mode = result.mode\n        nextChunk = result.chunk\n        buffer = result.buffer\n        state = result.state\n\n        if (result.data) {\n          yield result.data\n        }\n      }\n    }\n\n    if (buffer.length) {\n      throw Object.assign(new Error('unexpected end of input'), { code: 'ERR_UNEXPECTED_EOF' })\n    }\n  }\n\n  return decoder\n}\n\n/**\n * @param {*} reader\n * @param {import('./types').DecoderOptions} [options]\n * @returns\n */\ndecode.fromReader = (reader, options) => {\n  let byteLength = 1 // Read single byte chunks until the length is known\n\n  const varByteSource = {\n    [Symbol.asyncIterator] () { return this },\n    next: async () => {\n      try {\n        return await reader.next(byteLength)\n      } catch (err) {\n        if (err.code === 'ERR_UNDER_READ') {\n          return { done: true, value: null }\n        }\n        throw err\n      } finally {\n        // Reset the byteLength so we continue to check for varints\n        byteLength = 1\n      }\n    }\n  }\n\n  /**\n   * Once the length has been parsed, read chunk for that length\n   *\n   * @param {number} l\n   */\n  const onLength = l => { byteLength = l }\n  return decode({\n    ...(options || {}),\n    onLength\n  })(varByteSource)\n}\n\nmodule.exports = decode\nmodule.exports.MAX_LENGTH_LENGTH = MAX_LENGTH_LENGTH\nmodule.exports.MAX_DATA_LENGTH = MAX_DATA_LENGTH\n"]},"metadata":{},"sourceType":"script"}