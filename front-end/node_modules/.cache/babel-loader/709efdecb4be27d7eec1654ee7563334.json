{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decryptStream = exports.encryptStream = void 0;\n\nconst buffer_1 = require(\"buffer\");\n\nconst constants_1 = require(\"./constants\"); // Returns generator that encrypts payload from the user\n\n\nfunction encryptStream(handshake) {\n  return async function* (source) {\n    for await (const chunk of source) {\n      const chunkBuffer = buffer_1.Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);\n\n      for (let i = 0; i < chunkBuffer.length; i += constants_1.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {\n        let end = i + constants_1.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;\n\n        if (end > chunkBuffer.length) {\n          end = chunkBuffer.length;\n        }\n\n        const data = handshake.encrypt(chunkBuffer.slice(i, end), handshake.session);\n        yield data;\n      }\n    }\n  };\n}\n\nexports.encryptStream = encryptStream; // Decrypt received payload to the user\n\nfunction decryptStream(handshake) {\n  return async function* (source) {\n    for await (const chunk of source) {\n      const chunkBuffer = buffer_1.Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);\n\n      for (let i = 0; i < chunkBuffer.length; i += constants_1.NOISE_MSG_MAX_LENGTH_BYTES) {\n        let end = i + constants_1.NOISE_MSG_MAX_LENGTH_BYTES;\n\n        if (end > chunkBuffer.length) {\n          end = chunkBuffer.length;\n        }\n\n        const chunk = chunkBuffer.slice(i, end);\n        const {\n          plaintext: decrypted,\n          valid\n        } = await handshake.decrypt(chunk, handshake.session);\n\n        if (!valid) {\n          throw new Error('Failed to validate decrypted chunk');\n        }\n\n        yield decrypted;\n      }\n    }\n  };\n}\n\nexports.decryptStream = decryptStream;","map":{"version":3,"sources":["../../src/crypto.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,QAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AAEA,MAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA,C,CAMA;;;AACA,SAAgB,aAAhB,CAA+B,SAA/B,EAAoD;AAClD,SAAO,iBAAkB,MAAlB,EAAwB;AAC7B,eAAW,MAAM,KAAjB,IAA0B,MAA1B,EAAkC;AAChC,YAAM,WAAW,GAAG,QAAA,CAAA,MAAA,CAAO,IAAP,CAAY,KAAK,CAAC,MAAlB,EAA0B,KAAK,CAAC,UAAhC,EAA4C,KAAK,CAAC,MAAlD,CAApB;;AAEA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,WAAW,CAAC,MAAhC,EAAwC,CAAC,IAAI,WAAA,CAAA,sCAA7C,EAAqF;AACnF,YAAI,GAAG,GAAG,CAAC,GAAG,WAAA,CAAA,sCAAd;;AACA,YAAI,GAAG,GAAG,WAAW,CAAC,MAAtB,EAA8B;AAC5B,UAAA,GAAG,GAAG,WAAW,CAAC,MAAlB;AACD;;AAED,cAAM,IAAI,GAAG,SAAS,CAAC,OAAV,CAAkB,WAAW,CAAC,KAAZ,CAAkB,CAAlB,EAAqB,GAArB,CAAlB,EAA6C,SAAS,CAAC,OAAvD,CAAb;AACA,cAAM,IAAN;AACD;AACF;AACF,GAdD;AAeD;;AAhBD,OAAA,CAAA,aAAA,GAAA,aAAA,C,CAkBA;;AACA,SAAgB,aAAhB,CAA+B,SAA/B,EAAoD;AAClD,SAAO,iBAAkB,MAAlB,EAAwB;AAC7B,eAAW,MAAM,KAAjB,IAA0B,MAA1B,EAAkC;AAChC,YAAM,WAAW,GAAG,QAAA,CAAA,MAAA,CAAO,IAAP,CAAY,KAAK,CAAC,MAAlB,EAA0B,KAAK,CAAC,UAAhC,EAA4C,KAAK,CAAC,MAAlD,CAApB;;AAEA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,WAAW,CAAC,MAAhC,EAAwC,CAAC,IAAI,WAAA,CAAA,0BAA7C,EAAyE;AACvE,YAAI,GAAG,GAAG,CAAC,GAAG,WAAA,CAAA,0BAAd;;AACA,YAAI,GAAG,GAAG,WAAW,CAAC,MAAtB,EAA8B;AAC5B,UAAA,GAAG,GAAG,WAAW,CAAC,MAAlB;AACD;;AAED,cAAM,KAAK,GAAG,WAAW,CAAC,KAAZ,CAAkB,CAAlB,EAAqB,GAArB,CAAd;AACA,cAAM;AAAE,UAAA,SAAS,EAAE,SAAb;AAAwB,UAAA;AAAxB,YAAkC,MAAM,SAAS,CAAC,OAAV,CAAkB,KAAlB,EAAyB,SAAS,CAAC,OAAnC,CAA9C;;AACA,YAAI,CAAC,KAAL,EAAY;AACV,gBAAM,IAAI,KAAJ,CAAU,oCAAV,CAAN;AACD;;AACD,cAAM,SAAN;AACD;AACF;AACF,GAlBD;AAmBD;;AApBD,OAAA,CAAA,aAAA,GAAA,aAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decryptStream = exports.encryptStream = void 0;\nconst buffer_1 = require(\"buffer\");\nconst constants_1 = require(\"./constants\");\n// Returns generator that encrypts payload from the user\nfunction encryptStream(handshake) {\n    return async function* (source) {\n        for await (const chunk of source) {\n            const chunkBuffer = buffer_1.Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);\n            for (let i = 0; i < chunkBuffer.length; i += constants_1.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {\n                let end = i + constants_1.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;\n                if (end > chunkBuffer.length) {\n                    end = chunkBuffer.length;\n                }\n                const data = handshake.encrypt(chunkBuffer.slice(i, end), handshake.session);\n                yield data;\n            }\n        }\n    };\n}\nexports.encryptStream = encryptStream;\n// Decrypt received payload to the user\nfunction decryptStream(handshake) {\n    return async function* (source) {\n        for await (const chunk of source) {\n            const chunkBuffer = buffer_1.Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);\n            for (let i = 0; i < chunkBuffer.length; i += constants_1.NOISE_MSG_MAX_LENGTH_BYTES) {\n                let end = i + constants_1.NOISE_MSG_MAX_LENGTH_BYTES;\n                if (end > chunkBuffer.length) {\n                    end = chunkBuffer.length;\n                }\n                const chunk = chunkBuffer.slice(i, end);\n                const { plaintext: decrypted, valid } = await handshake.decrypt(chunk, handshake.session);\n                if (!valid) {\n                    throw new Error('Failed to validate decrypted chunk');\n                }\n                yield decrypted;\n            }\n        }\n    };\n}\nexports.decryptStream = decryptStream;\n//# sourceMappingURL=crypto.js.map"]},"metadata":{},"sourceType":"script"}