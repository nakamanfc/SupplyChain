{"ast":null,"code":"const {\n  Buffer\n} = require('buffer');\n\nconst BufferList = require('bl/BufferList');\n\nconst ZERO_OFFSET = '0'.charCodeAt(0);\nconst USTAR_MAGIC = Buffer.from('ustar\\x00', 'binary');\nconst GNU_MAGIC = Buffer.from('ustar\\x20', 'binary');\nconst GNU_VER = Buffer.from('\\x20\\x00', 'binary');\nconst MAGIC_OFFSET = 257;\nconst VERSION_OFFSET = 263;\n\nconst clamp = function (index, len, defaultValue) {\n  if (typeof index !== 'number') return defaultValue;\n  index = ~~index; // Coerce to integer.\n\n  if (index >= len) return len;\n  if (index >= 0) return index;\n  index += len;\n  if (index >= 0) return index;\n  return 0;\n};\n\nconst toType = function (flag) {\n  switch (flag) {\n    case 0:\n      return 'file';\n\n    case 1:\n      return 'link';\n\n    case 2:\n      return 'symlink';\n\n    case 3:\n      return 'character-device';\n\n    case 4:\n      return 'block-device';\n\n    case 5:\n      return 'directory';\n\n    case 6:\n      return 'fifo';\n\n    case 7:\n      return 'contiguous-file';\n\n    case 72:\n      return 'pax-header';\n\n    case 55:\n      return 'pax-global-header';\n\n    case 27:\n      return 'gnu-long-link-path';\n\n    case 28:\n    case 30:\n      return 'gnu-long-path';\n  }\n\n  return null;\n};\n\nconst indexOf = function (block, num, offset, end) {\n  for (; offset < end; offset++) {\n    if (block.get(offset) === num) return offset;\n  }\n\n  return end;\n};\n\nconst cksum = function (block) {\n  let sum = 8 * 32;\n\n  for (let i = 0; i < 148; i++) sum += block.get(i);\n\n  for (let j = 156; j < 512; j++) sum += block.get(j);\n\n  return sum;\n};\n/* Copied from the node-tar repo and modified to meet\n * tar-stream coding standard.\n *\n * Source: https://github.com/npm/node-tar/blob/51b6627a1f357d2eb433e7378e5f05e83b7aa6cd/lib/header.js#L349\n */\n\n\nfunction parse256(buf) {\n  // first byte MUST be either 80 or FF\n  // 80 for positive, FF for 2's comp\n  let positive;\n  if (buf.get(0) === 0x80) positive = true;else if (buf.get(0) === 0xFF) positive = false;else return null; // build up a base-256 tuple from the least sig to the highest\n\n  let zero = false;\n  const tuple = [];\n\n  for (let i = buf.length - 1; i > 0; i--) {\n    const byte = buf.get(i);\n    if (positive) tuple.push(byte);else if (zero && byte === 0) tuple.push(0);else if (zero) {\n      zero = false;\n      tuple.push(0x100 - byte);\n    } else tuple.push(0xFF - byte);\n  }\n\n  let sum = 0;\n  const l = tuple.length;\n\n  for (let i = 0; i < l; i++) {\n    sum += tuple[i] * Math.pow(256, i);\n  }\n\n  return positive ? sum : -1 * sum;\n}\n\nconst decodeOct = function (val, offset, length) {\n  val = val.shallowSlice(offset, offset + length);\n  offset = 0; // If prefixed with 0x80 then parse as a base-256 integer\n\n  if (val.get(offset) & 0x80) {\n    return parse256(val);\n  } else {\n    // Older versions of tar can prefix with spaces\n    while (offset < val.length && val.get(offset) === 32) offset++;\n\n    const end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length);\n\n    while (offset < end && val.get(offset) === 0) offset++;\n\n    if (end === offset) return 0;\n    return parseInt(val.shallowSlice(offset, end).toString(), 8);\n  }\n};\n\nconst decodeStr = function (val, offset, length, encoding) {\n  return val.shallowSlice(offset, indexOf(val, 0, offset, offset + length)).toString(encoding);\n};\n\nexports.decodeLongPath = function (buf, encoding) {\n  buf = BufferList.isBufferList(buf) ? buf : new BufferList(buf);\n  return decodeStr(buf, 0, buf.length, encoding);\n};\n\nexports.decodePax = function (buf) {\n  buf = BufferList.isBufferList(buf) ? buf : new BufferList(buf);\n  const result = {};\n\n  while (buf.length) {\n    let i = 0;\n\n    while (i < buf.length && buf.get(i) !== 32) i++;\n\n    const len = parseInt(buf.shallowSlice(0, i).toString(), 10);\n    if (!len) return result;\n    const b = buf.shallowSlice(i + 1, len - 1).toString();\n    const keyIndex = b.indexOf('=');\n    if (keyIndex === -1) return result;\n    result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1);\n    buf = buf.shallowSlice(len);\n  }\n\n  return result;\n};\n\nexports.decode = function (buf, filenameEncoding) {\n  buf = BufferList.isBufferList(buf) ? buf : new BufferList(buf);\n  let typeflag = buf.get(156) === 0 ? 0 : buf.get(156) - ZERO_OFFSET;\n  let name = decodeStr(buf, 0, 100, filenameEncoding);\n  const mode = decodeOct(buf, 100, 8);\n  const uid = decodeOct(buf, 108, 8);\n  const gid = decodeOct(buf, 116, 8);\n  const size = decodeOct(buf, 124, 12);\n  const mtime = decodeOct(buf, 136, 12);\n  const type = toType(typeflag);\n  const linkname = buf.get(157) === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding);\n  const uname = decodeStr(buf, 265, 32);\n  const gname = decodeStr(buf, 297, 32);\n  const devmajor = decodeOct(buf, 329, 8);\n  const devminor = decodeOct(buf, 337, 8);\n  const c = cksum(buf); // checksum is still initial value if header was null.\n\n  if (c === 8 * 32) return null; // valid checksum\n\n  if (c !== decodeOct(buf, 148, 8)) throw new Error('Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?');\n\n  if (USTAR_MAGIC.compare(buf.slice(MAGIC_OFFSET, MAGIC_OFFSET + 6)) === 0) {\n    // ustar (posix) format.\n    // prepend prefix, if present.\n    if (buf.get(345)) name = decodeStr(buf, 345, 155, filenameEncoding) + '/' + name;\n  } else if (GNU_MAGIC.compare(buf.slice(MAGIC_OFFSET, MAGIC_OFFSET + 6)) === 0 && GNU_VER.compare(buf.slice(VERSION_OFFSET, VERSION_OFFSET + 2)) === 0) {// 'gnu'/'oldgnu' format. Similar to ustar, but has support for incremental and\n    // multi-volume tarballs.\n  } else {\n    throw new Error('Invalid tar header: unknown format.');\n  } // to support old tar versions that use trailing / to indicate dirs\n\n\n  if (typeflag === 0 && name && name[name.length - 1] === '/') typeflag = 5;\n  return {\n    name: name,\n    mode: mode,\n    uid: uid,\n    gid: gid,\n    size: size,\n    mtime: new Date(1000 * mtime),\n    type: type,\n    linkname: linkname,\n    uname: uname,\n    gname: gname,\n    devmajor: devmajor,\n    devminor: devminor\n  };\n};","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/it-tar/extract-headers.js"],"names":["Buffer","require","BufferList","ZERO_OFFSET","charCodeAt","USTAR_MAGIC","from","GNU_MAGIC","GNU_VER","MAGIC_OFFSET","VERSION_OFFSET","clamp","index","len","defaultValue","toType","flag","indexOf","block","num","offset","end","get","cksum","sum","i","j","parse256","buf","positive","zero","tuple","length","byte","push","l","Math","pow","decodeOct","val","shallowSlice","parseInt","toString","decodeStr","encoding","exports","decodeLongPath","isBufferList","decodePax","result","b","keyIndex","slice","decode","filenameEncoding","typeflag","name","mode","uid","gid","size","mtime","type","linkname","uname","gname","devmajor","devminor","c","Error","compare","Date"],"mappings":"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","sourcesContent":["const { Buffer } = require('buffer')\nconst BufferList = require('bl/BufferList')\n\nconst ZERO_OFFSET = '0'.charCodeAt(0)\nconst USTAR_MAGIC = Buffer.from('ustar\\x00', 'binary')\nconst GNU_MAGIC = Buffer.from('ustar\\x20', 'binary')\nconst GNU_VER = Buffer.from('\\x20\\x00', 'binary')\nconst MAGIC_OFFSET = 257\nconst VERSION_OFFSET = 263\n\nconst clamp = function (index, len, defaultValue) {\n  if (typeof index !== 'number') return defaultValue\n  index = ~~index // Coerce to integer.\n  if (index >= len) return len\n  if (index >= 0) return index\n  index += len\n  if (index >= 0) return index\n  return 0\n}\n\nconst toType = function (flag) {\n  switch (flag) {\n    case 0:\n      return 'file'\n    case 1:\n      return 'link'\n    case 2:\n      return 'symlink'\n    case 3:\n      return 'character-device'\n    case 4:\n      return 'block-device'\n    case 5:\n      return 'directory'\n    case 6:\n      return 'fifo'\n    case 7:\n      return 'contiguous-file'\n    case 72:\n      return 'pax-header'\n    case 55:\n      return 'pax-global-header'\n    case 27:\n      return 'gnu-long-link-path'\n    case 28:\n    case 30:\n      return 'gnu-long-path'\n  }\n\n  return null\n}\n\nconst indexOf = function (block, num, offset, end) {\n  for (; offset < end; offset++) {\n    if (block.get(offset) === num) return offset\n  }\n  return end\n}\n\nconst cksum = function (block) {\n  let sum = 8 * 32\n  for (let i = 0; i < 148; i++) sum += block.get(i)\n  for (let j = 156; j < 512; j++) sum += block.get(j)\n  return sum\n}\n\n/* Copied from the node-tar repo and modified to meet\n * tar-stream coding standard.\n *\n * Source: https://github.com/npm/node-tar/blob/51b6627a1f357d2eb433e7378e5f05e83b7aa6cd/lib/header.js#L349\n */\nfunction parse256 (buf) {\n  // first byte MUST be either 80 or FF\n  // 80 for positive, FF for 2's comp\n  let positive\n  if (buf.get(0) === 0x80) positive = true\n  else if (buf.get(0) === 0xFF) positive = false\n  else return null\n\n  // build up a base-256 tuple from the least sig to the highest\n  let zero = false\n  const tuple = []\n  for (let i = buf.length - 1; i > 0; i--) {\n    const byte = buf.get(i)\n    if (positive) tuple.push(byte)\n    else if (zero && byte === 0) tuple.push(0)\n    else if (zero) {\n      zero = false\n      tuple.push(0x100 - byte)\n    } else tuple.push(0xFF - byte)\n  }\n\n  let sum = 0\n  const l = tuple.length\n  for (let i = 0; i < l; i++) {\n    sum += tuple[i] * Math.pow(256, i)\n  }\n\n  return positive ? sum : -1 * sum\n}\n\nconst decodeOct = function (val, offset, length) {\n  val = val.shallowSlice(offset, offset + length)\n  offset = 0\n\n  // If prefixed with 0x80 then parse as a base-256 integer\n  if (val.get(offset) & 0x80) {\n    return parse256(val)\n  } else {\n    // Older versions of tar can prefix with spaces\n    while (offset < val.length && val.get(offset) === 32) offset++\n    const end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length)\n    while (offset < end && val.get(offset) === 0) offset++\n    if (end === offset) return 0\n    return parseInt(val.shallowSlice(offset, end).toString(), 8)\n  }\n}\n\nconst decodeStr = function (val, offset, length, encoding) {\n  return val.shallowSlice(offset, indexOf(val, 0, offset, offset + length)).toString(encoding)\n}\n\nexports.decodeLongPath = function (buf, encoding) {\n  buf = BufferList.isBufferList(buf) ? buf : new BufferList(buf)\n  return decodeStr(buf, 0, buf.length, encoding)\n}\n\nexports.decodePax = function (buf) {\n  buf = BufferList.isBufferList(buf) ? buf : new BufferList(buf)\n  const result = {}\n\n  while (buf.length) {\n    let i = 0\n    while (i < buf.length && buf.get(i) !== 32) i++\n    const len = parseInt(buf.shallowSlice(0, i).toString(), 10)\n    if (!len) return result\n\n    const b = buf.shallowSlice(i + 1, len - 1).toString()\n    const keyIndex = b.indexOf('=')\n    if (keyIndex === -1) return result\n    result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1)\n\n    buf = buf.shallowSlice(len)\n  }\n\n  return result\n}\n\nexports.decode = function (buf, filenameEncoding) {\n  buf = BufferList.isBufferList(buf) ? buf : new BufferList(buf)\n  let typeflag = buf.get(156) === 0 ? 0 : buf.get(156) - ZERO_OFFSET\n\n  let name = decodeStr(buf, 0, 100, filenameEncoding)\n  const mode = decodeOct(buf, 100, 8)\n  const uid = decodeOct(buf, 108, 8)\n  const gid = decodeOct(buf, 116, 8)\n  const size = decodeOct(buf, 124, 12)\n  const mtime = decodeOct(buf, 136, 12)\n  const type = toType(typeflag)\n  const linkname = buf.get(157) === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding)\n  const uname = decodeStr(buf, 265, 32)\n  const gname = decodeStr(buf, 297, 32)\n  const devmajor = decodeOct(buf, 329, 8)\n  const devminor = decodeOct(buf, 337, 8)\n\n  const c = cksum(buf)\n\n  // checksum is still initial value if header was null.\n  if (c === 8 * 32) return null\n\n  // valid checksum\n  if (c !== decodeOct(buf, 148, 8)) throw new Error('Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?')\n\n  if (USTAR_MAGIC.compare(buf.slice(MAGIC_OFFSET, MAGIC_OFFSET + 6)) === 0) {\n    // ustar (posix) format.\n    // prepend prefix, if present.\n    if (buf.get(345)) name = decodeStr(buf, 345, 155, filenameEncoding) + '/' + name\n  } else if (GNU_MAGIC.compare(buf.slice(MAGIC_OFFSET, MAGIC_OFFSET + 6)) === 0 &&\n             GNU_VER.compare(buf.slice(VERSION_OFFSET, VERSION_OFFSET + 2)) === 0) {\n    // 'gnu'/'oldgnu' format. Similar to ustar, but has support for incremental and\n    // multi-volume tarballs.\n  } else {\n    throw new Error('Invalid tar header: unknown format.')\n  }\n\n  // to support old tar versions that use trailing / to indicate dirs\n  if (typeflag === 0 && name && name[name.length - 1] === '/') typeflag = 5\n\n  return {\n    name: name,\n    mode: mode,\n    uid: uid,\n    gid: gid,\n    size: size,\n    mtime: new Date(1000 * mtime),\n    type: type,\n    linkname: linkname,\n    uname: uname,\n    gname: gname,\n    devmajor: devmajor,\n    devminor: devminor\n  }\n}\n"]},"metadata":{},"sourceType":"script"}