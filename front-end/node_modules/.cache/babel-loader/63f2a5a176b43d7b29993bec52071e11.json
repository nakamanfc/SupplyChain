{"ast":null,"code":"'use strict';\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst Block = require('multiformats/block');\n\nconst {\n  base58btc\n} = require('multiformats/bases/base58');\n\nconst {\n  CarWriter\n} = require('@ipld/car/writer');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst log = require('debug')('ipfs:components:dag:import');\n\nconst raw = require('multiformats/codecs/raw');\n\nconst json = require('multiformats/codecs/json'); // blocks that we're OK with not inspecting for links\n\n/** @type {number[]} */\n\n\nconst NO_LINKS_CODECS = [raw.code, // raw\njson.code // JSON\n];\n/**\n * @typedef {import('../../types').Preload} Preload\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n * @typedef {import('@ipld/car/api').BlockWriter} BlockWriter\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * @param {Object} config\n * @param {IPFSRepo} config.repo\n * @param {Preload} config.preload\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n */\n\nmodule.exports = ({\n  repo,\n  preload,\n  codecs\n}) => {\n  /**\n   * @type {import('ipfs-core-types/src/dag').API[\"export\"]}\n   */\n  async function* dagExport(root, options = {}) {\n    if (options.preload !== false) {\n      preload(root);\n    }\n\n    const cid = CID.asCID(root);\n\n    if (!cid) {\n      throw new Error(`Unexpected error converting CID type: ${root}`);\n    }\n\n    log(`Exporting ${cid} as car`);\n    const {\n      writer,\n      out\n    } = await CarWriter.create([cid]); // we need to write with one async channel and send the CarWriter output\n    // with another to the caller, but if the write causes an error we capture\n    // that and make sure it gets propagated\n\n    /** @type {Error|null} */\n\n    let err = null;\n\n    (async () => {\n      try {\n        await traverseWrite(repo, {\n          signal: options.signal,\n          timeout: options.timeout\n        }, cid, writer, codecs);\n        writer.close();\n      } catch (e) {\n        err = e;\n      }\n    })();\n\n    for await (const chunk of out) {\n      if (err) {\n        break;\n      }\n\n      yield chunk;\n    }\n\n    if (err) {\n      throw err;\n    }\n  }\n\n  return withTimeoutOption(dagExport);\n};\n/**\n * @param {IPFSRepo} repo\n * @param {AbortOptions} options\n * @param {CID} cid\n * @param {BlockWriter} writer\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {Set<string>} seen\n * @returns {Promise<void>}\n */\n\n\nasync function traverseWrite(repo, options, cid, writer, codecs, seen = new Set()) {\n  const b58Cid = cid.toString(base58btc);\n\n  if (seen.has(b58Cid)) {\n    return;\n  }\n\n  const block = await getBlock(repo, options, cid, codecs);\n  log(`Adding block ${cid} to car`);\n  await writer.put(block);\n  seen.add(b58Cid); // recursive traversal of all links\n\n  for (const link of block.links) {\n    await traverseWrite(repo, options, link, writer, codecs, seen);\n  }\n}\n/**\n * @param {IPFSRepo} repo\n * @param {AbortOptions} options\n * @param {CID} cid\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @returns {Promise<{cid:CID, bytes:Uint8Array, links:CID[]}>}\n */\n\n\nasync function getBlock(repo, options, cid, codecs) {\n  const bytes = await repo.blocks.get(cid, options);\n  /** @type {CID[]} */\n\n  let links = [];\n  const codec = await codecs.getCodec(cid.code);\n\n  if (codec) {\n    const block = Block.createUnsafe({\n      bytes,\n      cid,\n      codec\n    });\n    links = [...block.links()].map(l => l[1]);\n  } else if (!NO_LINKS_CODECS.includes(cid.code)) {\n    throw new Error(`Can't decode links in block with codec 0x${cid.code.toString(16)} to form complete DAG`);\n  }\n\n  return {\n    cid,\n    bytes,\n    links\n  };\n}","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/ipfs-core/src/components/dag/export.js"],"names":["CID","require","Block","base58btc","CarWriter","withTimeoutOption","log","raw","json","NO_LINKS_CODECS","code","module","exports","repo","preload","codecs","dagExport","root","options","cid","asCID","Error","writer","out","create","err","traverseWrite","signal","timeout","close","e","chunk","seen","Set","b58Cid","toString","has","block","getBlock","put","add","link","links","bytes","blocks","get","codec","getCodec","createUnsafe","map","l","includes"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { CID } = require('multiformats/cid')\nconst Block = require('multiformats/block')\nconst { base58btc } = require('multiformats/bases/base58')\nconst { CarWriter } = require('@ipld/car/writer')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\nconst log = require('debug')('ipfs:components:dag:import')\nconst raw = require('multiformats/codecs/raw')\nconst json = require('multiformats/codecs/json')\n\n// blocks that we're OK with not inspecting for links\n/** @type {number[]} */\nconst NO_LINKS_CODECS = [\n  raw.code, // raw\n  json.code // JSON\n]\n\n/**\n * @typedef {import('../../types').Preload} Preload\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n * @typedef {import('@ipld/car/api').BlockWriter} BlockWriter\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * @param {Object} config\n * @param {IPFSRepo} config.repo\n * @param {Preload} config.preload\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n */\nmodule.exports = ({ repo, preload, codecs }) => {\n  /**\n   * @type {import('ipfs-core-types/src/dag').API[\"export\"]}\n   */\n  async function * dagExport (root, options = {}) {\n    if (options.preload !== false) {\n      preload(root)\n    }\n\n    const cid = CID.asCID(root)\n    if (!cid) {\n      throw new Error(`Unexpected error converting CID type: ${root}`)\n    }\n\n    log(`Exporting ${cid} as car`)\n    const { writer, out } = await CarWriter.create([cid])\n\n    // we need to write with one async channel and send the CarWriter output\n    // with another to the caller, but if the write causes an error we capture\n    // that and make sure it gets propagated\n    /** @type {Error|null} */\n    let err = null\n    ;(async () => {\n      try {\n        await traverseWrite(\n          repo,\n          { signal: options.signal, timeout: options.timeout },\n          cid,\n          writer,\n          codecs)\n        writer.close()\n      } catch (e) {\n        err = e\n      }\n    })()\n\n    for await (const chunk of out) {\n      if (err) {\n        break\n      }\n      yield chunk\n    }\n    if (err) {\n      throw err\n    }\n  }\n\n  return withTimeoutOption(dagExport)\n}\n\n/**\n * @param {IPFSRepo} repo\n * @param {AbortOptions} options\n * @param {CID} cid\n * @param {BlockWriter} writer\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {Set<string>} seen\n * @returns {Promise<void>}\n */\nasync function traverseWrite (repo, options, cid, writer, codecs, seen = new Set()) {\n  const b58Cid = cid.toString(base58btc)\n  if (seen.has(b58Cid)) {\n    return\n  }\n\n  const block = await getBlock(repo, options, cid, codecs)\n\n  log(`Adding block ${cid} to car`)\n  await writer.put(block)\n  seen.add(b58Cid)\n\n  // recursive traversal of all links\n  for (const link of block.links) {\n    await traverseWrite(repo, options, link, writer, codecs, seen)\n  }\n}\n\n/**\n * @param {IPFSRepo} repo\n * @param {AbortOptions} options\n * @param {CID} cid\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @returns {Promise<{cid:CID, bytes:Uint8Array, links:CID[]}>}\n */\nasync function getBlock (repo, options, cid, codecs) {\n  const bytes = await repo.blocks.get(cid, options)\n\n  /** @type {CID[]} */\n  let links = []\n  const codec = await codecs.getCodec(cid.code)\n\n  if (codec) {\n    const block = Block.createUnsafe({ bytes, cid, codec })\n    links = [...block.links()].map((l) => l[1])\n  } else if (!NO_LINKS_CODECS.includes(cid.code)) {\n    throw new Error(`Can't decode links in block with codec 0x${cid.code.toString(16)} to form complete DAG`)\n  }\n\n  return { cid, bytes, links }\n}\n"]},"metadata":{},"sourceType":"script"}