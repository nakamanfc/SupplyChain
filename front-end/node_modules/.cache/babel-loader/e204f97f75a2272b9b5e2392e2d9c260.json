{"ast":null,"code":"'use strict';\n\nconst log = require('debug')('ipfs:components:peer:storage');\n\nconst createRepo = require('../runtime/repo-nodejs');\n\nconst getDefaultConfig = require('../runtime/config-nodejs');\n\nconst {\n  ERR_REPO_NOT_INITIALIZED\n} = require('ipfs-repo').errors;\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst PeerId = require('peer-id');\n\nconst mergeOptions = require('merge-options').bind({\n  ignoreUndefined: true\n});\n\nconst configService = require('./config');\n\nconst {\n  NotEnabledError,\n  NotInitializedError\n} = require('../errors');\n\nconst createLibP2P = require('./libp2p');\n/**\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n * @typedef {import('../types').Options} IPFSOptions\n * @typedef {import('../types').InitOptions} InitOptions\n * @typedef {import('../types').Print} Print\n * @typedef {import('ipfs-core-types/src/config').Config} IPFSConfig\n * @typedef {import('libp2p-crypto').KeyType} KeyType\n * @typedef {import('libp2p/src/keychain')} Keychain\n */\n\n\nclass Storage {\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @param {Keychain} keychain\n   * @param {IPFSRepo} repo\n   * @param {Print} print\n   * @param {boolean} isNew\n   */\n  constructor(peerId, keychain, repo, print, isNew) {\n    this.print = print;\n    this.peerId = peerId;\n    this.keychain = keychain;\n    this.repo = repo;\n    this.print = print;\n    this.isNew = isNew;\n  }\n  /**\n   * @param {Print} print\n   * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n   * @param {IPFSOptions} options\n   */\n\n\n  static async start(print, codecs, options) {\n    const {\n      repoAutoMigrate,\n      repo: inputRepo,\n      onMigrationProgress\n    } = options;\n    const repo = typeof inputRepo === 'string' || inputRepo == null ? createRepo(print, codecs, {\n      path: inputRepo,\n      autoMigrate: repoAutoMigrate,\n      onMigrationProgress: onMigrationProgress\n    }) : inputRepo;\n    const {\n      peerId,\n      keychain,\n      isNew\n    } = await loadRepo(print, repo, options); // TODO: throw error?\n    // @ts-ignore On start, keychain will always be available\n\n    return new Storage(peerId, keychain, repo, print, isNew);\n  }\n\n}\n\nmodule.exports = Storage;\n/**\n * @param {Print} print\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n */\n\nconst loadRepo = async (print, repo, options) => {\n  if (!repo.closed) {\n    return { ...(await configureRepo(repo, options)),\n      isNew: false\n    };\n  }\n\n  try {\n    await repo.open();\n    return { ...(await configureRepo(repo, options)),\n      isNew: false\n    };\n  } catch (err) {\n    if (err.code !== ERR_REPO_NOT_INITIALIZED) {\n      throw err;\n    }\n\n    if (options.init && options.init.allowNew === false) {\n      throw new NotEnabledError('Initialization of new repos disabled by config, pass `config.init.isNew: true` to enable it');\n    }\n\n    return { ...(await initRepo(print, repo, options)),\n      isNew: true\n    };\n  }\n};\n/**\n * @param {Print} print\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n * @returns {Promise<{peerId: PeerId, keychain?: Keychain}>}\n */\n\n\nconst initRepo = async (print, repo, options) => {\n  const initOptions = options.init || {}; // 1. Verify that repo does not exist yet (if it does and we could not open it we give up)\n\n  const exists = await repo.exists();\n  log('repo exists?', exists);\n\n  if (exists === true) {\n    throw new Error('repo already exists');\n  } // 2. Restore `peerId` from a given `.privateKey` or init new using provided options.\n\n\n  const peerId = initOptions.privateKey ? await decodePeerId(initOptions.privateKey) : await initPeerId(print, initOptions);\n  const identity = peerIdToIdentity(peerId);\n  log('peer identity: %s', identity.PeerID); // 3. Init new repo with provided `.config` and restored / initialized `peerId`\n\n  const config = { ...mergeOptions(applyProfiles(getDefaultConfig(), initOptions.profiles), options.config),\n    Identity: identity\n  };\n  await repo.init(config); // 4. Open initialized repo.\n\n  await repo.open();\n  log('repo opened');\n  /** @type {import('./libp2p').KeychainConfig} */\n\n  const keychainConfig = {\n    pass: options.pass\n  };\n\n  try {\n    keychainConfig.dek = await repo.config.get('Keychain.DEK');\n  } catch (err) {\n    if (err.code !== 'ERR_NOT_FOUND') {\n      throw err;\n    }\n  } // Create libp2p for Keychain creation\n\n\n  const libp2p = await createLibP2P({\n    options: undefined,\n    multiaddrs: undefined,\n    peerId,\n    repo,\n    config,\n    keychainConfig\n  });\n\n  if (libp2p.keychain && libp2p.keychain.opts) {\n    await libp2p.loadKeychain();\n    await repo.config.set('Keychain', {\n      DEK: libp2p.keychain.opts.dek\n    });\n  }\n\n  return {\n    peerId,\n    keychain: libp2p.keychain\n  };\n};\n/**\n * Takes `peerId` either represented as a string serialized string or\n * an instance and returns a `PeerId` instance.\n *\n * @param {PeerId|string} peerId\n * @returns {Promise<PeerId>|PeerId}\n */\n\n\nconst decodePeerId = peerId => {\n  log('using user-supplied private-key');\n  return typeof peerId === 'object' ? peerId : PeerId.createFromPrivKey(uint8ArrayFromString(peerId, 'base64pad'));\n};\n/**\n * Initializes new PeerId by generating an underlying keypair.\n *\n * @param {Print} print\n * @param {Object} options\n * @param {KeyType} [options.algorithm='Ed25519']\n * @param {number} [options.bits=2048]\n * @returns {Promise<PeerId>}\n */\n\n\nconst initPeerId = (print, {\n  algorithm = 'Ed25519',\n  bits = 2048\n}) => {\n  // Generate peer identity keypair + transform to desired format + add to config.\n  print('generating %s keypair...', algorithm);\n  return PeerId.create({\n    keyType: algorithm,\n    bits\n  });\n};\n/**\n * @param {PeerId} peerId\n */\n\n\nconst peerIdToIdentity = peerId => ({\n  PeerID: peerId.toB58String(),\n\n  /** @type {string} */\n  PrivKey: uint8ArrayToString(peerId.privKey.bytes, 'base64pad')\n});\n/**\n * Applies passed `profiles` and a `config` to an open repo.\n *\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n * @returns {Promise<{peerId: PeerId, keychain?: Keychain}>}\n */\n\n\nconst configureRepo = async (repo, options) => {\n  const config = options.config;\n  const profiles = options.init && options.init.profiles || [];\n  const pass = options.pass;\n  const original = await repo.config.getAll();\n  const changed = mergeConfigs(applyProfiles(original, profiles), config);\n\n  if (original !== changed) {\n    await repo.config.replace(changed);\n  }\n\n  if (!changed.Identity || !changed.Identity.PrivKey) {\n    throw new NotInitializedError('No private key was found in the config, please intialize the repo');\n  }\n\n  const peerId = await PeerId.createFromPrivKey(changed.Identity.PrivKey);\n  const libp2p = await createLibP2P({\n    options: undefined,\n    multiaddrs: undefined,\n    peerId,\n    repo,\n    config: changed,\n    keychainConfig: {\n      pass,\n      ...changed.Keychain\n    }\n  });\n\n  if (libp2p.keychain) {\n    await libp2p.loadKeychain();\n  }\n\n  return {\n    peerId,\n    keychain: libp2p.keychain\n  };\n};\n/**\n * @param {IPFSConfig} config\n * @param {Partial<IPFSConfig>} [changes]\n */\n\n\nconst mergeConfigs = (config, changes) => changes ? mergeOptions(config, changes) : config;\n/**\n * Apply profiles (e.g. ['server', 'lowpower']) to config\n *\n * @param {IPFSConfig} config\n * @param {string[]} [profiles]\n */\n\n\nconst applyProfiles = (config, profiles) => {\n  return (profiles || []).reduce((config, name) => {\n    const profile = configService.profiles[name];\n\n    if (!profile) {\n      throw new Error(`Could not find profile with name '${name}'`);\n    }\n\n    log('applying profile %s', name);\n    return profile.transform(config);\n  }, config);\n};","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/ipfs-core/src/components/storage.js"],"names":["log","require","createRepo","getDefaultConfig","ERR_REPO_NOT_INITIALIZED","errors","fromString","uint8ArrayFromString","toString","uint8ArrayToString","PeerId","mergeOptions","bind","ignoreUndefined","configService","NotEnabledError","NotInitializedError","createLibP2P","Storage","constructor","peerId","keychain","repo","print","isNew","start","codecs","options","repoAutoMigrate","inputRepo","onMigrationProgress","path","autoMigrate","loadRepo","module","exports","closed","configureRepo","open","err","code","init","allowNew","initRepo","initOptions","exists","Error","privateKey","decodePeerId","initPeerId","identity","peerIdToIdentity","PeerID","config","applyProfiles","profiles","Identity","keychainConfig","pass","dek","get","libp2p","undefined","multiaddrs","opts","loadKeychain","set","DEK","createFromPrivKey","algorithm","bits","create","keyType","toB58String","PrivKey","privKey","bytes","original","getAll","changed","mergeConfigs","replace","Keychain","changes","reduce","name","profile","transform"],"mappings":"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","sourcesContent":["'use strict'\n\nconst log = require('debug')('ipfs:components:peer:storage')\nconst createRepo = require('../runtime/repo-nodejs')\nconst getDefaultConfig = require('../runtime/config-nodejs')\nconst { ERR_REPO_NOT_INITIALIZED } = require('ipfs-repo').errors\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst PeerId = require('peer-id')\nconst mergeOptions = require('merge-options').bind({ ignoreUndefined: true })\nconst configService = require('./config')\nconst { NotEnabledError, NotInitializedError } = require('../errors')\nconst createLibP2P = require('./libp2p')\n\n/**\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n * @typedef {import('../types').Options} IPFSOptions\n * @typedef {import('../types').InitOptions} InitOptions\n * @typedef {import('../types').Print} Print\n * @typedef {import('ipfs-core-types/src/config').Config} IPFSConfig\n * @typedef {import('libp2p-crypto').KeyType} KeyType\n * @typedef {import('libp2p/src/keychain')} Keychain\n */\n\nclass Storage {\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @param {Keychain} keychain\n   * @param {IPFSRepo} repo\n   * @param {Print} print\n   * @param {boolean} isNew\n   */\n  constructor (peerId, keychain, repo, print, isNew) {\n    this.print = print\n    this.peerId = peerId\n    this.keychain = keychain\n    this.repo = repo\n    this.print = print\n    this.isNew = isNew\n  }\n\n  /**\n   * @param {Print} print\n   * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n   * @param {IPFSOptions} options\n   */\n  static async start (print, codecs, options) {\n    const { repoAutoMigrate, repo: inputRepo, onMigrationProgress } = options\n\n    const repo = (typeof inputRepo === 'string' || inputRepo == null)\n      ? createRepo(print, codecs, {\n        path: inputRepo,\n        autoMigrate: repoAutoMigrate,\n        onMigrationProgress: onMigrationProgress\n      })\n      : inputRepo\n\n    const { peerId, keychain, isNew } = await loadRepo(print, repo, options)\n\n    // TODO: throw error?\n    // @ts-ignore On start, keychain will always be available\n    return new Storage(peerId, keychain, repo, print, isNew)\n  }\n}\nmodule.exports = Storage\n\n/**\n * @param {Print} print\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n */\nconst loadRepo = async (print, repo, options) => {\n  if (!repo.closed) {\n    return { ...await configureRepo(repo, options), isNew: false }\n  }\n\n  try {\n    await repo.open()\n\n    return { ...await configureRepo(repo, options), isNew: false }\n  } catch (err) {\n    if (err.code !== ERR_REPO_NOT_INITIALIZED) {\n      throw err\n    }\n\n    if (options.init && options.init.allowNew === false) {\n      throw new NotEnabledError('Initialization of new repos disabled by config, pass `config.init.isNew: true` to enable it')\n    }\n\n    return { ...await initRepo(print, repo, options), isNew: true }\n  }\n}\n\n/**\n * @param {Print} print\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n * @returns {Promise<{peerId: PeerId, keychain?: Keychain}>}\n */\nconst initRepo = async (print, repo, options) => {\n  const initOptions = options.init || {}\n\n  // 1. Verify that repo does not exist yet (if it does and we could not open it we give up)\n  const exists = await repo.exists()\n  log('repo exists?', exists)\n\n  if (exists === true) {\n    throw new Error('repo already exists')\n  }\n\n  // 2. Restore `peerId` from a given `.privateKey` or init new using provided options.\n  const peerId = initOptions.privateKey\n    ? await decodePeerId(initOptions.privateKey)\n    : await initPeerId(print, initOptions)\n\n  const identity = peerIdToIdentity(peerId)\n\n  log('peer identity: %s', identity.PeerID)\n\n  // 3. Init new repo with provided `.config` and restored / initialized `peerId`\n  const config = {\n    ...mergeOptions(applyProfiles(getDefaultConfig(), initOptions.profiles), options.config),\n    Identity: identity\n  }\n  await repo.init(config)\n\n  // 4. Open initialized repo.\n  await repo.open()\n\n  log('repo opened')\n\n  /** @type {import('./libp2p').KeychainConfig} */\n  const keychainConfig = {\n    pass: options.pass\n  }\n\n  try {\n    keychainConfig.dek = await repo.config.get('Keychain.DEK')\n  } catch (err) {\n    if (err.code !== 'ERR_NOT_FOUND') {\n      throw err\n    }\n  }\n\n  // Create libp2p for Keychain creation\n  const libp2p = await createLibP2P({\n    options: undefined,\n    multiaddrs: undefined,\n    peerId,\n    repo,\n    config,\n    keychainConfig\n  })\n\n  if (libp2p.keychain && libp2p.keychain.opts) {\n    await libp2p.loadKeychain()\n\n    await repo.config.set('Keychain', {\n      DEK: libp2p.keychain.opts.dek\n    })\n  }\n\n  return { peerId, keychain: libp2p.keychain }\n}\n\n/**\n * Takes `peerId` either represented as a string serialized string or\n * an instance and returns a `PeerId` instance.\n *\n * @param {PeerId|string} peerId\n * @returns {Promise<PeerId>|PeerId}\n */\nconst decodePeerId = (peerId) => {\n  log('using user-supplied private-key')\n  return typeof peerId === 'object'\n    ? peerId\n    : PeerId.createFromPrivKey(uint8ArrayFromString(peerId, 'base64pad'))\n}\n\n/**\n * Initializes new PeerId by generating an underlying keypair.\n *\n * @param {Print} print\n * @param {Object} options\n * @param {KeyType} [options.algorithm='Ed25519']\n * @param {number} [options.bits=2048]\n * @returns {Promise<PeerId>}\n */\nconst initPeerId = (print, { algorithm = 'Ed25519', bits = 2048 }) => {\n  // Generate peer identity keypair + transform to desired format + add to config.\n  print('generating %s keypair...', algorithm)\n  return PeerId.create({ keyType: algorithm, bits })\n}\n\n/**\n * @param {PeerId} peerId\n */\nconst peerIdToIdentity = (peerId) => ({\n  PeerID: peerId.toB58String(),\n  /** @type {string} */\n  PrivKey: uint8ArrayToString(peerId.privKey.bytes, 'base64pad')\n})\n\n/**\n * Applies passed `profiles` and a `config` to an open repo.\n *\n * @param {IPFSRepo} repo\n * @param {IPFSOptions} options\n * @returns {Promise<{peerId: PeerId, keychain?: Keychain}>}\n */\nconst configureRepo = async (repo, options) => {\n  const config = options.config\n  const profiles = (options.init && options.init.profiles) || []\n  const pass = options.pass\n  const original = await repo.config.getAll()\n  const changed = mergeConfigs(applyProfiles(original, profiles), config)\n\n  if (original !== changed) {\n    await repo.config.replace(changed)\n  }\n\n  if (!changed.Identity || !changed.Identity.PrivKey) {\n    throw new NotInitializedError('No private key was found in the config, please intialize the repo')\n  }\n\n  const peerId = await PeerId.createFromPrivKey(changed.Identity.PrivKey)\n  const libp2p = await createLibP2P({\n    options: undefined,\n    multiaddrs: undefined,\n    peerId,\n    repo,\n    config: changed,\n    keychainConfig: {\n      pass,\n      ...changed.Keychain\n    }\n  })\n\n  if (libp2p.keychain) {\n    await libp2p.loadKeychain()\n  }\n\n  return { peerId, keychain: libp2p.keychain }\n}\n\n/**\n * @param {IPFSConfig} config\n * @param {Partial<IPFSConfig>} [changes]\n */\nconst mergeConfigs = (config, changes) =>\n  changes ? mergeOptions(config, changes) : config\n\n/**\n * Apply profiles (e.g. ['server', 'lowpower']) to config\n *\n * @param {IPFSConfig} config\n * @param {string[]} [profiles]\n */\nconst applyProfiles = (config, profiles) => {\n  return (profiles || []).reduce((config, name) => {\n    const profile = configService.profiles[name]\n    if (!profile) {\n      throw new Error(`Could not find profile with name '${name}'`)\n    }\n    log('applying profile %s', name)\n    return profile.transform(config)\n  }, config)\n}\n"]},"metadata":{},"sourceType":"script"}