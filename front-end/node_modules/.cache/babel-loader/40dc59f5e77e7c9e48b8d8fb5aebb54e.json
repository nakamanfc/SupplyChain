{"ast":null,"code":"'use strict'; // @ts-ignore\n\nconst KBucket = require('k-bucket');\n\nconst utils = require('./utils');\n/**\n * @typedef {import('peer-id')} PeerId\n *\n * @typedef {object} KBucketPeer\n * @property {Uint8Array} id\n * @property {PeerId} peer\n */\n\n/**\n * A wrapper around `k-bucket`, to provide easy store and\n * retrieval for peers.\n */\n\n\nclass RoutingTable {\n  /**\n   * @param {PeerId} self\n   * @param {number} kBucketSize\n   */\n  constructor(self, kBucketSize) {\n    this.self = self;\n    this._onPing = this._onPing.bind(this);\n\n    this._onInit(kBucketSize);\n  }\n  /**\n   * @param {number} kBucketSize\n   */\n\n\n  async _onInit(kBucketSize) {\n    const selfKey = await utils.convertPeerId(this.self);\n    this.kb = new KBucket({\n      localNodeId: selfKey,\n      numberOfNodesPerKBucket: kBucketSize,\n      numberOfNodesToPing: 1\n    });\n    this.kb.on('ping', this._onPing);\n  }\n  /**\n   * Called on the `ping` event from `k-bucket`.\n   * Currently this just removes the oldest contact from\n   * the list, without actually pinging the individual peers.\n   * This is the same as go does, but should probably\n   * be upgraded to actually ping the individual peers.\n   *\n   * @param {KBucketPeer[]} oldContacts\n   * @param {KBucketPeer} newContact\n   */\n\n\n  _onPing(oldContacts, newContact) {\n    // just use the first one (k-bucket sorts from oldest to newest)\n    const oldest = oldContacts[0];\n\n    if (oldest) {\n      // remove the oldest one\n      this.kb.remove(oldest.id);\n    } // add the new one\n\n\n    this.kb.add(newContact);\n  } // -- Public Interface\n\n  /**\n   * Amount of currently stored peers.\n   */\n\n\n  get size() {\n    return this.kb.count();\n  }\n  /**\n   * Find a specific peer by id.\n   *\n   * @param {PeerId} peer\n   * @returns {Promise<PeerId | undefined>}\n   */\n\n\n  async find(peer) {\n    const key = await utils.convertPeerId(peer);\n    const closest = this.closestPeer(key);\n\n    if (closest && peer.equals(closest)) {\n      return closest;\n    }\n  }\n  /**\n   * Retrieve the closest peers to the given key.\n   *\n   * @param {Uint8Array} key\n   */\n\n\n  closestPeer(key) {\n    const res = this.closestPeers(key, 1);\n\n    if (res.length > 0) {\n      return res[0];\n    }\n  }\n  /**\n   * Retrieve the `count`-closest peers to the given key.\n   *\n   * @param {Uint8Array} key\n   * @param {number} count\n   */\n\n\n  closestPeers(key, count) {\n    /** @type {KBucketPeer[]} */\n    const closest = this.kb.closest(key, count);\n    return closest.map(p => p.peer);\n  }\n  /**\n   * Add or update the routing table with the given peer.\n   *\n   * @param {PeerId} peer\n   */\n\n\n  async add(peer) {\n    const id = await utils.convertPeerId(peer);\n    this.kb.add({\n      id: id,\n      peer: peer\n    });\n  }\n  /**\n   * Remove a given peer from the table.\n   *\n   * @param {PeerId} peer\n   */\n\n\n  async remove(peer) {\n    const id = await utils.convertPeerId(peer);\n    this.kb.remove(id);\n  }\n\n}\n\nmodule.exports = RoutingTable;","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/libp2p-kad-dht/src/routing.js"],"names":["KBucket","require","utils","RoutingTable","constructor","self","kBucketSize","_onPing","bind","_onInit","selfKey","convertPeerId","kb","localNodeId","numberOfNodesPerKBucket","numberOfNodesToPing","on","oldContacts","newContact","oldest","remove","id","add","size","count","find","peer","key","closest","closestPeer","equals","res","closestPeers","length","map","p","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\n// @ts-ignore\nconst KBucket = require('k-bucket')\n\nconst utils = require('./utils')\n\n/**\n * @typedef {import('peer-id')} PeerId\n *\n * @typedef {object} KBucketPeer\n * @property {Uint8Array} id\n * @property {PeerId} peer\n */\n\n/**\n * A wrapper around `k-bucket`, to provide easy store and\n * retrieval for peers.\n */\nclass RoutingTable {\n  /**\n   * @param {PeerId} self\n   * @param {number} kBucketSize\n   */\n  constructor (self, kBucketSize) {\n    this.self = self\n    this._onPing = this._onPing.bind(this)\n\n    this._onInit(kBucketSize)\n  }\n\n  /**\n   * @param {number} kBucketSize\n   */\n  async _onInit (kBucketSize) {\n    const selfKey = await utils.convertPeerId(this.self)\n\n    this.kb = new KBucket({\n      localNodeId: selfKey,\n      numberOfNodesPerKBucket: kBucketSize,\n      numberOfNodesToPing: 1\n    })\n\n    this.kb.on('ping', this._onPing)\n  }\n\n  /**\n   * Called on the `ping` event from `k-bucket`.\n   * Currently this just removes the oldest contact from\n   * the list, without actually pinging the individual peers.\n   * This is the same as go does, but should probably\n   * be upgraded to actually ping the individual peers.\n   *\n   * @param {KBucketPeer[]} oldContacts\n   * @param {KBucketPeer} newContact\n   */\n  _onPing (oldContacts, newContact) {\n    // just use the first one (k-bucket sorts from oldest to newest)\n    const oldest = oldContacts[0]\n\n    if (oldest) {\n      // remove the oldest one\n      this.kb.remove(oldest.id)\n    }\n\n    // add the new one\n    this.kb.add(newContact)\n  }\n\n  // -- Public Interface\n\n  /**\n   * Amount of currently stored peers.\n   */\n  get size () {\n    return this.kb.count()\n  }\n\n  /**\n   * Find a specific peer by id.\n   *\n   * @param {PeerId} peer\n   * @returns {Promise<PeerId | undefined>}\n   */\n  async find (peer) {\n    const key = await utils.convertPeerId(peer)\n    const closest = this.closestPeer(key)\n\n    if (closest && peer.equals(closest)) {\n      return closest\n    }\n  }\n\n  /**\n   * Retrieve the closest peers to the given key.\n   *\n   * @param {Uint8Array} key\n   */\n  closestPeer (key) {\n    const res = this.closestPeers(key, 1)\n    if (res.length > 0) {\n      return res[0]\n    }\n  }\n\n  /**\n   * Retrieve the `count`-closest peers to the given key.\n   *\n   * @param {Uint8Array} key\n   * @param {number} count\n   */\n  closestPeers (key, count) {\n    /** @type {KBucketPeer[]} */\n    const closest = this.kb.closest(key, count)\n\n    return closest.map(p => p.peer)\n  }\n\n  /**\n   * Add or update the routing table with the given peer.\n   *\n   * @param {PeerId} peer\n   */\n  async add (peer) {\n    const id = await utils.convertPeerId(peer)\n\n    this.kb.add({ id: id, peer: peer })\n  }\n\n  /**\n   * Remove a given peer from the table.\n   *\n   * @param {PeerId} peer\n   */\n  async remove (peer) {\n    const id = await utils.convertPeerId(peer)\n\n    this.kb.remove(id)\n  }\n}\n\nmodule.exports = RoutingTable\n"]},"metadata":{},"sourceType":"script"}