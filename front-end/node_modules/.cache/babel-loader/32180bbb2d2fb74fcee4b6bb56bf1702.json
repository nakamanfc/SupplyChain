{"ast":null,"code":"'use strict';\n\nconst filter = require('it-filter');\n\nconst pushable = require('it-pushable');\n\nconst drain = require('it-drain');\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst errCode = require('err-code');\n\nconst {\n  identity\n} = require('multiformats/hashes/identity');\n/**\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Options} DatastoreOptions\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n */\n\n/**\n *\n * @param {Blockstore} blockstore\n */\n\n\nmodule.exports = createIdStore;\n/**\n * @param {Blockstore} store\n * @returns {Blockstore}\n */\n\nfunction createIdStore(store) {\n  return {\n    open() {\n      return store.open();\n    },\n\n    close() {\n      return store.close();\n    },\n\n    query(query, options) {\n      return store.query(query, options);\n    },\n\n    queryKeys(query, options) {\n      return store.queryKeys(query, options);\n    },\n\n    async get(cid, options) {\n      const extracted = extractContents(cid);\n\n      if (extracted.isIdentity) {\n        return Promise.resolve(extracted.digest);\n      }\n\n      return store.get(cid, options);\n    },\n\n    async *getMany(cids, options) {\n      for await (const cid of cids) {\n        yield this.get(cid, options);\n      }\n    },\n\n    async put(cid, buf, options) {\n      const {\n        isIdentity\n      } = extractContents(cid);\n\n      if (isIdentity) {\n        return;\n      }\n\n      await store.put(cid, buf, options);\n    },\n\n    async *putMany(pairs, options) {\n      // in order to return all blocks. we're going to assemble a seperate iterable\n      // return rather than return the resolves of store.putMany using the same\n      // process used by blockstore.putMany\n      const output = pushable(); // process.nextTick runs on the microtask queue, setImmediate runs on the next\n      // event loop iteration so is slower. Use process.nextTick if it is available.\n\n      const runner = process && process.nextTick ? process.nextTick : setImmediate;\n      runner(async () => {\n        try {\n          await drain(store.putMany(async function* () {\n            for await (const {\n              key,\n              value\n            } of pairs) {\n              if (!extractContents(key).isIdentity) {\n                yield {\n                  key,\n                  value\n                };\n              } // if non identity blocks successfully write, blocks are included in output\n\n\n              output.push({\n                key,\n                value\n              });\n            }\n          }()));\n          output.end();\n        } catch (err) {\n          output.end(err);\n        }\n      });\n      yield* output;\n    },\n\n    has(cid, options) {\n      const {\n        isIdentity\n      } = extractContents(cid);\n\n      if (isIdentity) {\n        return Promise.resolve(true);\n      }\n\n      return store.has(cid, options);\n    },\n\n    delete(cid, options) {\n      const {\n        isIdentity\n      } = extractContents(cid);\n\n      if (isIdentity) {\n        return Promise.resolve();\n      }\n\n      return store.delete(cid, options);\n    },\n\n    deleteMany(cids, options) {\n      return store.deleteMany(filter(cids, cid => !extractContents(cid).isIdentity), options);\n    },\n\n    batch() {\n      const batch = store.batch();\n      return {\n        put(cid, buf) {\n          const {\n            isIdentity\n          } = extractContents(cid);\n\n          if (isIdentity) {\n            return;\n          }\n\n          batch.put(cid, buf);\n        },\n\n        delete(cid) {\n          const {\n            isIdentity\n          } = extractContents(cid);\n\n          if (isIdentity) {\n            return;\n          }\n\n          batch.delete(cid);\n        },\n\n        commit: options => {\n          return batch.commit(options);\n        }\n      };\n    }\n\n  };\n}\n/**\n * @param {CID} k\n * @returns {{ isIdentity: false } | { isIdentity: true, digest: Uint8Array}}\n */\n\n\nfunction extractContents(k) {\n  const cid = CID.asCID(k);\n\n  if (cid == null) {\n    throw errCode(new Error('Not a valid cid'), 'ERR_INVALID_CID');\n  }\n\n  if (cid.multihash.code !== identity.code) {\n    return {\n      isIdentity: false\n    };\n  }\n\n  return {\n    isIdentity: true,\n    digest: cid.multihash.digest\n  };\n}","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/ipfs-repo/src/idstore.js"],"names":["filter","require","pushable","drain","CID","errCode","identity","module","exports","createIdStore","store","open","close","query","options","queryKeys","get","cid","extracted","extractContents","isIdentity","Promise","resolve","digest","getMany","cids","put","buf","putMany","pairs","output","runner","process","nextTick","setImmediate","key","value","push","end","err","has","delete","deleteMany","batch","commit","k","asCID","Error","multihash","code"],"mappings":"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","sourcesContent":["'use strict'\n\nconst filter = require('it-filter')\nconst pushable = require('it-pushable')\nconst drain = require('it-drain')\nconst { CID } = require('multiformats/cid')\nconst errCode = require('err-code')\nconst { identity } = require('multiformats/hashes/identity')\n\n/**\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Options} DatastoreOptions\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n */\n\n/**\n *\n * @param {Blockstore} blockstore\n */\nmodule.exports = createIdStore\n\n/**\n * @param {Blockstore} store\n * @returns {Blockstore}\n */\nfunction createIdStore (store) {\n  return {\n    open () {\n      return store.open()\n    },\n\n    close () {\n      return store.close()\n    },\n\n    query (query, options) {\n      return store.query(query, options)\n    },\n\n    queryKeys (query, options) {\n      return store.queryKeys(query, options)\n    },\n\n    async get (cid, options) {\n      const extracted = extractContents(cid)\n      if (extracted.isIdentity) {\n        return Promise.resolve(extracted.digest)\n      }\n      return store.get(cid, options)\n    },\n\n    async * getMany (cids, options) {\n      for await (const cid of cids) {\n        yield this.get(cid, options)\n      }\n    },\n\n    async put (cid, buf, options) {\n      const { isIdentity } = extractContents(cid)\n\n      if (isIdentity) {\n        return\n      }\n\n      await store.put(cid, buf, options)\n    },\n\n    async * putMany (pairs, options) {\n      // in order to return all blocks. we're going to assemble a seperate iterable\n      // return rather than return the resolves of store.putMany using the same\n      // process used by blockstore.putMany\n      const output = pushable()\n\n      // process.nextTick runs on the microtask queue, setImmediate runs on the next\n      // event loop iteration so is slower. Use process.nextTick if it is available.\n      const runner = process && process.nextTick ? process.nextTick : setImmediate\n\n      runner(async () => {\n        try {\n          await drain(store.putMany(async function * () {\n            for await (const { key, value } of pairs) {\n              if (!extractContents(key).isIdentity) {\n                yield { key, value }\n              }\n\n              // if non identity blocks successfully write, blocks are included in output\n              output.push({ key, value })\n            }\n          }()))\n\n          output.end()\n        } catch (err) {\n          output.end(err)\n        }\n      })\n\n      yield * output\n    },\n\n    has (cid, options) {\n      const { isIdentity } = extractContents(cid)\n      if (isIdentity) {\n        return Promise.resolve(true)\n      }\n      return store.has(cid, options)\n    },\n\n    delete (cid, options) {\n      const { isIdentity } = extractContents(cid)\n      if (isIdentity) {\n        return Promise.resolve()\n      }\n      return store.delete(cid, options)\n    },\n\n    deleteMany (cids, options) {\n      return store.deleteMany(filter(cids, (cid) => !extractContents(cid).isIdentity), options)\n    },\n\n    batch () {\n      const batch = store.batch()\n\n      return {\n        put (cid, buf) {\n          const { isIdentity } = extractContents(cid)\n\n          if (isIdentity) {\n            return\n          }\n\n          batch.put(cid, buf)\n        },\n        delete (cid) {\n          const { isIdentity } = extractContents(cid)\n\n          if (isIdentity) {\n            return\n          }\n\n          batch.delete(cid)\n        },\n        commit: (options) => {\n          return batch.commit(options)\n        }\n      }\n    }\n  }\n}\n\n/**\n * @param {CID} k\n * @returns {{ isIdentity: false } | { isIdentity: true, digest: Uint8Array}}\n */\nfunction extractContents (k) {\n  const cid = CID.asCID(k)\n\n  if (cid == null) {\n    throw errCode(new Error('Not a valid cid'), 'ERR_INVALID_CID')\n  }\n\n  if (cid.multihash.code !== identity.code) {\n    return {\n      isIdentity: false\n    }\n  }\n\n  return {\n    isIdentity: true,\n    digest: cid.multihash.digest\n  }\n}\n"]},"metadata":{},"sourceType":"script"}