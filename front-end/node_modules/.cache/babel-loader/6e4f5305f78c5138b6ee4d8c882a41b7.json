{"ast":null,"code":"\"use strict\"; // Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Package hmac implements HMAC algorithm.\n */\n\nvar hash_1 = require(\"@stablelib/hash\");\n\nvar constant_time_1 = require(\"@stablelib/constant-time\");\n\nvar wipe_1 = require(\"@stablelib/wipe\");\n/**\n *  HMAC implements hash-based message authentication algorithm.\n */\n\n\nvar HMAC =\n/** @class */\nfunction () {\n  /**\n   * Constructs a new HMAC with the given Hash and secret key.\n   */\n  function HMAC(hash, key) {\n    this._finished = false; // true if HMAC was finalized\n    // Initialize inner and outer hashes.\n\n    this._inner = new hash();\n    this._outer = new hash(); // Set block and digest sizes for this HMAC\n    // instance to values from the hash.\n\n    this.blockSize = this._outer.blockSize;\n    this.digestLength = this._outer.digestLength; // Pad temporary stores a key (or its hash) padded with zeroes.\n\n    var pad = new Uint8Array(this.blockSize);\n\n    if (key.length > this.blockSize) {\n      // If key is bigger than hash block size, it must be\n      // hashed and this hash is used as a key instead.\n      this._inner.update(key).finish(pad).clean();\n    } else {\n      // Otherwise, copy the key into pad.\n      pad.set(key);\n    } // Now two different keys are derived from padded key\n    // by xoring a different byte value to each.\n    // To make inner hash key, xor byte 0x36 into pad.\n\n\n    for (var i = 0; i < pad.length; i++) {\n      pad[i] ^= 0x36;\n    } // Update inner hash with the result.\n\n\n    this._inner.update(pad); // To make outer hash key, xor byte 0x5c into pad.\n    // But since we already xored 0x36 there, we must\n    // first undo this by xoring it again.\n\n\n    for (var i = 0; i < pad.length; i++) {\n      pad[i] ^= 0x36 ^ 0x5c;\n    } // Update outer hash with the result.\n\n\n    this._outer.update(pad); // Save states of both hashes, so that we can quickly restore\n    // them later in reset() without the need to remember the actual\n    // key and perform this initialization again.\n\n\n    if (hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer)) {\n      this._innerKeyedState = this._inner.saveState();\n      this._outerKeyedState = this._outer.saveState();\n    } // Clean pad.\n\n\n    wipe_1.wipe(pad);\n  }\n  /**\n   * Returns HMAC state to the state initialized with key\n   * to make it possible to run HMAC over the other data with the same\n   * key without creating a new instance.\n   */\n\n\n  HMAC.prototype.reset = function () {\n    if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {\n      throw new Error(\"hmac: can't reset() because hash doesn't implement restoreState()\");\n    } // Restore keyed states of inner and outer hashes.\n\n\n    this._inner.restoreState(this._innerKeyedState);\n\n    this._outer.restoreState(this._outerKeyedState);\n\n    this._finished = false;\n    return this;\n  };\n  /**\n   * Cleans HMAC state.\n   */\n\n\n  HMAC.prototype.clean = function () {\n    if (hash_1.isSerializableHash(this._inner)) {\n      this._inner.cleanSavedState(this._innerKeyedState);\n    }\n\n    if (hash_1.isSerializableHash(this._outer)) {\n      this._outer.cleanSavedState(this._outerKeyedState);\n    }\n\n    this._inner.clean();\n\n    this._outer.clean();\n  };\n  /**\n   * Updates state with provided data.\n   */\n\n\n  HMAC.prototype.update = function (data) {\n    this._inner.update(data);\n\n    return this;\n  };\n  /**\n   * Finalizes HMAC and puts the result in out.\n   */\n\n\n  HMAC.prototype.finish = function (out) {\n    if (this._finished) {\n      // If HMAC was finalized, outer hash is also finalized,\n      // so it produces the same digest it produced when it\n      // was finalized.\n      this._outer.finish(out);\n\n      return this;\n    } // Finalize inner hash and store the result temporarily.\n\n\n    this._inner.finish(out); // Update outer hash with digest of inner hash and and finalize it.\n\n\n    this._outer.update(out.subarray(0, this.digestLength)).finish(out);\n\n    this._finished = true;\n    return this;\n  };\n  /**\n   * Returns the computed message authentication code.\n   */\n\n\n  HMAC.prototype.digest = function () {\n    var out = new Uint8Array(this.digestLength);\n    this.finish(out);\n    return out;\n  };\n  /**\n   * Saves HMAC state.\n   * This function is needed for PBKDF2 optimization.\n   */\n\n\n  HMAC.prototype.saveState = function () {\n    if (!hash_1.isSerializableHash(this._inner)) {\n      throw new Error(\"hmac: can't saveState() because hash doesn't implement it\");\n    }\n\n    return this._inner.saveState();\n  };\n\n  HMAC.prototype.restoreState = function (savedState) {\n    if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {\n      throw new Error(\"hmac: can't restoreState() because hash doesn't implement it\");\n    }\n\n    this._inner.restoreState(savedState);\n\n    this._outer.restoreState(this._outerKeyedState);\n\n    this._finished = false;\n    return this;\n  };\n\n  HMAC.prototype.cleanSavedState = function (savedState) {\n    if (!hash_1.isSerializableHash(this._inner)) {\n      throw new Error(\"hmac: can't cleanSavedState() because hash doesn't implement it\");\n    }\n\n    this._inner.cleanSavedState(savedState);\n  };\n\n  return HMAC;\n}();\n\nexports.HMAC = HMAC;\n/**\n * Returns HMAC using the given hash constructor for the key over data.\n */\n\nfunction hmac(hash, key, data) {\n  var h = new HMAC(hash, key);\n  h.update(data);\n  var digest = h.digest();\n  h.clean();\n  return digest;\n}\n\nexports.hmac = hmac;\n/**\n * Returns true if two HMAC digests are equal.\n * Uses constant-time comparison to avoid leaking timing information.\n *\n * Example:\n *\n *    const receivedDigest = ...\n *    const realDigest = hmac(SHA256, key, data);\n *    if (!equal(receivedDigest, realDigest)) {\n *        throw new Error(\"Authentication error\");\n *    }\n */\n\nexports.equal = constant_time_1.equal;","map":{"version":3,"sources":["../hmac.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Package hmac implements HMAC algorithm.\n */\nvar hash_1 = require(\"@stablelib/hash\");\nvar constant_time_1 = require(\"@stablelib/constant-time\");\nvar wipe_1 = require(\"@stablelib/wipe\");\n/**\n *  HMAC implements hash-based message authentication algorithm.\n */\nvar HMAC = /** @class */ (function () {\n    /**\n     * Constructs a new HMAC with the given Hash and secret key.\n     */\n    function HMAC(hash, key) {\n        this._finished = false; // true if HMAC was finalized\n        // Initialize inner and outer hashes.\n        this._inner = new hash();\n        this._outer = new hash();\n        // Set block and digest sizes for this HMAC\n        // instance to values from the hash.\n        this.blockSize = this._outer.blockSize;\n        this.digestLength = this._outer.digestLength;\n        // Pad temporary stores a key (or its hash) padded with zeroes.\n        var pad = new Uint8Array(this.blockSize);\n        if (key.length > this.blockSize) {\n            // If key is bigger than hash block size, it must be\n            // hashed and this hash is used as a key instead.\n            this._inner.update(key).finish(pad).clean();\n        }\n        else {\n            // Otherwise, copy the key into pad.\n            pad.set(key);\n        }\n        // Now two different keys are derived from padded key\n        // by xoring a different byte value to each.\n        // To make inner hash key, xor byte 0x36 into pad.\n        for (var i = 0; i < pad.length; i++) {\n            pad[i] ^= 0x36;\n        }\n        // Update inner hash with the result.\n        this._inner.update(pad);\n        // To make outer hash key, xor byte 0x5c into pad.\n        // But since we already xored 0x36 there, we must\n        // first undo this by xoring it again.\n        for (var i = 0; i < pad.length; i++) {\n            pad[i] ^= 0x36 ^ 0x5c;\n        }\n        // Update outer hash with the result.\n        this._outer.update(pad);\n        // Save states of both hashes, so that we can quickly restore\n        // them later in reset() without the need to remember the actual\n        // key and perform this initialization again.\n        if (hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer)) {\n            this._innerKeyedState = this._inner.saveState();\n            this._outerKeyedState = this._outer.saveState();\n        }\n        // Clean pad.\n        wipe_1.wipe(pad);\n    }\n    /**\n     * Returns HMAC state to the state initialized with key\n     * to make it possible to run HMAC over the other data with the same\n     * key without creating a new instance.\n     */\n    HMAC.prototype.reset = function () {\n        if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {\n            throw new Error(\"hmac: can't reset() because hash doesn't implement restoreState()\");\n        }\n        // Restore keyed states of inner and outer hashes.\n        this._inner.restoreState(this._innerKeyedState);\n        this._outer.restoreState(this._outerKeyedState);\n        this._finished = false;\n        return this;\n    };\n    /**\n     * Cleans HMAC state.\n     */\n    HMAC.prototype.clean = function () {\n        if (hash_1.isSerializableHash(this._inner)) {\n            this._inner.cleanSavedState(this._innerKeyedState);\n        }\n        if (hash_1.isSerializableHash(this._outer)) {\n            this._outer.cleanSavedState(this._outerKeyedState);\n        }\n        this._inner.clean();\n        this._outer.clean();\n    };\n    /**\n     * Updates state with provided data.\n     */\n    HMAC.prototype.update = function (data) {\n        this._inner.update(data);\n        return this;\n    };\n    /**\n     * Finalizes HMAC and puts the result in out.\n     */\n    HMAC.prototype.finish = function (out) {\n        if (this._finished) {\n            // If HMAC was finalized, outer hash is also finalized,\n            // so it produces the same digest it produced when it\n            // was finalized.\n            this._outer.finish(out);\n            return this;\n        }\n        // Finalize inner hash and store the result temporarily.\n        this._inner.finish(out);\n        // Update outer hash with digest of inner hash and and finalize it.\n        this._outer.update(out.subarray(0, this.digestLength)).finish(out);\n        this._finished = true;\n        return this;\n    };\n    /**\n     * Returns the computed message authentication code.\n     */\n    HMAC.prototype.digest = function () {\n        var out = new Uint8Array(this.digestLength);\n        this.finish(out);\n        return out;\n    };\n    /**\n     * Saves HMAC state.\n     * This function is needed for PBKDF2 optimization.\n     */\n    HMAC.prototype.saveState = function () {\n        if (!hash_1.isSerializableHash(this._inner)) {\n            throw new Error(\"hmac: can't saveState() because hash doesn't implement it\");\n        }\n        return this._inner.saveState();\n    };\n    HMAC.prototype.restoreState = function (savedState) {\n        if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {\n            throw new Error(\"hmac: can't restoreState() because hash doesn't implement it\");\n        }\n        this._inner.restoreState(savedState);\n        this._outer.restoreState(this._outerKeyedState);\n        this._finished = false;\n        return this;\n    };\n    HMAC.prototype.cleanSavedState = function (savedState) {\n        if (!hash_1.isSerializableHash(this._inner)) {\n            throw new Error(\"hmac: can't cleanSavedState() because hash doesn't implement it\");\n        }\n        this._inner.cleanSavedState(savedState);\n    };\n    return HMAC;\n}());\nexports.HMAC = HMAC;\n/**\n * Returns HMAC using the given hash constructor for the key over data.\n */\nfunction hmac(hash, key, data) {\n    var h = new HMAC(hash, key);\n    h.update(data);\n    var digest = h.digest();\n    h.clean();\n    return digest;\n}\nexports.hmac = hmac;\n/**\n * Returns true if two HMAC digests are equal.\n * Uses constant-time comparison to avoid leaking timing information.\n *\n * Example:\n *\n *    const receivedDigest = ...\n *    const realDigest = hmac(SHA256, key, data);\n *    if (!equal(receivedDigest, realDigest)) {\n *        throw new Error(\"Authentication error\");\n *    }\n */\nexports.equal = constant_time_1.equal;\n//# sourceMappingURL=hmac.js.map"]},"metadata":{},"sourceType":"script"}