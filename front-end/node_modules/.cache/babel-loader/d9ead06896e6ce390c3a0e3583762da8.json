{"ast":null,"code":"'use strict';\n\nvar hamtSharding = require('hamt-sharding');\n\nvar dagPb = require('@ipld/dag-pb');\n\nvar murmur3 = require('@multiformats/murmur3');\n\nconst hashFn = async function (buf) {\n  return (await murmur3.murmur3128.encode(buf)).slice(0, 8).reverse();\n};\n\nconst addLinksToHamtBucket = (links, bucket, rootBucket) => {\n  return Promise.all(links.map(link => {\n    if (link.Name == null) {\n      throw new Error('Unexpected Link without a Name');\n    }\n\n    if (link.Name.length === 2) {\n      const pos = parseInt(link.Name, 16);\n      return bucket._putObjectAt(pos, new hamtSharding.Bucket({\n        hash: rootBucket._options.hash,\n        bits: rootBucket._options.bits\n      }, bucket, pos));\n    }\n\n    return rootBucket.put(link.Name.substring(2), true);\n  }));\n};\n\nconst toPrefix = position => {\n  return position.toString(16).toUpperCase().padStart(2, '0').substring(0, 2);\n};\n\nconst toBucketPath = position => {\n  let bucket = position.bucket;\n  const path = [];\n\n  while (bucket._parent) {\n    path.push(bucket);\n    bucket = bucket._parent;\n  }\n\n  path.push(bucket);\n  return path.reverse();\n};\n\nconst findShardCid = async (node, name, blockstore, context, options) => {\n  if (!context) {\n    const rootBucket = hamtSharding.createHAMT({\n      hashFn\n    });\n    context = {\n      rootBucket,\n      hamtDepth: 1,\n      lastBucket: rootBucket\n    };\n  }\n\n  await addLinksToHamtBucket(node.Links, context.lastBucket, context.rootBucket);\n  const position = await context.rootBucket._findNewBucketAndPos(name);\n  let prefix = toPrefix(position.pos);\n  const bucketPath = toBucketPath(position);\n\n  if (bucketPath.length > context.hamtDepth) {\n    context.lastBucket = bucketPath[context.hamtDepth];\n    prefix = toPrefix(context.lastBucket._posAtParent);\n  }\n\n  const link = node.Links.find(link => {\n    if (link.Name == null) {\n      return false;\n    }\n\n    const entryPrefix = link.Name.substring(0, 2);\n    const entryName = link.Name.substring(2);\n\n    if (entryPrefix !== prefix) {\n      return false;\n    }\n\n    if (entryName && entryName !== name) {\n      return false;\n    }\n\n    return true;\n  });\n\n  if (!link) {\n    return null;\n  }\n\n  if (link.Name != null && link.Name.substring(2) === name) {\n    return link.Hash;\n  }\n\n  context.hamtDepth++;\n  const block = await blockstore.get(link.Hash, options);\n  node = dagPb.decode(block);\n  return findShardCid(node, name, blockstore, context, options);\n};\n\nmodule.exports = findShardCid;","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/ipfs-unixfs-exporter/cjs/src/utils/find-cid-in-shard.js"],"names":["hamtSharding","require","dagPb","murmur3","hashFn","buf","murmur3128","encode","slice","reverse","addLinksToHamtBucket","links","bucket","rootBucket","Promise","all","map","link","Name","Error","length","pos","parseInt","_putObjectAt","Bucket","hash","_options","bits","put","substring","toPrefix","position","toString","toUpperCase","padStart","toBucketPath","path","_parent","push","findShardCid","node","name","blockstore","context","options","createHAMT","hamtDepth","lastBucket","Links","_findNewBucketAndPos","prefix","bucketPath","_posAtParent","find","entryPrefix","entryName","Hash","block","get","decode","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar hamtSharding = require('hamt-sharding');\nvar dagPb = require('@ipld/dag-pb');\nvar murmur3 = require('@multiformats/murmur3');\n\nconst hashFn = async function (buf) {\n  return (await murmur3.murmur3128.encode(buf)).slice(0, 8).reverse();\n};\nconst addLinksToHamtBucket = (links, bucket, rootBucket) => {\n  return Promise.all(links.map(link => {\n    if (link.Name == null) {\n      throw new Error('Unexpected Link without a Name');\n    }\n    if (link.Name.length === 2) {\n      const pos = parseInt(link.Name, 16);\n      return bucket._putObjectAt(pos, new hamtSharding.Bucket({\n        hash: rootBucket._options.hash,\n        bits: rootBucket._options.bits\n      }, bucket, pos));\n    }\n    return rootBucket.put(link.Name.substring(2), true);\n  }));\n};\nconst toPrefix = position => {\n  return position.toString(16).toUpperCase().padStart(2, '0').substring(0, 2);\n};\nconst toBucketPath = position => {\n  let bucket = position.bucket;\n  const path = [];\n  while (bucket._parent) {\n    path.push(bucket);\n    bucket = bucket._parent;\n  }\n  path.push(bucket);\n  return path.reverse();\n};\nconst findShardCid = async (node, name, blockstore, context, options) => {\n  if (!context) {\n    const rootBucket = hamtSharding.createHAMT({ hashFn });\n    context = {\n      rootBucket,\n      hamtDepth: 1,\n      lastBucket: rootBucket\n    };\n  }\n  await addLinksToHamtBucket(node.Links, context.lastBucket, context.rootBucket);\n  const position = await context.rootBucket._findNewBucketAndPos(name);\n  let prefix = toPrefix(position.pos);\n  const bucketPath = toBucketPath(position);\n  if (bucketPath.length > context.hamtDepth) {\n    context.lastBucket = bucketPath[context.hamtDepth];\n    prefix = toPrefix(context.lastBucket._posAtParent);\n  }\n  const link = node.Links.find(link => {\n    if (link.Name == null) {\n      return false;\n    }\n    const entryPrefix = link.Name.substring(0, 2);\n    const entryName = link.Name.substring(2);\n    if (entryPrefix !== prefix) {\n      return false;\n    }\n    if (entryName && entryName !== name) {\n      return false;\n    }\n    return true;\n  });\n  if (!link) {\n    return null;\n  }\n  if (link.Name != null && link.Name.substring(2) === name) {\n    return link.Hash;\n  }\n  context.hamtDepth++;\n  const block = await blockstore.get(link.Hash, options);\n  node = dagPb.decode(block);\n  return findShardCid(node, name, blockstore, context, options);\n};\n\nmodule.exports = findShardCid;\n"]},"metadata":{},"sourceType":"script"}