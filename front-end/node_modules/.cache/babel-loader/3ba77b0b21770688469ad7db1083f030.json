{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst PeerId = require('peer-id');\n\nconst drain = require('it-drain');\n\nconst {\n  default: PQueue\n} = require('p-queue');\n\nconst defer = require('p-defer');\n\nconst log = debug('libp2p-delegated-content-routing');\nlog.error = debug('libp2p-delegated-content-routing:error');\nconst DEFAULT_TIMEOUT = 30e3; // 30 second default\n\nconst CONCURRENT_HTTP_REQUESTS = 4;\n/**\n * @typedef {import('peer-id').PeerID} PeerID\n * @typedef {import('cids').CID} CID\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * An implementation of content routing, using a delegated peer.\n */\n\nclass DelegatedContentRouting {\n  /**\n   * Create a new DelegatedContentRouting instance.\n   *\n   * @param {PeerID} peerId - the id of the node that is using this routing.\n   * @param {object} client - an instance of the ipfs-http-client module\n   */\n  constructor(peerId, client) {\n    if (peerId == null) {\n      throw new Error('missing self peerId');\n    }\n\n    if (client == null) {\n      throw new Error('missing ipfs http client');\n    }\n\n    this._client = client;\n    this.peerId = peerId; // limit concurrency to avoid request flood in web browser\n    // https://github.com/libp2p/js-libp2p-delegated-content-routing/issues/12\n\n    const concurrency = {\n      concurrency: CONCURRENT_HTTP_REQUESTS\n    };\n    this._httpQueue = new PQueue(concurrency); // sometimes refs requests take long time, they need separate queue\n    // to not suffocate regular business\n\n    this._httpQueueRefs = new PQueue(Object.assign({}, concurrency, {\n      concurrency: 2\n    }));\n    const {\n      protocol,\n      host,\n      port\n    } = client.getEndpointConfig();\n    log(`enabled DelegatedContentRouting via ${protocol}://${host}:${port}`);\n  }\n  /**\n   * Search the dht for providers of the given CID.\n   *\n   * - call `findProviders` on the delegated node.\n   *\n   * @param {CID} key - The CID to find providers for\n   * @param {object} options - Options\n   * @param {number} options.timeout - How long the query can take. Defaults to 30 seconds\n   * @param {number} options.numProviders - How many providers to find, defaults to 20\n   * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} - An async iterable of PeerId/Multiaddrs\n   */\n\n\n  async *findProviders(key, options = {}) {\n    log(`findProviders starts: ${key}`);\n    options.timeout = options.timeout || DEFAULT_TIMEOUT;\n    let providers = 0;\n    const onStart = defer();\n    const onFinish = defer();\n\n    this._httpQueue.add(() => {\n      onStart.resolve();\n      return onFinish.promise;\n    });\n\n    try {\n      await onStart.promise;\n\n      for await (const {\n        id,\n        addrs\n      } of this._client.dht.findProvs(key, {\n        numProviders: options.numProviders,\n        timeout: options.timeout\n      })) {\n        yield {\n          id: PeerId.parse(id),\n          multiaddrs: addrs\n        };\n        providers++;\n      }\n    } catch (err) {\n      log.error('findProviders errored:', err);\n      throw err;\n    } finally {\n      onFinish.resolve();\n      log(`findProviders finished: ${key} found ${providers} providers`);\n    }\n  }\n  /**\n   * Announce to the network that the delegated node can provide the given key.\n   *\n   * Currently this uses the following hack\n   * - delegate is one of bootstrap nodes, so we are always connected to it\n   * - call block stat on the delegated node, so it fetches the content\n   * - call dht provide with the passed cid\n   *\n   * N.B. this must be called for every block in the dag you want provided otherwise\n   * the delegate will only be able to supply the root block of the dag when asked\n   * for the data by an interested peer.\n   *\n   * @param {CID} key - The delegate will publish a provider record for this CID\n   * @returns {Promise<void>}\n   */\n\n\n  async provide(key) {\n    log(`provide starts: ${key}`);\n    await this._httpQueueRefs.add(async () => {\n      await this._client.block.stat(key);\n      await drain(this._client.dht.provide(key));\n    });\n    log(`provide finished: ${key}`);\n  }\n\n}\n\nmodule.exports = DelegatedContentRouting;","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/libp2p-delegated-content-routing/src/index.js"],"names":["debug","require","PeerId","drain","default","PQueue","defer","log","error","DEFAULT_TIMEOUT","CONCURRENT_HTTP_REQUESTS","DelegatedContentRouting","constructor","peerId","client","Error","_client","concurrency","_httpQueue","_httpQueueRefs","Object","assign","protocol","host","port","getEndpointConfig","findProviders","key","options","timeout","providers","onStart","onFinish","add","resolve","promise","id","addrs","dht","findProvs","numProviders","parse","multiaddrs","err","provide","block","stat","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst PeerId = require('peer-id')\nconst drain = require('it-drain')\n\nconst { default: PQueue } = require('p-queue')\nconst defer = require('p-defer')\n\nconst log = debug('libp2p-delegated-content-routing')\nlog.error = debug('libp2p-delegated-content-routing:error')\n\nconst DEFAULT_TIMEOUT = 30e3 // 30 second default\nconst CONCURRENT_HTTP_REQUESTS = 4\n\n/**\n * @typedef {import('peer-id').PeerID} PeerID\n * @typedef {import('cids').CID} CID\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * An implementation of content routing, using a delegated peer.\n */\nclass DelegatedContentRouting {\n  /**\n   * Create a new DelegatedContentRouting instance.\n   *\n   * @param {PeerID} peerId - the id of the node that is using this routing.\n   * @param {object} client - an instance of the ipfs-http-client module\n   */\n  constructor (peerId, client) {\n    if (peerId == null) {\n      throw new Error('missing self peerId')\n    }\n\n    if (client == null) {\n      throw new Error('missing ipfs http client')\n    }\n\n    this._client = client\n    this.peerId = peerId\n\n    // limit concurrency to avoid request flood in web browser\n    // https://github.com/libp2p/js-libp2p-delegated-content-routing/issues/12\n    const concurrency = { concurrency: CONCURRENT_HTTP_REQUESTS }\n    this._httpQueue = new PQueue(concurrency)\n    // sometimes refs requests take long time, they need separate queue\n    // to not suffocate regular business\n    this._httpQueueRefs = new PQueue(Object.assign({}, concurrency, {\n      concurrency: 2\n    }))\n\n    const {\n      protocol,\n      host,\n      port\n    } = client.getEndpointConfig()\n\n    log(`enabled DelegatedContentRouting via ${protocol}://${host}:${port}`)\n  }\n\n  /**\n   * Search the dht for providers of the given CID.\n   *\n   * - call `findProviders` on the delegated node.\n   *\n   * @param {CID} key - The CID to find providers for\n   * @param {object} options - Options\n   * @param {number} options.timeout - How long the query can take. Defaults to 30 seconds\n   * @param {number} options.numProviders - How many providers to find, defaults to 20\n   * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} - An async iterable of PeerId/Multiaddrs\n   */\n  async * findProviders (key, options = {}) {\n    log(`findProviders starts: ${key}`)\n    options.timeout = options.timeout || DEFAULT_TIMEOUT\n\n    let providers = 0\n    const onStart = defer()\n    const onFinish = defer()\n\n    this._httpQueue.add(() => {\n      onStart.resolve()\n      return onFinish.promise\n    })\n\n    try {\n      await onStart.promise\n\n      for await (const { id, addrs } of this._client.dht.findProvs(key, {\n        numProviders: options.numProviders,\n        timeout: options.timeout\n      })) {\n        yield {\n          id: PeerId.parse(id),\n          multiaddrs: addrs\n        }\n        providers++\n      }\n    } catch (err) {\n      log.error('findProviders errored:', err)\n      throw err\n    } finally {\n      onFinish.resolve()\n      log(`findProviders finished: ${key} found ${providers} providers`)\n    }\n  }\n\n  /**\n   * Announce to the network that the delegated node can provide the given key.\n   *\n   * Currently this uses the following hack\n   * - delegate is one of bootstrap nodes, so we are always connected to it\n   * - call block stat on the delegated node, so it fetches the content\n   * - call dht provide with the passed cid\n   *\n   * N.B. this must be called for every block in the dag you want provided otherwise\n   * the delegate will only be able to supply the root block of the dag when asked\n   * for the data by an interested peer.\n   *\n   * @param {CID} key - The delegate will publish a provider record for this CID\n   * @returns {Promise<void>}\n   */\n  async provide (key) {\n    log(`provide starts: ${key}`)\n    await this._httpQueueRefs.add(async () => {\n      await this._client.block.stat(key)\n      await drain(this._client.dht.provide(key))\n    })\n    log(`provide finished: ${key}`)\n  }\n}\n\nmodule.exports = DelegatedContentRouting\n"]},"metadata":{},"sourceType":"script"}