{"ast":null,"code":"\"use strict\"; // Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar chacha_1 = require(\"@stablelib/chacha\");\n\nvar poly1305_1 = require(\"@stablelib/poly1305\");\n\nvar wipe_1 = require(\"@stablelib/wipe\");\n\nvar binary_1 = require(\"@stablelib/binary\");\n\nvar constant_time_1 = require(\"@stablelib/constant-time\");\n\nexports.KEY_LENGTH = 32;\nexports.NONCE_LENGTH = 12;\nexports.TAG_LENGTH = 16;\nvar ZEROS = new Uint8Array(16);\n/**\n * ChaCha20-Poly1305 Authenticated Encryption with Associated Data.\n *\n * Defined in RFC7539.\n */\n\nvar ChaCha20Poly1305 =\n/** @class */\nfunction () {\n  /**\n   * Creates a new instance with the given 32-byte key.\n   */\n  function ChaCha20Poly1305(key) {\n    this.nonceLength = exports.NONCE_LENGTH;\n    this.tagLength = exports.TAG_LENGTH;\n\n    if (key.length !== exports.KEY_LENGTH) {\n      throw new Error(\"ChaCha20Poly1305 needs 32-byte key\");\n    } // Copy key.\n\n\n    this._key = new Uint8Array(key);\n  }\n  /**\n   * Encrypts and authenticates plaintext, authenticates associated data,\n   * and returns sealed ciphertext, which includes authentication tag.\n   *\n   * RFC7539 specifies 12 bytes for nonce. It may be this 12-byte nonce\n   * (\"IV\"), or full 16-byte counter (called \"32-bit fixed-common part\")\n   * and nonce.\n   *\n   * If dst is given (it must be the size of plaintext + the size of tag\n   * length) the result will be put into it. Dst and plaintext must not\n   * overlap.\n   */\n\n\n  ChaCha20Poly1305.prototype.seal = function (nonce, plaintext, associatedData, dst) {\n    if (nonce.length > 16) {\n      throw new Error(\"ChaCha20Poly1305: incorrect nonce length\");\n    } // Allocate space for counter, and set nonce as last bytes of it.\n\n\n    var counter = new Uint8Array(16);\n    counter.set(nonce, counter.length - nonce.length); // Generate authentication key by taking first 32-bytes of stream.\n    // We pass full counter, which has 12-byte nonce and 4-byte block counter,\n    // and it will get incremented after generating the block, which is\n    // exactly what we need: we only use the first 32 bytes of 64-byte\n    // ChaCha block and discard the next 32 bytes.\n\n    var authKey = new Uint8Array(32);\n    chacha_1.stream(this._key, counter, authKey, 4); // Allocate space for sealed ciphertext.\n\n    var resultLength = plaintext.length + this.tagLength;\n    var result;\n\n    if (dst) {\n      if (dst.length !== resultLength) {\n        throw new Error(\"ChaCha20Poly1305: incorrect destination length\");\n      }\n\n      result = dst;\n    } else {\n      result = new Uint8Array(resultLength);\n    } // Encrypt plaintext.\n\n\n    chacha_1.streamXOR(this._key, counter, plaintext, result, 4); // Authenticate.\n    // XXX: can \"simplify\" here: pass full result (which is already padded\n    // due to zeroes prepared for tag), and ciphertext length instead of\n    // subarray of result.\n\n    this._authenticate(result.subarray(result.length - this.tagLength, result.length), authKey, result.subarray(0, result.length - this.tagLength), associatedData); // Cleanup.\n\n\n    wipe_1.wipe(counter);\n    return result;\n  };\n  /**\n   * Authenticates sealed ciphertext (which includes authentication tag) and\n   * associated data, decrypts ciphertext and returns decrypted plaintext.\n   *\n   * RFC7539 specifies 12 bytes for nonce. It may be this 12-byte nonce\n   * (\"IV\"), or full 16-byte counter (called \"32-bit fixed-common part\")\n   * and nonce.\n   *\n   * If authentication fails, it returns null.\n   *\n   * If dst is given (it must be of ciphertext length minus tag length),\n   * the result will be put into it. Dst and plaintext must not overlap.\n   */\n\n\n  ChaCha20Poly1305.prototype.open = function (nonce, sealed, associatedData, dst) {\n    if (nonce.length > 16) {\n      throw new Error(\"ChaCha20Poly1305: incorrect nonce length\");\n    } // Sealed ciphertext should at least contain tag.\n\n\n    if (sealed.length < this.tagLength) {\n      // TODO(dchest): should we throw here instead?\n      return null;\n    } // Allocate space for counter, and set nonce as last bytes of it.\n\n\n    var counter = new Uint8Array(16);\n    counter.set(nonce, counter.length - nonce.length); // Generate authentication key by taking first 32-bytes of stream.\n\n    var authKey = new Uint8Array(32);\n    chacha_1.stream(this._key, counter, authKey, 4); // Authenticate.\n    // XXX: can simplify and avoid allocation: since authenticate()\n    // already allocates tag (from Poly1305.digest(), it can return)\n    // it instead of copying to calculatedTag. But then in seal()\n    // we'll need to copy it.\n\n    var calculatedTag = new Uint8Array(this.tagLength);\n\n    this._authenticate(calculatedTag, authKey, sealed.subarray(0, sealed.length - this.tagLength), associatedData); // Constant-time compare tags and return null if they differ.\n\n\n    if (!constant_time_1.equal(calculatedTag, sealed.subarray(sealed.length - this.tagLength, sealed.length))) {\n      return null;\n    } // Allocate space for decrypted plaintext.\n\n\n    var resultLength = sealed.length - this.tagLength;\n    var result;\n\n    if (dst) {\n      if (dst.length !== resultLength) {\n        throw new Error(\"ChaCha20Poly1305: incorrect destination length\");\n      }\n\n      result = dst;\n    } else {\n      result = new Uint8Array(resultLength);\n    } // Decrypt.\n\n\n    chacha_1.streamXOR(this._key, counter, sealed.subarray(0, sealed.length - this.tagLength), result, 4); // Cleanup.\n\n    wipe_1.wipe(counter);\n    return result;\n  };\n\n  ChaCha20Poly1305.prototype.clean = function () {\n    wipe_1.wipe(this._key);\n    return this;\n  };\n\n  ChaCha20Poly1305.prototype._authenticate = function (tagOut, authKey, ciphertext, associatedData) {\n    // Initialize Poly1305 with authKey.\n    var h = new poly1305_1.Poly1305(authKey); // Authenticate padded associated data.\n\n    if (associatedData) {\n      h.update(associatedData);\n\n      if (associatedData.length % 16 > 0) {\n        h.update(ZEROS.subarray(associatedData.length % 16));\n      }\n    } // Authenticate padded ciphertext.\n\n\n    h.update(ciphertext);\n\n    if (ciphertext.length % 16 > 0) {\n      h.update(ZEROS.subarray(ciphertext.length % 16));\n    } // Authenticate length of associated data.\n    // XXX: can avoid allocation here?\n\n\n    var length = new Uint8Array(8);\n\n    if (associatedData) {\n      binary_1.writeUint64LE(associatedData.length, length);\n    }\n\n    h.update(length); // Authenticate length of ciphertext.\n\n    binary_1.writeUint64LE(ciphertext.length, length);\n    h.update(length); // Get tag and copy it into tagOut.\n\n    var tag = h.digest();\n\n    for (var i = 0; i < tag.length; i++) {\n      tagOut[i] = tag[i];\n    } // Cleanup.\n\n\n    h.clean();\n    wipe_1.wipe(tag);\n    wipe_1.wipe(length);\n  };\n\n  return ChaCha20Poly1305;\n}();\n\nexports.ChaCha20Poly1305 = ChaCha20Poly1305;","map":{"version":3,"sources":["../chacha20poly1305.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar chacha_1 = require(\"@stablelib/chacha\");\nvar poly1305_1 = require(\"@stablelib/poly1305\");\nvar wipe_1 = require(\"@stablelib/wipe\");\nvar binary_1 = require(\"@stablelib/binary\");\nvar constant_time_1 = require(\"@stablelib/constant-time\");\nexports.KEY_LENGTH = 32;\nexports.NONCE_LENGTH = 12;\nexports.TAG_LENGTH = 16;\nvar ZEROS = new Uint8Array(16);\n/**\n * ChaCha20-Poly1305 Authenticated Encryption with Associated Data.\n *\n * Defined in RFC7539.\n */\nvar ChaCha20Poly1305 = /** @class */ (function () {\n    /**\n     * Creates a new instance with the given 32-byte key.\n     */\n    function ChaCha20Poly1305(key) {\n        this.nonceLength = exports.NONCE_LENGTH;\n        this.tagLength = exports.TAG_LENGTH;\n        if (key.length !== exports.KEY_LENGTH) {\n            throw new Error(\"ChaCha20Poly1305 needs 32-byte key\");\n        }\n        // Copy key.\n        this._key = new Uint8Array(key);\n    }\n    /**\n     * Encrypts and authenticates plaintext, authenticates associated data,\n     * and returns sealed ciphertext, which includes authentication tag.\n     *\n     * RFC7539 specifies 12 bytes for nonce. It may be this 12-byte nonce\n     * (\"IV\"), or full 16-byte counter (called \"32-bit fixed-common part\")\n     * and nonce.\n     *\n     * If dst is given (it must be the size of plaintext + the size of tag\n     * length) the result will be put into it. Dst and plaintext must not\n     * overlap.\n     */\n    ChaCha20Poly1305.prototype.seal = function (nonce, plaintext, associatedData, dst) {\n        if (nonce.length > 16) {\n            throw new Error(\"ChaCha20Poly1305: incorrect nonce length\");\n        }\n        // Allocate space for counter, and set nonce as last bytes of it.\n        var counter = new Uint8Array(16);\n        counter.set(nonce, counter.length - nonce.length);\n        // Generate authentication key by taking first 32-bytes of stream.\n        // We pass full counter, which has 12-byte nonce and 4-byte block counter,\n        // and it will get incremented after generating the block, which is\n        // exactly what we need: we only use the first 32 bytes of 64-byte\n        // ChaCha block and discard the next 32 bytes.\n        var authKey = new Uint8Array(32);\n        chacha_1.stream(this._key, counter, authKey, 4);\n        // Allocate space for sealed ciphertext.\n        var resultLength = plaintext.length + this.tagLength;\n        var result;\n        if (dst) {\n            if (dst.length !== resultLength) {\n                throw new Error(\"ChaCha20Poly1305: incorrect destination length\");\n            }\n            result = dst;\n        }\n        else {\n            result = new Uint8Array(resultLength);\n        }\n        // Encrypt plaintext.\n        chacha_1.streamXOR(this._key, counter, plaintext, result, 4);\n        // Authenticate.\n        // XXX: can \"simplify\" here: pass full result (which is already padded\n        // due to zeroes prepared for tag), and ciphertext length instead of\n        // subarray of result.\n        this._authenticate(result.subarray(result.length - this.tagLength, result.length), authKey, result.subarray(0, result.length - this.tagLength), associatedData);\n        // Cleanup.\n        wipe_1.wipe(counter);\n        return result;\n    };\n    /**\n     * Authenticates sealed ciphertext (which includes authentication tag) and\n     * associated data, decrypts ciphertext and returns decrypted plaintext.\n     *\n     * RFC7539 specifies 12 bytes for nonce. It may be this 12-byte nonce\n     * (\"IV\"), or full 16-byte counter (called \"32-bit fixed-common part\")\n     * and nonce.\n     *\n     * If authentication fails, it returns null.\n     *\n     * If dst is given (it must be of ciphertext length minus tag length),\n     * the result will be put into it. Dst and plaintext must not overlap.\n     */\n    ChaCha20Poly1305.prototype.open = function (nonce, sealed, associatedData, dst) {\n        if (nonce.length > 16) {\n            throw new Error(\"ChaCha20Poly1305: incorrect nonce length\");\n        }\n        // Sealed ciphertext should at least contain tag.\n        if (sealed.length < this.tagLength) {\n            // TODO(dchest): should we throw here instead?\n            return null;\n        }\n        // Allocate space for counter, and set nonce as last bytes of it.\n        var counter = new Uint8Array(16);\n        counter.set(nonce, counter.length - nonce.length);\n        // Generate authentication key by taking first 32-bytes of stream.\n        var authKey = new Uint8Array(32);\n        chacha_1.stream(this._key, counter, authKey, 4);\n        // Authenticate.\n        // XXX: can simplify and avoid allocation: since authenticate()\n        // already allocates tag (from Poly1305.digest(), it can return)\n        // it instead of copying to calculatedTag. But then in seal()\n        // we'll need to copy it.\n        var calculatedTag = new Uint8Array(this.tagLength);\n        this._authenticate(calculatedTag, authKey, sealed.subarray(0, sealed.length - this.tagLength), associatedData);\n        // Constant-time compare tags and return null if they differ.\n        if (!constant_time_1.equal(calculatedTag, sealed.subarray(sealed.length - this.tagLength, sealed.length))) {\n            return null;\n        }\n        // Allocate space for decrypted plaintext.\n        var resultLength = sealed.length - this.tagLength;\n        var result;\n        if (dst) {\n            if (dst.length !== resultLength) {\n                throw new Error(\"ChaCha20Poly1305: incorrect destination length\");\n            }\n            result = dst;\n        }\n        else {\n            result = new Uint8Array(resultLength);\n        }\n        // Decrypt.\n        chacha_1.streamXOR(this._key, counter, sealed.subarray(0, sealed.length - this.tagLength), result, 4);\n        // Cleanup.\n        wipe_1.wipe(counter);\n        return result;\n    };\n    ChaCha20Poly1305.prototype.clean = function () {\n        wipe_1.wipe(this._key);\n        return this;\n    };\n    ChaCha20Poly1305.prototype._authenticate = function (tagOut, authKey, ciphertext, associatedData) {\n        // Initialize Poly1305 with authKey.\n        var h = new poly1305_1.Poly1305(authKey);\n        // Authenticate padded associated data.\n        if (associatedData) {\n            h.update(associatedData);\n            if (associatedData.length % 16 > 0) {\n                h.update(ZEROS.subarray(associatedData.length % 16));\n            }\n        }\n        // Authenticate padded ciphertext.\n        h.update(ciphertext);\n        if (ciphertext.length % 16 > 0) {\n            h.update(ZEROS.subarray(ciphertext.length % 16));\n        }\n        // Authenticate length of associated data.\n        // XXX: can avoid allocation here?\n        var length = new Uint8Array(8);\n        if (associatedData) {\n            binary_1.writeUint64LE(associatedData.length, length);\n        }\n        h.update(length);\n        // Authenticate length of ciphertext.\n        binary_1.writeUint64LE(ciphertext.length, length);\n        h.update(length);\n        // Get tag and copy it into tagOut.\n        var tag = h.digest();\n        for (var i = 0; i < tag.length; i++) {\n            tagOut[i] = tag[i];\n        }\n        // Cleanup.\n        h.clean();\n        wipe_1.wipe(tag);\n        wipe_1.wipe(length);\n    };\n    return ChaCha20Poly1305;\n}());\nexports.ChaCha20Poly1305 = ChaCha20Poly1305;\n//# sourceMappingURL=chacha20poly1305.js.map"]},"metadata":{},"sourceType":"script"}