{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.XXHandshake = void 0;\n\nconst buffer_1 = require(\"buffer\");\n\nconst xx_1 = require(\"./handshakes/xx\");\n\nconst utils_1 = require(\"./utils\");\n\nconst logger_1 = require(\"./logger\");\n\nconst encoder_1 = require(\"./encoder\");\n\nclass XXHandshake {\n  constructor(isInitiator, payload, prologue, staticKeypair, connection, remotePeer, handshake) {\n    this.isInitiator = isInitiator;\n    this.payload = payload;\n    this.prologue = prologue;\n    this.staticKeypair = staticKeypair;\n    this.connection = connection;\n\n    if (remotePeer) {\n      this.remotePeer = remotePeer;\n    }\n\n    this.xx = handshake !== null && handshake !== void 0 ? handshake : new xx_1.XX();\n    this.session = this.xx.initSession(this.isInitiator, this.prologue, this.staticKeypair);\n    this.remoteEarlyData = buffer_1.Buffer.alloc(0);\n  } // stage 0\n\n\n  async propose() {\n    logger_1.logLocalStaticKeys(this.session.hs.s);\n\n    if (this.isInitiator) {\n      logger_1.logger('Stage 0 - Initiator starting to send first message.');\n      const messageBuffer = this.xx.sendMessage(this.session, buffer_1.Buffer.alloc(0));\n      this.connection.writeLP(encoder_1.encode0(messageBuffer));\n      logger_1.logger('Stage 0 - Initiator finished sending first message.');\n      logger_1.logLocalEphemeralKeys(this.session.hs.e);\n    } else {\n      logger_1.logger('Stage 0 - Responder waiting to receive first message...');\n      const receivedMessageBuffer = encoder_1.decode0((await this.connection.readLP()).slice());\n      const {\n        valid\n      } = this.xx.recvMessage(this.session, receivedMessageBuffer);\n\n      if (!valid) {\n        throw new Error('xx handshake stage 0 validation fail');\n      }\n\n      logger_1.logger('Stage 0 - Responder received first message.');\n      logger_1.logRemoteEphemeralKey(this.session.hs.re);\n    }\n  } // stage 1\n\n\n  async exchange() {\n    if (this.isInitiator) {\n      logger_1.logger('Stage 1 - Initiator waiting to receive first message from responder...');\n      const receivedMessageBuffer = encoder_1.decode1((await this.connection.readLP()).slice());\n      const {\n        plaintext,\n        valid\n      } = this.xx.recvMessage(this.session, receivedMessageBuffer);\n\n      if (!valid) {\n        throw new Error('xx handshake stage 1 validation fail');\n      }\n\n      logger_1.logger('Stage 1 - Initiator received the message.');\n      logger_1.logRemoteEphemeralKey(this.session.hs.re);\n      logger_1.logRemoteStaticKey(this.session.hs.rs);\n      logger_1.logger(\"Initiator going to check remote's signature...\");\n\n      try {\n        const decodedPayload = await utils_1.decodePayload(plaintext);\n        this.remotePeer = this.remotePeer || (await utils_1.getPeerIdFromPayload(decodedPayload));\n        this.remotePeer = await utils_1.verifySignedPayload(receivedMessageBuffer.ns, decodedPayload, this.remotePeer);\n        this.setRemoteEarlyData(decodedPayload.data);\n      } catch (e) {\n        const err = e;\n        throw new Error(`Error occurred while verifying signed payload: ${err.message}`);\n      }\n\n      logger_1.logger('All good with the signature!');\n    } else {\n      logger_1.logger('Stage 1 - Responder sending out first message with signed payload and static key.');\n      const messageBuffer = this.xx.sendMessage(this.session, this.payload);\n      this.connection.writeLP(encoder_1.encode1(messageBuffer));\n      logger_1.logger('Stage 1 - Responder sent the second handshake message with signed payload.');\n      logger_1.logLocalEphemeralKeys(this.session.hs.e);\n    }\n  } // stage 2\n\n\n  async finish() {\n    if (this.isInitiator) {\n      logger_1.logger('Stage 2 - Initiator sending third handshake message.');\n      const messageBuffer = this.xx.sendMessage(this.session, this.payload);\n      this.connection.writeLP(encoder_1.encode2(messageBuffer));\n      logger_1.logger('Stage 2 - Initiator sent message with signed payload.');\n    } else {\n      logger_1.logger('Stage 2 - Responder waiting for third handshake message...');\n      const receivedMessageBuffer = encoder_1.decode2((await this.connection.readLP()).slice());\n      const {\n        plaintext,\n        valid\n      } = this.xx.recvMessage(this.session, receivedMessageBuffer);\n\n      if (!valid) {\n        throw new Error('xx handshake stage 2 validation fail');\n      }\n\n      logger_1.logger('Stage 2 - Responder received the message, finished handshake.');\n\n      try {\n        const decodedPayload = await utils_1.decodePayload(plaintext);\n        this.remotePeer = this.remotePeer || (await utils_1.getPeerIdFromPayload(decodedPayload));\n        await utils_1.verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);\n        this.setRemoteEarlyData(decodedPayload.data);\n      } catch (e) {\n        const err = e;\n        throw new Error(`Error occurred while verifying signed payload: ${err.message}`);\n      }\n    }\n\n    logger_1.logCipherState(this.session);\n  }\n\n  encrypt(plaintext, session) {\n    const cs = this.getCS(session);\n    return this.xx.encryptWithAd(cs, buffer_1.Buffer.alloc(0), plaintext);\n  }\n\n  decrypt(ciphertext, session) {\n    const cs = this.getCS(session, false);\n    return this.xx.decryptWithAd(cs, buffer_1.Buffer.alloc(0), ciphertext);\n  }\n\n  getRemoteStaticKey() {\n    return this.session.hs.rs;\n  }\n\n  getCS(session, encryption = true) {\n    if (!session.cs1 || !session.cs2) {\n      throw new Error('Handshake not completed properly, cipher state does not exist.');\n    }\n\n    if (this.isInitiator) {\n      return encryption ? session.cs1 : session.cs2;\n    } else {\n      return encryption ? session.cs2 : session.cs1;\n    }\n  }\n\n  setRemoteEarlyData(data) {\n    if (data) {\n      this.remoteEarlyData = buffer_1.Buffer.from(data.buffer, data.byteOffset, data.length);\n    }\n  }\n\n}\n\nexports.XXHandshake = XXHandshake;","map":{"version":3,"sources":["../../src/handshake-xx.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.XXHandshake = void 0;\nconst buffer_1 = require(\"buffer\");\nconst xx_1 = require(\"./handshakes/xx\");\nconst utils_1 = require(\"./utils\");\nconst logger_1 = require(\"./logger\");\nconst encoder_1 = require(\"./encoder\");\nclass XXHandshake {\n    constructor(isInitiator, payload, prologue, staticKeypair, connection, remotePeer, handshake) {\n        this.isInitiator = isInitiator;\n        this.payload = payload;\n        this.prologue = prologue;\n        this.staticKeypair = staticKeypair;\n        this.connection = connection;\n        if (remotePeer) {\n            this.remotePeer = remotePeer;\n        }\n        this.xx = handshake !== null && handshake !== void 0 ? handshake : new xx_1.XX();\n        this.session = this.xx.initSession(this.isInitiator, this.prologue, this.staticKeypair);\n        this.remoteEarlyData = buffer_1.Buffer.alloc(0);\n    }\n    // stage 0\n    async propose() {\n        logger_1.logLocalStaticKeys(this.session.hs.s);\n        if (this.isInitiator) {\n            logger_1.logger('Stage 0 - Initiator starting to send first message.');\n            const messageBuffer = this.xx.sendMessage(this.session, buffer_1.Buffer.alloc(0));\n            this.connection.writeLP(encoder_1.encode0(messageBuffer));\n            logger_1.logger('Stage 0 - Initiator finished sending first message.');\n            logger_1.logLocalEphemeralKeys(this.session.hs.e);\n        }\n        else {\n            logger_1.logger('Stage 0 - Responder waiting to receive first message...');\n            const receivedMessageBuffer = encoder_1.decode0((await this.connection.readLP()).slice());\n            const { valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);\n            if (!valid) {\n                throw new Error('xx handshake stage 0 validation fail');\n            }\n            logger_1.logger('Stage 0 - Responder received first message.');\n            logger_1.logRemoteEphemeralKey(this.session.hs.re);\n        }\n    }\n    // stage 1\n    async exchange() {\n        if (this.isInitiator) {\n            logger_1.logger('Stage 1 - Initiator waiting to receive first message from responder...');\n            const receivedMessageBuffer = encoder_1.decode1((await this.connection.readLP()).slice());\n            const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);\n            if (!valid) {\n                throw new Error('xx handshake stage 1 validation fail');\n            }\n            logger_1.logger('Stage 1 - Initiator received the message.');\n            logger_1.logRemoteEphemeralKey(this.session.hs.re);\n            logger_1.logRemoteStaticKey(this.session.hs.rs);\n            logger_1.logger(\"Initiator going to check remote's signature...\");\n            try {\n                const decodedPayload = await utils_1.decodePayload(plaintext);\n                this.remotePeer = this.remotePeer || await utils_1.getPeerIdFromPayload(decodedPayload);\n                this.remotePeer = await utils_1.verifySignedPayload(receivedMessageBuffer.ns, decodedPayload, this.remotePeer);\n                this.setRemoteEarlyData(decodedPayload.data);\n            }\n            catch (e) {\n                const err = e;\n                throw new Error(`Error occurred while verifying signed payload: ${err.message}`);\n            }\n            logger_1.logger('All good with the signature!');\n        }\n        else {\n            logger_1.logger('Stage 1 - Responder sending out first message with signed payload and static key.');\n            const messageBuffer = this.xx.sendMessage(this.session, this.payload);\n            this.connection.writeLP(encoder_1.encode1(messageBuffer));\n            logger_1.logger('Stage 1 - Responder sent the second handshake message with signed payload.');\n            logger_1.logLocalEphemeralKeys(this.session.hs.e);\n        }\n    }\n    // stage 2\n    async finish() {\n        if (this.isInitiator) {\n            logger_1.logger('Stage 2 - Initiator sending third handshake message.');\n            const messageBuffer = this.xx.sendMessage(this.session, this.payload);\n            this.connection.writeLP(encoder_1.encode2(messageBuffer));\n            logger_1.logger('Stage 2 - Initiator sent message with signed payload.');\n        }\n        else {\n            logger_1.logger('Stage 2 - Responder waiting for third handshake message...');\n            const receivedMessageBuffer = encoder_1.decode2((await this.connection.readLP()).slice());\n            const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);\n            if (!valid) {\n                throw new Error('xx handshake stage 2 validation fail');\n            }\n            logger_1.logger('Stage 2 - Responder received the message, finished handshake.');\n            try {\n                const decodedPayload = await utils_1.decodePayload(plaintext);\n                this.remotePeer = this.remotePeer || await utils_1.getPeerIdFromPayload(decodedPayload);\n                await utils_1.verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);\n                this.setRemoteEarlyData(decodedPayload.data);\n            }\n            catch (e) {\n                const err = e;\n                throw new Error(`Error occurred while verifying signed payload: ${err.message}`);\n            }\n        }\n        logger_1.logCipherState(this.session);\n    }\n    encrypt(plaintext, session) {\n        const cs = this.getCS(session);\n        return this.xx.encryptWithAd(cs, buffer_1.Buffer.alloc(0), plaintext);\n    }\n    decrypt(ciphertext, session) {\n        const cs = this.getCS(session, false);\n        return this.xx.decryptWithAd(cs, buffer_1.Buffer.alloc(0), ciphertext);\n    }\n    getRemoteStaticKey() {\n        return this.session.hs.rs;\n    }\n    getCS(session, encryption = true) {\n        if (!session.cs1 || !session.cs2) {\n            throw new Error('Handshake not completed properly, cipher state does not exist.');\n        }\n        if (this.isInitiator) {\n            return encryption ? session.cs1 : session.cs2;\n        }\n        else {\n            return encryption ? session.cs2 : session.cs1;\n        }\n    }\n    setRemoteEarlyData(data) {\n        if (data) {\n            this.remoteEarlyData = buffer_1.Buffer.from(data.buffer, data.byteOffset, data.length);\n        }\n    }\n}\nexports.XXHandshake = XXHandshake;\n//# sourceMappingURL=handshake-xx.js.map"]},"metadata":{},"sourceType":"script"}