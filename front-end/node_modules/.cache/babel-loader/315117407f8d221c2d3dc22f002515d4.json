{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nconst pubsub_1 = __importStar(require(\"libp2p-interfaces/src/pubsub\"));\n\nconst message_cache_1 = require(\"./message-cache\");\n\nconst rpc_1 = require(\"./message/rpc\");\n\nconst constants = __importStar(require(\"./constants\"));\n\nconst heartbeat_1 = require(\"./heartbeat\");\n\nconst get_gossip_peers_1 = require(\"./get-gossip-peers\");\n\nconst utils_1 = require(\"./utils\");\n\nconst score_1 = require(\"./score\");\n\nconst tracer_1 = require(\"./tracer\"); // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\n\n\nconst TimeCache = require(\"time-cache\");\n\nconst PeerId = require(\"peer-id\"); // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\n\n\nconst Envelope = require(\"libp2p/src/record/envelope\");\n\nclass Gossipsub extends pubsub_1.default {\n  // TODO: add remaining props\n\n  /**\n   * @param {Libp2p} libp2p\n   * @param {Object} [options]\n   * @param {boolean} [options.emitSelf = false] if publish should emit to self, if subscribed\n   * @param {boolean} [options.canRelayMessage = false] - if can relay messages not subscribed\n   * @param {boolean} [options.gossipIncoming = true] if incoming messages on a subscribed topic should be automatically gossiped\n   * @param {boolean} [options.fallbackToFloodsub = true] if dial should fallback to floodsub\n   * @param {boolean} [options.floodPublish = true] if self-published messages should be sent to all peers\n   * @param {boolean} [options.doPX = false] whether PX is enabled; this should be enabled in bootstrappers and other well connected/trusted nodes.\n   * @param {Object} [options.messageCache] override the default MessageCache\n   * @param {string} [options.globalSignaturePolicy = \"StrictSign\"] signing policy to apply across all messages\n   * @param {Object} [options.scoreParams] peer score parameters\n   * @param {Object} [options.scoreThresholds] peer score thresholds\n   * @param {AddrInfo[]} [options.directPeers] peers with which we will maintain direct connections\n   * @constructor\n   */\n  constructor(libp2p, options = {}) {\n    const multicodecs = [constants.GossipsubIDv11, constants.GossipsubIDv10];\n    const opts = Object.assign(Object.assign({\n      gossipIncoming: true,\n      fallbackToFloodsub: true,\n      floodPublish: true,\n      doPX: false,\n      directPeers: [],\n      D: constants.GossipsubD,\n      Dlo: constants.GossipsubDlo,\n      Dhi: constants.GossipsubDhi,\n      Dscore: constants.GossipsubDscore,\n      Dout: constants.GossipsubDout,\n      Dlazy: constants.GossipsubDlazy\n    }, options), {\n      scoreParams: score_1.createPeerScoreParams(options.scoreParams),\n      scoreThresholds: score_1.createPeerScoreThresholds(options.scoreThresholds)\n    }); // Also wants to get notified of peers connected using floodsub\n\n    if (opts.fallbackToFloodsub) {\n      multicodecs.push(constants.FloodsubID);\n    }\n\n    super(Object.assign({\n      debugName: 'libp2p:gossipsub',\n      multicodecs,\n      libp2p\n    }, opts));\n    this._options = opts;\n    /**\n     * Direct peers\n     * @type {Set<string>}\n     */\n\n    this.direct = new Set(opts.directPeers.map(p => p.id.toB58String())); // set direct peer addresses in the address book\n\n    opts.directPeers.forEach(p => {\n      libp2p.peerStore.addressBook.add(p.id, p.addrs);\n    });\n    /**\n     * Cache of seen messages\n     *\n     * @type {TimeCache}\n     */\n\n    this.seenCache = new TimeCache();\n    /**\n     * Map of topic meshes\n     * topic => peer id set\n     *\n     * @type {Map<string, Set<string>>}\n     */\n\n    this.mesh = new Map();\n    /**\n     * Map of topics to set of peers. These mesh peers are the ones to which we are publishing without a topic membership\n     * topic => peer id set\n     *\n     * @type {Map<string, Set<string>>}\n     */\n\n    this.fanout = new Map();\n    /**\n     * Map of last publish time for fanout topics\n     * topic => last publish time\n     *\n     * @type {Map<string, number>}\n     */\n\n    this.lastpub = new Map();\n    /**\n     * Map of pending messages to gossip\n     * peer id => control messages\n     *\n     * @type {Map<string, Array<RPC.IControlIHave object>> }\n     */\n\n    this.gossip = new Map();\n    /**\n     * Map of control messages\n     * peer id => control message\n     *\n     * @type {Map<string, RPC.IControlMessage object>}\n     */\n\n    this.control = new Map();\n    /**\n     * Number of IHAVEs received from peer in the last heartbeat\n     * @type {Map<string, number>}\n     */\n\n    this.peerhave = new Map();\n    /**\n     * Number of messages we have asked from peer in the last heartbeat\n     * @type {Map<string, number>}\n     */\n\n    this.iasked = new Map();\n    /**\n     * Prune backoff map\n     */\n\n    this.backoff = new Map();\n    /**\n     * Connection direction cache, marks peers with outbound connections\n     * peer id => direction\n     *\n     * @type {Map<string, boolean>}\n     */\n\n    this.outbound = new Map();\n    /**\n     * A message cache that contains the messages for last few hearbeat ticks\n     *\n     */\n\n    this.messageCache = options.messageCache || new message_cache_1.MessageCache(constants.GossipsubHistoryGossip, constants.GossipsubHistoryLength, this.getMsgId.bind(this));\n    /**\n     * A heartbeat timer that maintains the mesh\n     */\n\n    this.heartbeat = new heartbeat_1.Heartbeat(this);\n    /**\n     * Number of heartbeats since the beginning of time\n     * This allows us to amortize some resource cleanup -- eg: backoff cleanup\n     */\n\n    this.heartbeatTicks = 0;\n    /**\n     * Tracks IHAVE/IWANT promises broken by peers\n     */\n\n    this.gossipTracer = new tracer_1.IWantTracer(this.getMsgId.bind(this));\n    /**\n     * libp2p\n     */\n\n    this._libp2p = libp2p;\n    /**\n     * Peer score tracking\n     */\n\n    this.score = new score_1.PeerScore(this._options.scoreParams, libp2p.connectionManager, this.getMsgId.bind(this));\n  }\n  /**\n   * Decode a Uint8Array into an RPC object\n   * Overrided to use an extended protocol-specific protobuf decoder\n   * @override\n   * @param {Uint8Array} bytes\n   * @returns {RPC}\n   */\n\n\n  _decodeRpc(bytes) {\n    return rpc_1.RPC.decode(bytes);\n  }\n  /**\n   * Encode an RPC object into a Uint8Array\n   * Overrided to use an extended protocol-specific protobuf encoder\n   * @override\n   * @param {RPC} rpc\n   * @returns {Uint8Array}\n   */\n\n\n  _encodeRpc(rpc) {\n    return rpc_1.RPC.encode(rpc).finish();\n  }\n  /**\n   * Add a peer to the router\n   * @override\n   * @param {PeerId} peerId\n   * @param {string} protocol\n   * @returns {PeerStreams}\n   */\n\n\n  _addPeer(peerId, protocol) {\n    const p = super._addPeer(peerId, protocol); // Add to peer scoring\n\n\n    this.score.addPeer(peerId.toB58String()); // track the connection direction\n\n    let outbound = false;\n\n    for (const c of this._libp2p.connectionManager.getAll(peerId)) {\n      if (c.stat.direction === 'outbound') {\n        if (Array.from(c.registry.values()).some(rvalue => protocol === rvalue.protocol)) {\n          outbound = true;\n          break;\n        }\n      }\n    }\n\n    this.outbound.set(p.id.toB58String(), outbound);\n    return p;\n  }\n  /**\n   * Removes a peer from the router\n   * @override\n   * @param {PeerId} peer\n   * @returns {PeerStreams | undefined}\n   */\n\n\n  _removePeer(peerId) {\n    const peerStreams = super._removePeer(peerId);\n\n    const id = peerId.toB58String(); // Remove this peer from the mesh\n    // eslint-disable-next-line no-unused-vars\n\n    for (const peers of this.mesh.values()) {\n      peers.delete(id);\n    } // Remove this peer from the fanout\n    // eslint-disable-next-line no-unused-vars\n\n\n    for (const peers of this.fanout.values()) {\n      peers.delete(id);\n    } // Remove from gossip mapping\n\n\n    this.gossip.delete(id); // Remove from control mapping\n\n    this.control.delete(id); // Remove from backoff mapping\n\n    this.outbound.delete(id); // Remove from peer scoring\n\n    this.score.removePeer(id);\n    return peerStreams;\n  }\n  /**\n   * Handles an rpc request from a peer\n   *\n   * @override\n   * @param {String} idB58Str\n   * @param {PeerStreams} peerStreams\n   * @param {RPC} rpc\n   * @returns {Promise<boolean>}\n   */\n\n\n  _processRpc(id, peerStreams, rpc) {\n    const _super = Object.create(null, {\n      _processRpc: {\n        get: () => super._processRpc\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (yield _super._processRpc.call(this, id, peerStreams, rpc)) {\n        if (rpc.control) {\n          this._processRpcControlMessage(id, rpc.control);\n        }\n\n        return true;\n      }\n\n      return false;\n    });\n  }\n  /**\n   * Handles an rpc control message from a peer\n   * @param {string} id peer id\n   * @param {RPC.IControlMessage} controlMsg\n   * @returns {void}\n   */\n\n\n  _processRpcControlMessage(id, controlMsg) {\n    if (!controlMsg) {\n      return;\n    }\n\n    const iwant = controlMsg.ihave ? this._handleIHave(id, controlMsg.ihave) : [];\n    const ihave = controlMsg.iwant ? this._handleIWant(id, controlMsg.iwant) : [];\n    const prune = controlMsg.graft ? this._handleGraft(id, controlMsg.graft) : [];\n    controlMsg.prune && this._handlePrune(id, controlMsg.prune);\n\n    if (!iwant.length && !ihave.length && !prune.length) {\n      return;\n    }\n\n    const outRpc = utils_1.createGossipRpc(ihave, {\n      iwant,\n      prune\n    });\n\n    this._sendRpc(id, outRpc);\n  }\n  /**\n   * Process incoming message,\n   * emitting locally and forwarding on to relevant floodsub and gossipsub peers\n   * @override\n   * @param {InMessage} msg\n   * @returns {Promise<void>}\n   */\n\n\n  _processRpcMessage(msg) {\n    const _super = Object.create(null, {\n      _processRpcMessage: {\n        get: () => super._processRpcMessage\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const msgID = yield this.getMsgId(msg);\n      const msgIdStr = utils_1.messageIdToString(msgID); // Ignore if we've already seen the message\n\n      if (this.seenCache.has(msgIdStr)) {\n        this.score.duplicateMessage(msg);\n        return;\n      }\n\n      this.seenCache.put(msgIdStr);\n      yield this.score.validateMessage(msg);\n      yield _super._processRpcMessage.call(this, msg);\n    });\n  }\n  /**\n   * Whether to accept a message from a peer\n   * @override\n   * @param {string} id\n   * @returns {boolean}\n   */\n\n\n  _acceptFrom(id) {\n    return this.direct.has(id) || this.score.score(id) >= this._options.scoreThresholds.graylistThreshold;\n  }\n  /**\n   * Validate incoming message\n   * @override\n   * @param {InMessage} message\n   * @returns {Promise<void>}\n   */\n\n\n  validate(message) {\n    const _super = Object.create(null, {\n      validate: {\n        get: () => super.validate\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield _super.validate.call(this, message);\n      } catch (e) {\n        this.score.rejectMessage(message, e.code);\n        this.gossipTracer.rejectMessage(message, e.code);\n        throw e;\n      }\n    });\n  }\n  /**\n   * Handles IHAVE messages\n   * @param {string} id peer id\n   * @param {Array<RPC.IControlIHave>} ihave\n   * @returns {RPC.IControlIWant}\n   */\n\n\n  _handleIHave(id, ihave) {\n    if (!ihave.length) {\n      return [];\n    } // we ignore IHAVE gossip from any peer whose score is below the gossips threshold\n\n\n    const score = this.score.score(id);\n\n    if (score < this._options.scoreThresholds.gossipThreshold) {\n      this.log('IHAVE: ignoring peer %s with score below threshold [ score = %d ]', id, score);\n      return [];\n    } // IHAVE flood protection\n\n\n    const peerhave = (this.peerhave.get(id) || 0) + 1;\n    this.peerhave.set(id, peerhave);\n\n    if (peerhave > constants.GossipsubMaxIHaveMessages) {\n      this.log('IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring', id, peerhave);\n      return [];\n    }\n\n    const iasked = this.iasked.get(id) || 0;\n\n    if (iasked >= constants.GossipsubMaxIHaveLength) {\n      this.log('IHAVE: peer %s has already advertised too many messages (%d); ignoring', id, iasked);\n      return [];\n    } // string msgId => msgId\n\n\n    const iwant = new Map();\n    ihave.forEach(({\n      topicID,\n      messageIDs\n    }) => {\n      if (!topicID || !messageIDs || !this.mesh.has(topicID)) {\n        return;\n      }\n\n      messageIDs.forEach(msgID => {\n        const msgIdStr = utils_1.messageIdToString(msgID);\n\n        if (this.seenCache.has(msgIdStr)) {\n          return;\n        }\n\n        iwant.set(msgIdStr, msgID);\n      });\n    });\n\n    if (!iwant.size) {\n      return [];\n    }\n\n    let iask = iwant.size;\n\n    if (iask + iasked > constants.GossipsubMaxIHaveLength) {\n      iask = constants.GossipsubMaxIHaveLength - iasked;\n    }\n\n    this.log('IHAVE: Asking for %d out of %d messages from %s', iask, iwant.size, id);\n    let iwantList = Array.from(iwant.values()); // ask in random order\n\n    utils_1.shuffle(iwantList); // truncate to the messages we are actually asking for and update the iasked counter\n\n    iwantList = iwantList.slice(0, iask);\n    this.iasked.set(id, iasked + iask);\n    this.gossipTracer.addPromise(id, iwantList);\n    return [{\n      messageIDs: iwantList\n    }];\n  }\n  /**\n   * Handles IWANT messages\n   * Returns messages to send back to peer\n   * @param {string} id peer id\n   * @param {Array<RPC.IControlIWant>} iwant\n   * @returns {Array<RPC.IMessage>}\n   */\n\n\n  _handleIWant(id, iwant) {\n    if (!iwant.length) {\n      return [];\n    } // we don't respond to IWANT requests from any per whose score is below the gossip threshold\n\n\n    const score = this.score.score(id);\n\n    if (score < this._options.scoreThresholds.gossipThreshold) {\n      this.log('IWANT: ignoring peer %s with score below threshold [score = %d]', id, score);\n      return [];\n    } // @type {Map<string, Message>}\n\n\n    const ihave = new Map();\n    iwant.forEach(({\n      messageIDs\n    }) => {\n      messageIDs && messageIDs.forEach(msgID => {\n        const [msg, count] = this.messageCache.getForPeer(msgID, id);\n\n        if (!msg) {\n          return;\n        }\n\n        if (count > constants.GossipsubGossipRetransmission) {\n          this.log('IWANT: Peer %s has asked for message %s too many times: ignoring request', id, msgID);\n          return;\n        }\n\n        ihave.set(utils_1.messageIdToString(msgID), msg);\n      });\n    });\n\n    if (!ihave.size) {\n      return [];\n    }\n\n    this.log('IWANT: Sending %d messages to %s', ihave.size, id);\n    return Array.from(ihave.values()).map(pubsub_1.utils.normalizeOutRpcMessage);\n  }\n  /**\n   * Handles Graft messages\n   * @param {string} id peer id\n   * @param {Array<RPC.IControlGraft>} graft\n   * @return {Array<RPC.IControlPrune>}\n   */\n\n\n  _handleGraft(id, graft) {\n    const prune = [];\n    const score = this.score.score(id);\n\n    const now = this._now();\n\n    let doPX = this._options.doPX;\n    graft.forEach(({\n      topicID\n    }) => {\n      var _a;\n\n      if (!topicID) {\n        return;\n      }\n\n      const peersInMesh = this.mesh.get(topicID);\n\n      if (!peersInMesh) {\n        // don't do PX when there is an unknown topic to avoid leaking our peers\n        doPX = false; // spam hardening: ignore GRAFTs for unknown topics\n\n        return;\n      } // check if peer is already in the mesh; if so do nothing\n\n\n      if (peersInMesh.has(id)) {\n        return;\n      } // we don't GRAFT to/from direct peers; complain loudly if this happens\n\n\n      if (this.direct.has(id)) {\n        this.log('GRAFT: ignoring request from direct peer %s', id); // this is possibly a bug from a non-reciprical configuration; send a PRUNE\n\n        prune.push(topicID); // but don't px\n\n        doPX = false;\n        return;\n      } // make sure we are not backing off that peer\n\n\n      const expire = (_a = this.backoff.get(topicID)) === null || _a === void 0 ? void 0 : _a.get(id);\n\n      if (typeof expire === 'number' && now < expire) {\n        this.log('GRAFT: ignoring backed off peer %s', id); // add behavioral penalty\n\n        this.score.addPenalty(id, 1); // no PX\n\n        doPX = false; // check the flood cutoff -- is the GRAFT coming too fast?\n\n        const floodCutoff = expire + constants.GossipsubGraftFloodThreshold - constants.GossipsubPruneBackoff;\n\n        if (now < floodCutoff) {\n          // extra penalty\n          this.score.addPenalty(id, 1);\n        } // refresh the backoff\n\n\n        this._addBackoff(id, topicID);\n\n        prune.push(topicID);\n        return;\n      } // check the score\n\n\n      if (score < 0) {\n        // we don't GRAFT peers with negative score\n        this.log('GRAFT: ignoring peer %s with negative score: score=%d, topic=%s', id, score, topicID); // we do send them PRUNE however, because it's a matter of protocol correctness\n\n        prune.push(topicID); // but we won't PX to them\n\n        doPX = false; // add/refresh backoff so that we don't reGRAFT too early even if the score decays\n\n        this._addBackoff(id, topicID);\n\n        return;\n      } // check the number of mesh peers; if it is at (or over) Dhi, we only accept grafts\n      // from peers with outbound connections; this is a defensive check to restrict potential\n      // mesh takeover attacks combined with love bombing\n\n\n      if (peersInMesh.size >= this._options.Dhi && !this.outbound.get(id)) {\n        prune.push(topicID);\n\n        this._addBackoff(id, topicID);\n\n        return;\n      }\n\n      this.log('GRAFT: Add mesh link from %s in %s', id, topicID);\n      this.score.graft(id, topicID);\n      peersInMesh.add(id);\n    });\n\n    if (!prune.length) {\n      return [];\n    }\n\n    return prune.map(topic => this._makePrune(id, topic, doPX));\n  }\n  /**\n   * Handles Prune messages\n   * @param {string} id peer id\n   * @param {Array<RPC.IControlPrune>} prune\n   * @returns {void}\n   */\n\n\n  _handlePrune(id, prune) {\n    const score = this.score.score(id);\n    prune.forEach(({\n      topicID,\n      backoff,\n      peers\n    }) => {\n      if (!topicID) {\n        return;\n      }\n\n      const peersInMesh = this.mesh.get(topicID);\n\n      if (!peersInMesh) {\n        return;\n      }\n\n      this.log('PRUNE: Remove mesh link to %s in %s', id, topicID);\n      this.score.prune(id, topicID);\n      peersInMesh.delete(id); // is there a backoff specified by the peer? if so obey it\n\n      if (typeof backoff === 'number' && backoff > 0) {\n        this._doAddBackoff(id, topicID, backoff * 1000);\n      } else {\n        this._addBackoff(id, topicID);\n      } // PX\n\n\n      if (peers && peers.length) {\n        // we ignore PX from peers with insufficient scores\n        if (score < this._options.scoreThresholds.acceptPXThreshold) {\n          this.log('PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]', id, score, topicID);\n          return;\n        }\n\n        this._pxConnect(peers);\n      }\n    });\n  }\n  /**\n   * Add standard backoff log for a peer in a topic\n   * @param {string} id\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  _addBackoff(id, topic) {\n    this._doAddBackoff(id, topic, constants.GossipsubPruneBackoff);\n  }\n  /**\n   * Add backoff expiry interval for a peer in a topic\n   * @param {string} id\n   * @param {string} topic\n   * @param {number} interval backoff duration in milliseconds\n   * @returns {void}\n   */\n\n\n  _doAddBackoff(id, topic, interval) {\n    let backoff = this.backoff.get(topic);\n\n    if (!backoff) {\n      backoff = new Map();\n      this.backoff.set(topic, backoff);\n    }\n\n    const expire = this._now() + interval;\n    const existingExpire = backoff.get(id) || 0;\n\n    if (existingExpire < expire) {\n      backoff.set(id, expire);\n    }\n  }\n  /**\n   * Apply penalties from broken IHAVE/IWANT promises\n   * @returns {void}\n   */\n\n\n  _applyIwantPenalties() {\n    this.gossipTracer.getBrokenPromises().forEach((count, p) => {\n      this.log('peer %s didn\\'t follow up in %d IWANT requests; adding penalty', p, count);\n      this.score.addPenalty(p, count);\n    });\n  }\n  /**\n   * Clear expired backoff expiries\n   * @returns {void}\n   */\n\n\n  _clearBackoff() {\n    // we only clear once every GossipsubPruneBackoffTicks ticks to avoid iterating over the maps too much\n    if (this.heartbeatTicks % constants.GossipsubPruneBackoffTicks !== 0) {\n      return;\n    }\n\n    const now = this._now();\n\n    this.backoff.forEach((backoff, topic) => {\n      backoff.forEach((expire, id) => {\n        if (expire < now) {\n          backoff.delete(id);\n        }\n      });\n\n      if (backoff.size === 0) {\n        this.backoff.delete(topic);\n      }\n    });\n  }\n  /**\n   * Maybe reconnect to direct peers\n   * @returns {void}\n   */\n\n\n  _directConnect() {\n    // we only do this every few ticks to allow pending connections to complete and account for\n    // restarts/downtime\n    if (this.heartbeatTicks % constants.GossipsubDirectConnectTicks !== 0) {\n      return;\n    }\n\n    const toconnect = [];\n    this.direct.forEach(id => {\n      const peer = this.peers.get(id);\n\n      if (!peer || !peer.isWritable) {\n        toconnect.push(id);\n      }\n    });\n\n    if (toconnect.length) {\n      toconnect.forEach(id => {\n        this._connect(id);\n      });\n    }\n  }\n  /**\n   * Maybe attempt connection given signed peer records\n   * @param {RPC.IPeerInfo[]} peers\n   * @returns {Promise<void>}\n   */\n\n\n  _pxConnect(peers) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (peers.length > constants.GossipsubPrunePeers) {\n        utils_1.shuffle(peers);\n        peers = peers.slice(0, constants.GossipsubPrunePeers);\n      }\n\n      const toconnect = [];\n      yield Promise.all(peers.map(pi => __awaiter(this, void 0, void 0, function* () {\n        if (!pi.peerID) {\n          return;\n        }\n\n        const p = PeerId.createFromBytes(pi.peerID);\n        const id = p.toB58String();\n\n        if (this.peers.has(id)) {\n          return;\n        }\n\n        if (!pi.signedPeerRecord) {\n          toconnect.push(id);\n          return;\n        } // The peer sent us a signed record\n        // This is not a record from the peer who sent the record, but another peer who is connected with it\n        // Ensure that it is valid\n\n\n        try {\n          const envelope = yield Envelope.openAndCertify(pi.signedPeerRecord, 'libp2p-peer-record');\n          const eid = envelope.peerId.toB58String();\n\n          if (id !== eid) {\n            this.log('bogus peer record obtained through px: peer ID %s doesn\\'t match expected peer %s', eid, id);\n            return;\n          }\n\n          if (!this._libp2p.peerStore.addressBook.consumePeerRecord(envelope)) {\n            this.log('bogus peer record obtained through px: could not add peer record to address book');\n            return;\n          }\n\n          toconnect.push(id);\n        } catch (e) {\n          this.log('bogus peer record obtained through px: invalid signature or not a peer record');\n        }\n      })));\n\n      if (!toconnect.length) {\n        return;\n      }\n\n      toconnect.forEach(id => this._connect(id));\n    });\n  }\n  /**\n   * Mounts the gossipsub protocol onto the libp2p node and sends our\n   * our subscriptions to every peer connected\n   * @override\n   * @returns {void}\n   */\n\n\n  start() {\n    super.start();\n    this.heartbeat.start();\n    this.score.start(); // connect to direct peers\n\n    this._directPeerInitial = setTimeout(() => {\n      this.direct.forEach(id => {\n        this._connect(id);\n      });\n    }, constants.GossipsubDirectConnectInitialDelay);\n  }\n  /**\n   * Unmounts the gossipsub protocol and shuts down every connection\n   * @override\n   * @returns {void}\n   */\n\n\n  stop() {\n    super.stop();\n    this.heartbeat.stop();\n    this.score.stop();\n    this.mesh = new Map();\n    this.fanout = new Map();\n    this.lastpub = new Map();\n    this.gossip = new Map();\n    this.control = new Map();\n    this.peerhave = new Map();\n    this.iasked = new Map();\n    this.backoff = new Map();\n    this.outbound = new Map();\n    this.gossipTracer.clear();\n    clearTimeout(this._directPeerInitial);\n  }\n  /**\n   * Connect to a peer using the gossipsub protocol\n   * @param {string} id\n   * @returns {void}\n   */\n\n\n  _connect(id) {\n    this.log('Initiating connection with %s', id);\n\n    this._libp2p.dialProtocol(PeerId.createFromB58String(id), this.multicodecs);\n  }\n  /**\n   * Subscribes to a topic\n   * @override\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  subscribe(topic) {\n    super.subscribe(topic);\n    this.join(topic);\n  }\n  /**\n   * Unsubscribe to a topic\n   * @override\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  unsubscribe(topic) {\n    super.unsubscribe(topic);\n    this.leave(topic);\n  }\n  /**\n   * Join topic\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  join(topic) {\n    if (!this.started) {\n      throw new Error('Gossipsub has not started');\n    }\n\n    this.log('JOIN %s', topic);\n    const fanoutPeers = this.fanout.get(topic);\n\n    if (fanoutPeers) {\n      // these peers have a score above the publish threshold, which may be negative\n      // so drop the ones with a negative score\n      fanoutPeers.forEach(id => {\n        if (this.score.score(id) < 0) {\n          fanoutPeers.delete(id);\n        }\n      });\n\n      if (fanoutPeers.size < this._options.D) {\n        // we need more peers; eager, as this would get fixed in the next heartbeat\n        get_gossip_peers_1.getGossipPeers(this, topic, this._options.D - fanoutPeers.size, id => {\n          // filter our current peers, direct peers, and peers with negative scores\n          return !fanoutPeers.has(id) && !this.direct.has(id) && this.score.score(id) >= 0;\n        }).forEach(id => fanoutPeers.add(id));\n      }\n\n      this.mesh.set(topic, fanoutPeers);\n      this.fanout.delete(topic);\n      this.lastpub.delete(topic);\n    } else {\n      const peers = get_gossip_peers_1.getGossipPeers(this, topic, this._options.D, id => {\n        // filter direct peers and peers with negative score\n        return !this.direct.has(id) && this.score.score(id) >= 0;\n      });\n      this.mesh.set(topic, peers);\n    }\n\n    this.mesh.get(topic).forEach(id => {\n      this.log('JOIN: Add mesh link to %s in %s', id, topic);\n\n      this._sendGraft(id, topic);\n    });\n  }\n  /**\n   * Leave topic\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  leave(topic) {\n    if (!this.started) {\n      throw new Error('Gossipsub has not started');\n    }\n\n    this.log('LEAVE %s', topic); // Send PRUNE to mesh peers\n\n    const meshPeers = this.mesh.get(topic);\n\n    if (meshPeers) {\n      meshPeers.forEach(id => {\n        this.log('LEAVE: Remove mesh link to %s in %s', id, topic);\n\n        this._sendPrune(id, topic);\n      });\n      this.mesh.delete(topic);\n    }\n  }\n  /**\n   * Publish messages\n   *\n   * @override\n   * @param {InMessage} msg\n   * @returns {void}\n   */\n\n\n  _publish(msg) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (msg.receivedFrom !== this.peerId.toB58String()) {\n        this.score.deliverMessage(msg);\n        this.gossipTracer.deliverMessage(msg);\n      }\n\n      const msgID = yield this.getMsgId(msg);\n      const msgIdStr = utils_1.messageIdToString(msgID); // put in seen cache\n\n      this.seenCache.put(msgIdStr);\n      this.messageCache.put(msg);\n      const tosend = new Set();\n      msg.topicIDs.forEach(topic => {\n        const peersInTopic = this.topics.get(topic);\n\n        if (!peersInTopic) {\n          return;\n        }\n\n        if (this._options.floodPublish && msg.from === this.peerId.toB58String()) {\n          // flood-publish behavior\n          // send to direct peers and _all_ peers meeting the publishThreshold\n          peersInTopic.forEach(id => {\n            if (this.direct.has(id) || this.score.score(id) >= this._options.scoreThresholds.publishThreshold) {\n              tosend.add(id);\n            }\n          });\n        } else {\n          // non-flood-publish behavior\n          // send to direct peers, subscribed floodsub peers\n          // and some mesh peers above publishThreshold\n          // direct peers\n          this.direct.forEach(id => {\n            tosend.add(id);\n          }); // floodsub peers\n\n          peersInTopic.forEach(id => {\n            const score = this.score.score(id);\n            const peerStreams = this.peers.get(id);\n\n            if (!peerStreams) {\n              return;\n            }\n\n            if (peerStreams.protocol === constants.FloodsubID && score >= this._options.scoreThresholds.publishThreshold) {\n              tosend.add(id);\n            }\n          }); // Gossipsub peers handling\n\n          let meshPeers = this.mesh.get(topic);\n\n          if (!meshPeers || !meshPeers.size) {\n            // We are not in the mesh for topic, use fanout peers\n            meshPeers = this.fanout.get(topic);\n\n            if (!meshPeers) {\n              // If we are not in the fanout, then pick peers in topic above the publishThreshold\n              const peers = get_gossip_peers_1.getGossipPeers(this, topic, this._options.D, id => {\n                return this.score.score(id) >= this._options.scoreThresholds.publishThreshold;\n              });\n\n              if (peers.size > 0) {\n                meshPeers = peers;\n                this.fanout.set(topic, peers);\n              } else {\n                meshPeers = new Set();\n              }\n            } // Store the latest publishing time\n\n\n            this.lastpub.set(topic, this._now());\n          }\n\n          meshPeers.forEach(peer => {\n            tosend.add(peer);\n          });\n        }\n      }); // Publish messages to peers\n\n      const rpc = utils_1.createGossipRpc([pubsub_1.utils.normalizeOutRpcMessage(msg)]);\n      tosend.forEach(id => {\n        if (id === msg.from) {\n          return;\n        }\n\n        this._sendRpc(id, rpc);\n      });\n    });\n  }\n  /**\n   * Sends a GRAFT message to a peer\n   * @param {string} id peer id\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  _sendGraft(id, topic) {\n    const graft = [{\n      topicID: topic\n    }];\n    const out = utils_1.createGossipRpc([], {\n      graft\n    });\n\n    this._sendRpc(id, out);\n  }\n  /**\n   * Sends a PRUNE message to a peer\n   * @param {string} id peer id\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  _sendPrune(id, topic) {\n    const prune = [this._makePrune(id, topic, this._options.doPX)];\n    const out = utils_1.createGossipRpc([], {\n      prune\n    });\n\n    this._sendRpc(id, out);\n  }\n  /**\n   * @override\n   */\n\n\n  _sendRpc(id, outRpc) {\n    const peerStreams = this.peers.get(id);\n\n    if (!peerStreams || !peerStreams.isWritable) {\n      return;\n    } // piggyback control message retries\n\n\n    const ctrl = this.control.get(id);\n\n    if (ctrl) {\n      this._piggybackControl(id, outRpc, ctrl);\n\n      this.control.delete(id);\n    } // piggyback gossip\n\n\n    const ihave = this.gossip.get(id);\n\n    if (ihave) {\n      this._piggybackGossip(id, outRpc, ihave);\n\n      this.gossip.delete(id);\n    }\n\n    peerStreams.write(rpc_1.RPC.encode(outRpc).finish());\n  }\n\n  _piggybackControl(id, outRpc, ctrl) {\n    const tograft = (ctrl.graft || []).filter(({\n      topicID\n    }) => (topicID && this.mesh.get(topicID) || new Set()).has(id));\n    const toprune = (ctrl.prune || []).filter(({\n      topicID\n    }) => !(topicID && this.mesh.get(topicID) || new Set()).has(id));\n\n    if (!tograft.length && !toprune.length) {\n      return;\n    }\n\n    if (outRpc.control) {\n      outRpc.control.graft = outRpc.control.graft && outRpc.control.graft.concat(tograft);\n      outRpc.control.prune = outRpc.control.prune && outRpc.control.prune.concat(toprune);\n    } else {\n      outRpc.control = {\n        ihave: [],\n        iwant: [],\n        graft: tograft,\n        prune: toprune\n      };\n    }\n  }\n\n  _piggybackGossip(id, outRpc, ihave) {\n    if (!outRpc.control) {\n      outRpc.control = {\n        ihave: [],\n        iwant: [],\n        graft: [],\n        prune: []\n      };\n    }\n\n    outRpc.control.ihave = ihave;\n  }\n  /**\n   * Send graft and prune messages\n   * @param {Map<string, Array<string>>} tograft peer id => topic[]\n   * @param {Map<string, Array<string>>} toprune peer id => topic[]\n   */\n\n\n  _sendGraftPrune(tograft, toprune, noPX) {\n    const doPX = this._options.doPX;\n\n    for (const [id, topics] of tograft) {\n      const graft = topics.map(topicID => ({\n        topicID\n      }));\n      let prune = []; // If a peer also has prunes, process them now\n\n      const pruning = toprune.get(id);\n\n      if (pruning) {\n        prune = pruning.map(topicID => this._makePrune(id, topicID, doPX && !noPX.get(id)));\n        toprune.delete(id);\n      }\n\n      const outRpc = utils_1.createGossipRpc([], {\n        graft,\n        prune\n      });\n\n      this._sendRpc(id, outRpc);\n    }\n\n    for (const [id, topics] of toprune) {\n      const prune = topics.map(topicID => this._makePrune(id, topicID, doPX && !noPX.get(id)));\n      const outRpc = utils_1.createGossipRpc([], {\n        prune\n      });\n\n      this._sendRpc(id, outRpc);\n    }\n  }\n  /**\n   * Emits gossip to peers in a particular topic\n   * @param {string} topic\n   * @param {Set<string>} exclude peers to exclude\n   * @returns {void}\n   */\n\n\n  _emitGossip(topic, exclude) {\n    const messageIDs = this.messageCache.getGossipIDs(topic);\n\n    if (!messageIDs.length) {\n      return;\n    } // shuffle to emit in random order\n\n\n    utils_1.shuffle(messageIDs); // if we are emitting more than GossipsubMaxIHaveLength ids, truncate the list\n\n    if (messageIDs.length > constants.GossipsubMaxIHaveLength) {\n      // we do the truncation (with shuffling) per peer below\n      this.log('too many messages for gossip; will truncate IHAVE list (%d messages)', messageIDs.length);\n    } // Send gossip to GossipFactor peers above threshold with a minimum of D_lazy\n    // First we collect the peers above gossipThreshold that are not in the exclude set\n    // and then randomly select from that set\n    // We also exclude direct peers, as there is no reason to emit gossip to them\n\n\n    const peersToGossip = [];\n    const topicPeers = this.topics.get(topic);\n\n    if (!topicPeers) {\n      // no topic peers, no gossip\n      return;\n    }\n\n    topicPeers.forEach(id => {\n      const peerStreams = this.peers.get(id);\n\n      if (!peerStreams) {\n        return;\n      }\n\n      if (!exclude.has(id) && !this.direct.has(id) && utils_1.hasGossipProtocol(peerStreams.protocol) && this.score.score(id) >= this._options.scoreThresholds.gossipThreshold) {\n        peersToGossip.push(id);\n      }\n    });\n    let target = this._options.Dlazy;\n    const factor = constants.GossipsubGossipFactor * peersToGossip.length;\n\n    if (factor > target) {\n      target = factor;\n    }\n\n    if (target > peersToGossip.length) {\n      target = peersToGossip.length;\n    } else {\n      utils_1.shuffle(peersToGossip);\n    } // Emit the IHAVE gossip to the selected peers up to the target\n\n\n    peersToGossip.slice(0, target).forEach(id => {\n      let peerMessageIDs = messageIDs;\n\n      if (messageIDs.length > constants.GossipsubMaxIHaveLength) {\n        // shuffle and slice message IDs per peer so that we emit a different set for each peer\n        // we have enough reduncancy in the system that this will significantly increase the message\n        // coverage when we do truncate\n        peerMessageIDs = utils_1.shuffle(peerMessageIDs.slice()).slice(0, constants.GossipsubMaxIHaveLength);\n      }\n\n      this._pushGossip(id, {\n        topicID: topic,\n        messageIDs: peerMessageIDs\n      });\n    });\n  }\n  /**\n   * Flush gossip and control messages\n   */\n\n\n  _flush() {\n    // send gossip first, which will also piggyback control\n    for (const [peer, ihave] of this.gossip.entries()) {\n      this.gossip.delete(peer);\n      const out = utils_1.createGossipRpc([], {\n        ihave\n      });\n\n      this._sendRpc(peer, out);\n    } // send the remaining control messages\n\n\n    for (const [peer, control] of this.control.entries()) {\n      this.control.delete(peer);\n      const out = utils_1.createGossipRpc([], {\n        graft: control.graft,\n        prune: control.prune\n      });\n\n      this._sendRpc(peer, out);\n    }\n  }\n  /**\n   * Adds new IHAVE messages to pending gossip\n   * @param {PeerStreams} peerStreams\n   * @param {Array<RPC.IControlIHave>} controlIHaveMsgs\n   * @returns {void}\n   */\n\n\n  _pushGossip(id, controlIHaveMsgs) {\n    this.log('Add gossip to %s', id);\n    const gossip = this.gossip.get(id) || [];\n    this.gossip.set(id, gossip.concat(controlIHaveMsgs));\n  }\n  /**\n   * Returns the current time in milliseconds\n   * @returns {number}\n   */\n\n\n  _now() {\n    return Date.now();\n  }\n  /**\n   * Make a PRUNE control message for a peer in a topic\n   * @param {string} id\n   * @param {string} topic\n   * @param {boolean} doPX\n   * @returns {RPC.IControlPrune}\n   */\n\n\n  _makePrune(id, topic, doPX) {\n    if (this.peers.get(id).protocol === constants.GossipsubIDv10) {\n      // Gossipsub v1.0 -- no backoff, the peer won't be able to parse it anyway\n      return {\n        topicID: topic,\n        peers: []\n      };\n    } // backoff is measured in seconds\n    // GossipsubPruneBackoff is measured in milliseconds\n\n\n    const backoff = constants.GossipsubPruneBackoff / 1000;\n    const px = [];\n\n    if (doPX) {\n      // select peers for Peer eXchange\n      const peers = get_gossip_peers_1.getGossipPeers(this, topic, constants.GossipsubPrunePeers, xid => {\n        return xid !== id && this.score.score(xid) >= 0;\n      });\n      peers.forEach(p => {\n        // see if we have a signed record to send back; if we don't, just send\n        // the peer ID and let the pruned peer find them in the DHT -- we can't trust\n        // unsigned address records through PX anyways\n        // Finding signed records in the DHT is not supported at the time of writing in js-libp2p\n        const peerId = PeerId.createFromB58String(p);\n        px.push({\n          peerID: peerId.toBytes(),\n          signedPeerRecord: this._libp2p.peerStore.addressBook.getRawEnvelope(peerId)\n        });\n      });\n    }\n\n    return {\n      topicID: topic,\n      peers: px,\n      backoff: backoff\n    };\n  }\n\n}\n\nGossipsub.multicodec = constants.GossipsubIDv11;\nmodule.exports = Gossipsub;","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/libp2p-gossipsub/src/index.js"],"names":["__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__importStar","mod","__esModule","result","prototype","hasOwnProperty","call","__awaiter","thisArg","_arguments","P","generator","adopt","resolve","Promise","reject","fulfilled","step","next","e","rejected","done","then","apply","pubsub_1","require","message_cache_1","rpc_1","constants","heartbeat_1","get_gossip_peers_1","utils_1","score_1","tracer_1","TimeCache","PeerId","Envelope","Gossipsub","default","constructor","libp2p","options","multicodecs","GossipsubIDv11","GossipsubIDv10","opts","assign","gossipIncoming","fallbackToFloodsub","floodPublish","doPX","directPeers","D","GossipsubD","Dlo","GossipsubDlo","Dhi","GossipsubDhi","Dscore","GossipsubDscore","Dout","GossipsubDout","Dlazy","GossipsubDlazy","scoreParams","createPeerScoreParams","scoreThresholds","createPeerScoreThresholds","push","FloodsubID","debugName","_options","direct","Set","map","p","id","toB58String","forEach","peerStore","addressBook","add","addrs","seenCache","mesh","Map","fanout","lastpub","gossip","control","peerhave","iasked","backoff","outbound","messageCache","MessageCache","GossipsubHistoryGossip","GossipsubHistoryLength","getMsgId","bind","heartbeat","Heartbeat","heartbeatTicks","gossipTracer","IWantTracer","_libp2p","score","PeerScore","connectionManager","_decodeRpc","bytes","RPC","decode","_encodeRpc","rpc","encode","finish","_addPeer","peerId","protocol","addPeer","c","getAll","stat","direction","Array","from","registry","values","some","rvalue","set","_removePeer","peerStreams","peers","delete","removePeer","_processRpc","_super","_processRpcControlMessage","controlMsg","iwant","ihave","_handleIHave","_handleIWant","prune","graft","_handleGraft","_handlePrune","length","outRpc","createGossipRpc","_sendRpc","_processRpcMessage","msg","msgID","msgIdStr","messageIdToString","has","duplicateMessage","put","validateMessage","_acceptFrom","graylistThreshold","validate","message","rejectMessage","code","gossipThreshold","log","GossipsubMaxIHaveMessages","GossipsubMaxIHaveLength","topicID","messageIDs","size","iask","iwantList","shuffle","slice","addPromise","count","getForPeer","GossipsubGossipRetransmission","utils","normalizeOutRpcMessage","now","_now","_a","peersInMesh","expire","addPenalty","floodCutoff","GossipsubGraftFloodThreshold","GossipsubPruneBackoff","_addBackoff","topic","_makePrune","_doAddBackoff","acceptPXThreshold","_pxConnect","interval","existingExpire","_applyIwantPenalties","getBrokenPromises","_clearBackoff","GossipsubPruneBackoffTicks","_directConnect","GossipsubDirectConnectTicks","toconnect","peer","isWritable","_connect","GossipsubPrunePeers","all","pi","peerID","createFromBytes","signedPeerRecord","envelope","openAndCertify","eid","consumePeerRecord","start","_directPeerInitial","setTimeout","GossipsubDirectConnectInitialDelay","stop","clear","clearTimeout","dialProtocol","createFromB58String","subscribe","join","unsubscribe","leave","started","Error","fanoutPeers","getGossipPeers","_sendGraft","meshPeers","_sendPrune","_publish","receivedFrom","deliverMessage","tosend","topicIDs","peersInTopic","topics","publishThreshold","out","ctrl","_piggybackControl","_piggybackGossip","write","tograft","filter","toprune","concat","_sendGraftPrune","noPX","pruning","_emitGossip","exclude","getGossipIDs","peersToGossip","topicPeers","hasGossipProtocol","target","factor","GossipsubGossipFactor","peerMessageIDs","_pushGossip","_flush","entries","controlIHaveMsgs","Date","px","xid","toBytes","getRawEnvelope","multicodec","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nconst pubsub_1 = __importStar(require(\"libp2p-interfaces/src/pubsub\"));\nconst message_cache_1 = require(\"./message-cache\");\nconst rpc_1 = require(\"./message/rpc\");\nconst constants = __importStar(require(\"./constants\"));\nconst heartbeat_1 = require(\"./heartbeat\");\nconst get_gossip_peers_1 = require(\"./get-gossip-peers\");\nconst utils_1 = require(\"./utils\");\nconst score_1 = require(\"./score\");\nconst tracer_1 = require(\"./tracer\");\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nconst TimeCache = require(\"time-cache\");\nconst PeerId = require(\"peer-id\");\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nconst Envelope = require(\"libp2p/src/record/envelope\");\nclass Gossipsub extends pubsub_1.default {\n    // TODO: add remaining props\n    /**\n     * @param {Libp2p} libp2p\n     * @param {Object} [options]\n     * @param {boolean} [options.emitSelf = false] if publish should emit to self, if subscribed\n     * @param {boolean} [options.canRelayMessage = false] - if can relay messages not subscribed\n     * @param {boolean} [options.gossipIncoming = true] if incoming messages on a subscribed topic should be automatically gossiped\n     * @param {boolean} [options.fallbackToFloodsub = true] if dial should fallback to floodsub\n     * @param {boolean} [options.floodPublish = true] if self-published messages should be sent to all peers\n     * @param {boolean} [options.doPX = false] whether PX is enabled; this should be enabled in bootstrappers and other well connected/trusted nodes.\n     * @param {Object} [options.messageCache] override the default MessageCache\n     * @param {string} [options.globalSignaturePolicy = \"StrictSign\"] signing policy to apply across all messages\n     * @param {Object} [options.scoreParams] peer score parameters\n     * @param {Object} [options.scoreThresholds] peer score thresholds\n     * @param {AddrInfo[]} [options.directPeers] peers with which we will maintain direct connections\n     * @constructor\n     */\n    constructor(libp2p, options = {}) {\n        const multicodecs = [constants.GossipsubIDv11, constants.GossipsubIDv10];\n        const opts = Object.assign(Object.assign({ gossipIncoming: true, fallbackToFloodsub: true, floodPublish: true, doPX: false, directPeers: [], D: constants.GossipsubD, Dlo: constants.GossipsubDlo, Dhi: constants.GossipsubDhi, Dscore: constants.GossipsubDscore, Dout: constants.GossipsubDout, Dlazy: constants.GossipsubDlazy }, options), { scoreParams: score_1.createPeerScoreParams(options.scoreParams), scoreThresholds: score_1.createPeerScoreThresholds(options.scoreThresholds) });\n        // Also wants to get notified of peers connected using floodsub\n        if (opts.fallbackToFloodsub) {\n            multicodecs.push(constants.FloodsubID);\n        }\n        super(Object.assign({ debugName: 'libp2p:gossipsub', multicodecs,\n            libp2p }, opts));\n        this._options = opts;\n        /**\n         * Direct peers\n         * @type {Set<string>}\n         */\n        this.direct = new Set(opts.directPeers.map(p => p.id.toB58String()));\n        // set direct peer addresses in the address book\n        opts.directPeers.forEach(p => {\n            libp2p.peerStore.addressBook.add(p.id, p.addrs);\n        });\n        /**\n         * Cache of seen messages\n         *\n         * @type {TimeCache}\n         */\n        this.seenCache = new TimeCache();\n        /**\n         * Map of topic meshes\n         * topic => peer id set\n         *\n         * @type {Map<string, Set<string>>}\n         */\n        this.mesh = new Map();\n        /**\n         * Map of topics to set of peers. These mesh peers are the ones to which we are publishing without a topic membership\n         * topic => peer id set\n         *\n         * @type {Map<string, Set<string>>}\n         */\n        this.fanout = new Map();\n        /**\n         * Map of last publish time for fanout topics\n         * topic => last publish time\n         *\n         * @type {Map<string, number>}\n         */\n        this.lastpub = new Map();\n        /**\n         * Map of pending messages to gossip\n         * peer id => control messages\n         *\n         * @type {Map<string, Array<RPC.IControlIHave object>> }\n         */\n        this.gossip = new Map();\n        /**\n         * Map of control messages\n         * peer id => control message\n         *\n         * @type {Map<string, RPC.IControlMessage object>}\n         */\n        this.control = new Map();\n        /**\n         * Number of IHAVEs received from peer in the last heartbeat\n         * @type {Map<string, number>}\n         */\n        this.peerhave = new Map();\n        /**\n         * Number of messages we have asked from peer in the last heartbeat\n         * @type {Map<string, number>}\n         */\n        this.iasked = new Map();\n        /**\n         * Prune backoff map\n         */\n        this.backoff = new Map();\n        /**\n         * Connection direction cache, marks peers with outbound connections\n         * peer id => direction\n         *\n         * @type {Map<string, boolean>}\n         */\n        this.outbound = new Map();\n        /**\n         * A message cache that contains the messages for last few hearbeat ticks\n         *\n         */\n        this.messageCache = options.messageCache || new message_cache_1.MessageCache(constants.GossipsubHistoryGossip, constants.GossipsubHistoryLength, this.getMsgId.bind(this));\n        /**\n         * A heartbeat timer that maintains the mesh\n         */\n        this.heartbeat = new heartbeat_1.Heartbeat(this);\n        /**\n         * Number of heartbeats since the beginning of time\n         * This allows us to amortize some resource cleanup -- eg: backoff cleanup\n         */\n        this.heartbeatTicks = 0;\n        /**\n         * Tracks IHAVE/IWANT promises broken by peers\n         */\n        this.gossipTracer = new tracer_1.IWantTracer(this.getMsgId.bind(this));\n        /**\n         * libp2p\n         */\n        this._libp2p = libp2p;\n        /**\n         * Peer score tracking\n         */\n        this.score = new score_1.PeerScore(this._options.scoreParams, libp2p.connectionManager, this.getMsgId.bind(this));\n    }\n    /**\n     * Decode a Uint8Array into an RPC object\n     * Overrided to use an extended protocol-specific protobuf decoder\n     * @override\n     * @param {Uint8Array} bytes\n     * @returns {RPC}\n     */\n    _decodeRpc(bytes) {\n        return rpc_1.RPC.decode(bytes);\n    }\n    /**\n     * Encode an RPC object into a Uint8Array\n     * Overrided to use an extended protocol-specific protobuf encoder\n     * @override\n     * @param {RPC} rpc\n     * @returns {Uint8Array}\n     */\n    _encodeRpc(rpc) {\n        return rpc_1.RPC.encode(rpc).finish();\n    }\n    /**\n     * Add a peer to the router\n     * @override\n     * @param {PeerId} peerId\n     * @param {string} protocol\n     * @returns {PeerStreams}\n     */\n    _addPeer(peerId, protocol) {\n        const p = super._addPeer(peerId, protocol);\n        // Add to peer scoring\n        this.score.addPeer(peerId.toB58String());\n        // track the connection direction\n        let outbound = false;\n        for (const c of this._libp2p.connectionManager.getAll(peerId)) {\n            if (c.stat.direction === 'outbound') {\n                if (Array.from(c.registry.values()).some(rvalue => protocol === rvalue.protocol)) {\n                    outbound = true;\n                    break;\n                }\n            }\n        }\n        this.outbound.set(p.id.toB58String(), outbound);\n        return p;\n    }\n    /**\n     * Removes a peer from the router\n     * @override\n     * @param {PeerId} peer\n     * @returns {PeerStreams | undefined}\n     */\n    _removePeer(peerId) {\n        const peerStreams = super._removePeer(peerId);\n        const id = peerId.toB58String();\n        // Remove this peer from the mesh\n        // eslint-disable-next-line no-unused-vars\n        for (const peers of this.mesh.values()) {\n            peers.delete(id);\n        }\n        // Remove this peer from the fanout\n        // eslint-disable-next-line no-unused-vars\n        for (const peers of this.fanout.values()) {\n            peers.delete(id);\n        }\n        // Remove from gossip mapping\n        this.gossip.delete(id);\n        // Remove from control mapping\n        this.control.delete(id);\n        // Remove from backoff mapping\n        this.outbound.delete(id);\n        // Remove from peer scoring\n        this.score.removePeer(id);\n        return peerStreams;\n    }\n    /**\n     * Handles an rpc request from a peer\n     *\n     * @override\n     * @param {String} idB58Str\n     * @param {PeerStreams} peerStreams\n     * @param {RPC} rpc\n     * @returns {Promise<boolean>}\n     */\n    _processRpc(id, peerStreams, rpc) {\n        const _super = Object.create(null, {\n            _processRpc: { get: () => super._processRpc }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            if (yield _super._processRpc.call(this, id, peerStreams, rpc)) {\n                if (rpc.control) {\n                    this._processRpcControlMessage(id, rpc.control);\n                }\n                return true;\n            }\n            return false;\n        });\n    }\n    /**\n     * Handles an rpc control message from a peer\n     * @param {string} id peer id\n     * @param {RPC.IControlMessage} controlMsg\n     * @returns {void}\n     */\n    _processRpcControlMessage(id, controlMsg) {\n        if (!controlMsg) {\n            return;\n        }\n        const iwant = controlMsg.ihave ? this._handleIHave(id, controlMsg.ihave) : [];\n        const ihave = controlMsg.iwant ? this._handleIWant(id, controlMsg.iwant) : [];\n        const prune = controlMsg.graft ? this._handleGraft(id, controlMsg.graft) : [];\n        controlMsg.prune && this._handlePrune(id, controlMsg.prune);\n        if (!iwant.length && !ihave.length && !prune.length) {\n            return;\n        }\n        const outRpc = utils_1.createGossipRpc(ihave, { iwant, prune });\n        this._sendRpc(id, outRpc);\n    }\n    /**\n     * Process incoming message,\n     * emitting locally and forwarding on to relevant floodsub and gossipsub peers\n     * @override\n     * @param {InMessage} msg\n     * @returns {Promise<void>}\n     */\n    _processRpcMessage(msg) {\n        const _super = Object.create(null, {\n            _processRpcMessage: { get: () => super._processRpcMessage }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            const msgID = yield this.getMsgId(msg);\n            const msgIdStr = utils_1.messageIdToString(msgID);\n            // Ignore if we've already seen the message\n            if (this.seenCache.has(msgIdStr)) {\n                this.score.duplicateMessage(msg);\n                return;\n            }\n            this.seenCache.put(msgIdStr);\n            yield this.score.validateMessage(msg);\n            yield _super._processRpcMessage.call(this, msg);\n        });\n    }\n    /**\n     * Whether to accept a message from a peer\n     * @override\n     * @param {string} id\n     * @returns {boolean}\n     */\n    _acceptFrom(id) {\n        return this.direct.has(id) || this.score.score(id) >= this._options.scoreThresholds.graylistThreshold;\n    }\n    /**\n     * Validate incoming message\n     * @override\n     * @param {InMessage} message\n     * @returns {Promise<void>}\n     */\n    validate(message) {\n        const _super = Object.create(null, {\n            validate: { get: () => super.validate }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield _super.validate.call(this, message);\n            }\n            catch (e) {\n                this.score.rejectMessage(message, e.code);\n                this.gossipTracer.rejectMessage(message, e.code);\n                throw e;\n            }\n        });\n    }\n    /**\n     * Handles IHAVE messages\n     * @param {string} id peer id\n     * @param {Array<RPC.IControlIHave>} ihave\n     * @returns {RPC.IControlIWant}\n     */\n    _handleIHave(id, ihave) {\n        if (!ihave.length) {\n            return [];\n        }\n        // we ignore IHAVE gossip from any peer whose score is below the gossips threshold\n        const score = this.score.score(id);\n        if (score < this._options.scoreThresholds.gossipThreshold) {\n            this.log('IHAVE: ignoring peer %s with score below threshold [ score = %d ]', id, score);\n            return [];\n        }\n        // IHAVE flood protection\n        const peerhave = (this.peerhave.get(id) || 0) + 1;\n        this.peerhave.set(id, peerhave);\n        if (peerhave > constants.GossipsubMaxIHaveMessages) {\n            this.log('IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring', id, peerhave);\n            return [];\n        }\n        const iasked = this.iasked.get(id) || 0;\n        if (iasked >= constants.GossipsubMaxIHaveLength) {\n            this.log('IHAVE: peer %s has already advertised too many messages (%d); ignoring', id, iasked);\n            return [];\n        }\n        // string msgId => msgId\n        const iwant = new Map();\n        ihave.forEach(({ topicID, messageIDs }) => {\n            if (!topicID || !messageIDs || !this.mesh.has(topicID)) {\n                return;\n            }\n            messageIDs.forEach((msgID) => {\n                const msgIdStr = utils_1.messageIdToString(msgID);\n                if (this.seenCache.has(msgIdStr)) {\n                    return;\n                }\n                iwant.set(msgIdStr, msgID);\n            });\n        });\n        if (!iwant.size) {\n            return [];\n        }\n        let iask = iwant.size;\n        if (iask + iasked > constants.GossipsubMaxIHaveLength) {\n            iask = constants.GossipsubMaxIHaveLength - iasked;\n        }\n        this.log('IHAVE: Asking for %d out of %d messages from %s', iask, iwant.size, id);\n        let iwantList = Array.from(iwant.values());\n        // ask in random order\n        utils_1.shuffle(iwantList);\n        // truncate to the messages we are actually asking for and update the iasked counter\n        iwantList = iwantList.slice(0, iask);\n        this.iasked.set(id, iasked + iask);\n        this.gossipTracer.addPromise(id, iwantList);\n        return [{\n                messageIDs: iwantList\n            }];\n    }\n    /**\n     * Handles IWANT messages\n     * Returns messages to send back to peer\n     * @param {string} id peer id\n     * @param {Array<RPC.IControlIWant>} iwant\n     * @returns {Array<RPC.IMessage>}\n     */\n    _handleIWant(id, iwant) {\n        if (!iwant.length) {\n            return [];\n        }\n        // we don't respond to IWANT requests from any per whose score is below the gossip threshold\n        const score = this.score.score(id);\n        if (score < this._options.scoreThresholds.gossipThreshold) {\n            this.log('IWANT: ignoring peer %s with score below threshold [score = %d]', id, score);\n            return [];\n        }\n        // @type {Map<string, Message>}\n        const ihave = new Map();\n        iwant.forEach(({ messageIDs }) => {\n            messageIDs && messageIDs.forEach((msgID) => {\n                const [msg, count] = this.messageCache.getForPeer(msgID, id);\n                if (!msg) {\n                    return;\n                }\n                if (count > constants.GossipsubGossipRetransmission) {\n                    this.log('IWANT: Peer %s has asked for message %s too many times: ignoring request', id, msgID);\n                    return;\n                }\n                ihave.set(utils_1.messageIdToString(msgID), msg);\n            });\n        });\n        if (!ihave.size) {\n            return [];\n        }\n        this.log('IWANT: Sending %d messages to %s', ihave.size, id);\n        return Array.from(ihave.values()).map(pubsub_1.utils.normalizeOutRpcMessage);\n    }\n    /**\n     * Handles Graft messages\n     * @param {string} id peer id\n     * @param {Array<RPC.IControlGraft>} graft\n     * @return {Array<RPC.IControlPrune>}\n     */\n    _handleGraft(id, graft) {\n        const prune = [];\n        const score = this.score.score(id);\n        const now = this._now();\n        let doPX = this._options.doPX;\n        graft.forEach(({ topicID }) => {\n            var _a;\n            if (!topicID) {\n                return;\n            }\n            const peersInMesh = this.mesh.get(topicID);\n            if (!peersInMesh) {\n                // don't do PX when there is an unknown topic to avoid leaking our peers\n                doPX = false;\n                // spam hardening: ignore GRAFTs for unknown topics\n                return;\n            }\n            // check if peer is already in the mesh; if so do nothing\n            if (peersInMesh.has(id)) {\n                return;\n            }\n            // we don't GRAFT to/from direct peers; complain loudly if this happens\n            if (this.direct.has(id)) {\n                this.log('GRAFT: ignoring request from direct peer %s', id);\n                // this is possibly a bug from a non-reciprical configuration; send a PRUNE\n                prune.push(topicID);\n                // but don't px\n                doPX = false;\n                return;\n            }\n            // make sure we are not backing off that peer\n            const expire = (_a = this.backoff.get(topicID)) === null || _a === void 0 ? void 0 : _a.get(id);\n            if (typeof expire === 'number' && now < expire) {\n                this.log('GRAFT: ignoring backed off peer %s', id);\n                // add behavioral penalty\n                this.score.addPenalty(id, 1);\n                // no PX\n                doPX = false;\n                // check the flood cutoff -- is the GRAFT coming too fast?\n                const floodCutoff = expire + constants.GossipsubGraftFloodThreshold - constants.GossipsubPruneBackoff;\n                if (now < floodCutoff) {\n                    // extra penalty\n                    this.score.addPenalty(id, 1);\n                }\n                // refresh the backoff\n                this._addBackoff(id, topicID);\n                prune.push(topicID);\n                return;\n            }\n            // check the score\n            if (score < 0) {\n                // we don't GRAFT peers with negative score\n                this.log('GRAFT: ignoring peer %s with negative score: score=%d, topic=%s', id, score, topicID);\n                // we do send them PRUNE however, because it's a matter of protocol correctness\n                prune.push(topicID);\n                // but we won't PX to them\n                doPX = false;\n                // add/refresh backoff so that we don't reGRAFT too early even if the score decays\n                this._addBackoff(id, topicID);\n                return;\n            }\n            // check the number of mesh peers; if it is at (or over) Dhi, we only accept grafts\n            // from peers with outbound connections; this is a defensive check to restrict potential\n            // mesh takeover attacks combined with love bombing\n            if (peersInMesh.size >= this._options.Dhi && !this.outbound.get(id)) {\n                prune.push(topicID);\n                this._addBackoff(id, topicID);\n                return;\n            }\n            this.log('GRAFT: Add mesh link from %s in %s', id, topicID);\n            this.score.graft(id, topicID);\n            peersInMesh.add(id);\n        });\n        if (!prune.length) {\n            return [];\n        }\n        return prune.map(topic => this._makePrune(id, topic, doPX));\n    }\n    /**\n     * Handles Prune messages\n     * @param {string} id peer id\n     * @param {Array<RPC.IControlPrune>} prune\n     * @returns {void}\n     */\n    _handlePrune(id, prune) {\n        const score = this.score.score(id);\n        prune.forEach(({ topicID, backoff, peers }) => {\n            if (!topicID) {\n                return;\n            }\n            const peersInMesh = this.mesh.get(topicID);\n            if (!peersInMesh) {\n                return;\n            }\n            this.log('PRUNE: Remove mesh link to %s in %s', id, topicID);\n            this.score.prune(id, topicID);\n            peersInMesh.delete(id);\n            // is there a backoff specified by the peer? if so obey it\n            if (typeof backoff === 'number' && backoff > 0) {\n                this._doAddBackoff(id, topicID, backoff * 1000);\n            }\n            else {\n                this._addBackoff(id, topicID);\n            }\n            // PX\n            if (peers && peers.length) {\n                // we ignore PX from peers with insufficient scores\n                if (score < this._options.scoreThresholds.acceptPXThreshold) {\n                    this.log('PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]', id, score, topicID);\n                    return;\n                }\n                this._pxConnect(peers);\n            }\n        });\n    }\n    /**\n     * Add standard backoff log for a peer in a topic\n     * @param {string} id\n     * @param {string} topic\n     * @returns {void}\n     */\n    _addBackoff(id, topic) {\n        this._doAddBackoff(id, topic, constants.GossipsubPruneBackoff);\n    }\n    /**\n     * Add backoff expiry interval for a peer in a topic\n     * @param {string} id\n     * @param {string} topic\n     * @param {number} interval backoff duration in milliseconds\n     * @returns {void}\n     */\n    _doAddBackoff(id, topic, interval) {\n        let backoff = this.backoff.get(topic);\n        if (!backoff) {\n            backoff = new Map();\n            this.backoff.set(topic, backoff);\n        }\n        const expire = this._now() + interval;\n        const existingExpire = backoff.get(id) || 0;\n        if (existingExpire < expire) {\n            backoff.set(id, expire);\n        }\n    }\n    /**\n     * Apply penalties from broken IHAVE/IWANT promises\n     * @returns {void}\n     */\n    _applyIwantPenalties() {\n        this.gossipTracer.getBrokenPromises().forEach((count, p) => {\n            this.log('peer %s didn\\'t follow up in %d IWANT requests; adding penalty', p, count);\n            this.score.addPenalty(p, count);\n        });\n    }\n    /**\n     * Clear expired backoff expiries\n     * @returns {void}\n     */\n    _clearBackoff() {\n        // we only clear once every GossipsubPruneBackoffTicks ticks to avoid iterating over the maps too much\n        if (this.heartbeatTicks % constants.GossipsubPruneBackoffTicks !== 0) {\n            return;\n        }\n        const now = this._now();\n        this.backoff.forEach((backoff, topic) => {\n            backoff.forEach((expire, id) => {\n                if (expire < now) {\n                    backoff.delete(id);\n                }\n            });\n            if (backoff.size === 0) {\n                this.backoff.delete(topic);\n            }\n        });\n    }\n    /**\n     * Maybe reconnect to direct peers\n     * @returns {void}\n     */\n    _directConnect() {\n        // we only do this every few ticks to allow pending connections to complete and account for\n        // restarts/downtime\n        if (this.heartbeatTicks % constants.GossipsubDirectConnectTicks !== 0) {\n            return;\n        }\n        const toconnect = [];\n        this.direct.forEach(id => {\n            const peer = this.peers.get(id);\n            if (!peer || !peer.isWritable) {\n                toconnect.push(id);\n            }\n        });\n        if (toconnect.length) {\n            toconnect.forEach(id => {\n                this._connect(id);\n            });\n        }\n    }\n    /**\n     * Maybe attempt connection given signed peer records\n     * @param {RPC.IPeerInfo[]} peers\n     * @returns {Promise<void>}\n     */\n    _pxConnect(peers) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (peers.length > constants.GossipsubPrunePeers) {\n                utils_1.shuffle(peers);\n                peers = peers.slice(0, constants.GossipsubPrunePeers);\n            }\n            const toconnect = [];\n            yield Promise.all(peers.map((pi) => __awaiter(this, void 0, void 0, function* () {\n                if (!pi.peerID) {\n                    return;\n                }\n                const p = PeerId.createFromBytes(pi.peerID);\n                const id = p.toB58String();\n                if (this.peers.has(id)) {\n                    return;\n                }\n                if (!pi.signedPeerRecord) {\n                    toconnect.push(id);\n                    return;\n                }\n                // The peer sent us a signed record\n                // This is not a record from the peer who sent the record, but another peer who is connected with it\n                // Ensure that it is valid\n                try {\n                    const envelope = yield Envelope.openAndCertify(pi.signedPeerRecord, 'libp2p-peer-record');\n                    const eid = envelope.peerId.toB58String();\n                    if (id !== eid) {\n                        this.log('bogus peer record obtained through px: peer ID %s doesn\\'t match expected peer %s', eid, id);\n                        return;\n                    }\n                    if (!this._libp2p.peerStore.addressBook.consumePeerRecord(envelope)) {\n                        this.log('bogus peer record obtained through px: could not add peer record to address book');\n                        return;\n                    }\n                    toconnect.push(id);\n                }\n                catch (e) {\n                    this.log('bogus peer record obtained through px: invalid signature or not a peer record');\n                }\n            })));\n            if (!toconnect.length) {\n                return;\n            }\n            toconnect.forEach(id => this._connect(id));\n        });\n    }\n    /**\n     * Mounts the gossipsub protocol onto the libp2p node and sends our\n     * our subscriptions to every peer connected\n     * @override\n     * @returns {void}\n     */\n    start() {\n        super.start();\n        this.heartbeat.start();\n        this.score.start();\n        // connect to direct peers\n        this._directPeerInitial = setTimeout(() => {\n            this.direct.forEach(id => {\n                this._connect(id);\n            });\n        }, constants.GossipsubDirectConnectInitialDelay);\n    }\n    /**\n     * Unmounts the gossipsub protocol and shuts down every connection\n     * @override\n     * @returns {void}\n     */\n    stop() {\n        super.stop();\n        this.heartbeat.stop();\n        this.score.stop();\n        this.mesh = new Map();\n        this.fanout = new Map();\n        this.lastpub = new Map();\n        this.gossip = new Map();\n        this.control = new Map();\n        this.peerhave = new Map();\n        this.iasked = new Map();\n        this.backoff = new Map();\n        this.outbound = new Map();\n        this.gossipTracer.clear();\n        clearTimeout(this._directPeerInitial);\n    }\n    /**\n     * Connect to a peer using the gossipsub protocol\n     * @param {string} id\n     * @returns {void}\n     */\n    _connect(id) {\n        this.log('Initiating connection with %s', id);\n        this._libp2p.dialProtocol(PeerId.createFromB58String(id), this.multicodecs);\n    }\n    /**\n     * Subscribes to a topic\n     * @override\n     * @param {string} topic\n     * @returns {void}\n     */\n    subscribe(topic) {\n        super.subscribe(topic);\n        this.join(topic);\n    }\n    /**\n     * Unsubscribe to a topic\n     * @override\n     * @param {string} topic\n     * @returns {void}\n     */\n    unsubscribe(topic) {\n        super.unsubscribe(topic);\n        this.leave(topic);\n    }\n    /**\n     * Join topic\n     * @param {string} topic\n     * @returns {void}\n     */\n    join(topic) {\n        if (!this.started) {\n            throw new Error('Gossipsub has not started');\n        }\n        this.log('JOIN %s', topic);\n        const fanoutPeers = this.fanout.get(topic);\n        if (fanoutPeers) {\n            // these peers have a score above the publish threshold, which may be negative\n            // so drop the ones with a negative score\n            fanoutPeers.forEach(id => {\n                if (this.score.score(id) < 0) {\n                    fanoutPeers.delete(id);\n                }\n            });\n            if (fanoutPeers.size < this._options.D) {\n                // we need more peers; eager, as this would get fixed in the next heartbeat\n                get_gossip_peers_1.getGossipPeers(this, topic, this._options.D - fanoutPeers.size, (id) => {\n                    // filter our current peers, direct peers, and peers with negative scores\n                    return !fanoutPeers.has(id) && !this.direct.has(id) && this.score.score(id) >= 0;\n                }).forEach(id => fanoutPeers.add(id));\n            }\n            this.mesh.set(topic, fanoutPeers);\n            this.fanout.delete(topic);\n            this.lastpub.delete(topic);\n        }\n        else {\n            const peers = get_gossip_peers_1.getGossipPeers(this, topic, this._options.D, (id) => {\n                // filter direct peers and peers with negative score\n                return !this.direct.has(id) && this.score.score(id) >= 0;\n            });\n            this.mesh.set(topic, peers);\n        }\n        this.mesh.get(topic).forEach((id) => {\n            this.log('JOIN: Add mesh link to %s in %s', id, topic);\n            this._sendGraft(id, topic);\n        });\n    }\n    /**\n     * Leave topic\n     * @param {string} topic\n     * @returns {void}\n     */\n    leave(topic) {\n        if (!this.started) {\n            throw new Error('Gossipsub has not started');\n        }\n        this.log('LEAVE %s', topic);\n        // Send PRUNE to mesh peers\n        const meshPeers = this.mesh.get(topic);\n        if (meshPeers) {\n            meshPeers.forEach((id) => {\n                this.log('LEAVE: Remove mesh link to %s in %s', id, topic);\n                this._sendPrune(id, topic);\n            });\n            this.mesh.delete(topic);\n        }\n    }\n    /**\n     * Publish messages\n     *\n     * @override\n     * @param {InMessage} msg\n     * @returns {void}\n     */\n    _publish(msg) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (msg.receivedFrom !== this.peerId.toB58String()) {\n                this.score.deliverMessage(msg);\n                this.gossipTracer.deliverMessage(msg);\n            }\n            const msgID = yield this.getMsgId(msg);\n            const msgIdStr = utils_1.messageIdToString(msgID);\n            // put in seen cache\n            this.seenCache.put(msgIdStr);\n            this.messageCache.put(msg);\n            const tosend = new Set();\n            msg.topicIDs.forEach((topic) => {\n                const peersInTopic = this.topics.get(topic);\n                if (!peersInTopic) {\n                    return;\n                }\n                if (this._options.floodPublish && msg.from === this.peerId.toB58String()) {\n                    // flood-publish behavior\n                    // send to direct peers and _all_ peers meeting the publishThreshold\n                    peersInTopic.forEach(id => {\n                        if (this.direct.has(id) || this.score.score(id) >= this._options.scoreThresholds.publishThreshold) {\n                            tosend.add(id);\n                        }\n                    });\n                }\n                else {\n                    // non-flood-publish behavior\n                    // send to direct peers, subscribed floodsub peers\n                    // and some mesh peers above publishThreshold\n                    // direct peers\n                    this.direct.forEach(id => {\n                        tosend.add(id);\n                    });\n                    // floodsub peers\n                    peersInTopic.forEach((id) => {\n                        const score = this.score.score(id);\n                        const peerStreams = this.peers.get(id);\n                        if (!peerStreams) {\n                            return;\n                        }\n                        if (peerStreams.protocol === constants.FloodsubID && score >= this._options.scoreThresholds.publishThreshold) {\n                            tosend.add(id);\n                        }\n                    });\n                    // Gossipsub peers handling\n                    let meshPeers = this.mesh.get(topic);\n                    if (!meshPeers || !meshPeers.size) {\n                        // We are not in the mesh for topic, use fanout peers\n                        meshPeers = this.fanout.get(topic);\n                        if (!meshPeers) {\n                            // If we are not in the fanout, then pick peers in topic above the publishThreshold\n                            const peers = get_gossip_peers_1.getGossipPeers(this, topic, this._options.D, id => {\n                                return this.score.score(id) >= this._options.scoreThresholds.publishThreshold;\n                            });\n                            if (peers.size > 0) {\n                                meshPeers = peers;\n                                this.fanout.set(topic, peers);\n                            }\n                            else {\n                                meshPeers = new Set();\n                            }\n                        }\n                        // Store the latest publishing time\n                        this.lastpub.set(topic, this._now());\n                    }\n                    meshPeers.forEach((peer) => {\n                        tosend.add(peer);\n                    });\n                }\n            });\n            // Publish messages to peers\n            const rpc = utils_1.createGossipRpc([\n                pubsub_1.utils.normalizeOutRpcMessage(msg)\n            ]);\n            tosend.forEach((id) => {\n                if (id === msg.from) {\n                    return;\n                }\n                this._sendRpc(id, rpc);\n            });\n        });\n    }\n    /**\n     * Sends a GRAFT message to a peer\n     * @param {string} id peer id\n     * @param {string} topic\n     * @returns {void}\n     */\n    _sendGraft(id, topic) {\n        const graft = [{\n                topicID: topic\n            }];\n        const out = utils_1.createGossipRpc([], { graft });\n        this._sendRpc(id, out);\n    }\n    /**\n     * Sends a PRUNE message to a peer\n     * @param {string} id peer id\n     * @param {string} topic\n     * @returns {void}\n     */\n    _sendPrune(id, topic) {\n        const prune = [\n            this._makePrune(id, topic, this._options.doPX)\n        ];\n        const out = utils_1.createGossipRpc([], { prune });\n        this._sendRpc(id, out);\n    }\n    /**\n     * @override\n     */\n    _sendRpc(id, outRpc) {\n        const peerStreams = this.peers.get(id);\n        if (!peerStreams || !peerStreams.isWritable) {\n            return;\n        }\n        // piggyback control message retries\n        const ctrl = this.control.get(id);\n        if (ctrl) {\n            this._piggybackControl(id, outRpc, ctrl);\n            this.control.delete(id);\n        }\n        // piggyback gossip\n        const ihave = this.gossip.get(id);\n        if (ihave) {\n            this._piggybackGossip(id, outRpc, ihave);\n            this.gossip.delete(id);\n        }\n        peerStreams.write(rpc_1.RPC.encode(outRpc).finish());\n    }\n    _piggybackControl(id, outRpc, ctrl) {\n        const tograft = (ctrl.graft || [])\n            .filter(({ topicID }) => (topicID && this.mesh.get(topicID) || new Set()).has(id));\n        const toprune = (ctrl.prune || [])\n            .filter(({ topicID }) => !(topicID && this.mesh.get(topicID) || new Set()).has(id));\n        if (!tograft.length && !toprune.length) {\n            return;\n        }\n        if (outRpc.control) {\n            outRpc.control.graft = outRpc.control.graft && outRpc.control.graft.concat(tograft);\n            outRpc.control.prune = outRpc.control.prune && outRpc.control.prune.concat(toprune);\n        }\n        else {\n            outRpc.control = { ihave: [], iwant: [], graft: tograft, prune: toprune };\n        }\n    }\n    _piggybackGossip(id, outRpc, ihave) {\n        if (!outRpc.control) {\n            outRpc.control = { ihave: [], iwant: [], graft: [], prune: [] };\n        }\n        outRpc.control.ihave = ihave;\n    }\n    /**\n     * Send graft and prune messages\n     * @param {Map<string, Array<string>>} tograft peer id => topic[]\n     * @param {Map<string, Array<string>>} toprune peer id => topic[]\n     */\n    _sendGraftPrune(tograft, toprune, noPX) {\n        const doPX = this._options.doPX;\n        for (const [id, topics] of tograft) {\n            const graft = topics.map((topicID) => ({ topicID }));\n            let prune = [];\n            // If a peer also has prunes, process them now\n            const pruning = toprune.get(id);\n            if (pruning) {\n                prune = pruning.map((topicID) => this._makePrune(id, topicID, doPX && !noPX.get(id)));\n                toprune.delete(id);\n            }\n            const outRpc = utils_1.createGossipRpc([], { graft, prune });\n            this._sendRpc(id, outRpc);\n        }\n        for (const [id, topics] of toprune) {\n            const prune = topics.map((topicID) => this._makePrune(id, topicID, doPX && !noPX.get(id)));\n            const outRpc = utils_1.createGossipRpc([], { prune });\n            this._sendRpc(id, outRpc);\n        }\n    }\n    /**\n     * Emits gossip to peers in a particular topic\n     * @param {string} topic\n     * @param {Set<string>} exclude peers to exclude\n     * @returns {void}\n     */\n    _emitGossip(topic, exclude) {\n        const messageIDs = this.messageCache.getGossipIDs(topic);\n        if (!messageIDs.length) {\n            return;\n        }\n        // shuffle to emit in random order\n        utils_1.shuffle(messageIDs);\n        // if we are emitting more than GossipsubMaxIHaveLength ids, truncate the list\n        if (messageIDs.length > constants.GossipsubMaxIHaveLength) {\n            // we do the truncation (with shuffling) per peer below\n            this.log('too many messages for gossip; will truncate IHAVE list (%d messages)', messageIDs.length);\n        }\n        // Send gossip to GossipFactor peers above threshold with a minimum of D_lazy\n        // First we collect the peers above gossipThreshold that are not in the exclude set\n        // and then randomly select from that set\n        // We also exclude direct peers, as there is no reason to emit gossip to them\n        const peersToGossip = [];\n        const topicPeers = this.topics.get(topic);\n        if (!topicPeers) {\n            // no topic peers, no gossip\n            return;\n        }\n        topicPeers.forEach(id => {\n            const peerStreams = this.peers.get(id);\n            if (!peerStreams) {\n                return;\n            }\n            if (!exclude.has(id) &&\n                !this.direct.has(id) &&\n                utils_1.hasGossipProtocol(peerStreams.protocol) &&\n                this.score.score(id) >= this._options.scoreThresholds.gossipThreshold) {\n                peersToGossip.push(id);\n            }\n        });\n        let target = this._options.Dlazy;\n        const factor = constants.GossipsubGossipFactor * peersToGossip.length;\n        if (factor > target) {\n            target = factor;\n        }\n        if (target > peersToGossip.length) {\n            target = peersToGossip.length;\n        }\n        else {\n            utils_1.shuffle(peersToGossip);\n        }\n        // Emit the IHAVE gossip to the selected peers up to the target\n        peersToGossip.slice(0, target).forEach(id => {\n            let peerMessageIDs = messageIDs;\n            if (messageIDs.length > constants.GossipsubMaxIHaveLength) {\n                // shuffle and slice message IDs per peer so that we emit a different set for each peer\n                // we have enough reduncancy in the system that this will significantly increase the message\n                // coverage when we do truncate\n                peerMessageIDs = utils_1.shuffle(peerMessageIDs.slice()).slice(0, constants.GossipsubMaxIHaveLength);\n            }\n            this._pushGossip(id, {\n                topicID: topic,\n                messageIDs: peerMessageIDs\n            });\n        });\n    }\n    /**\n     * Flush gossip and control messages\n     */\n    _flush() {\n        // send gossip first, which will also piggyback control\n        for (const [peer, ihave] of this.gossip.entries()) {\n            this.gossip.delete(peer);\n            const out = utils_1.createGossipRpc([], { ihave });\n            this._sendRpc(peer, out);\n        }\n        // send the remaining control messages\n        for (const [peer, control] of this.control.entries()) {\n            this.control.delete(peer);\n            const out = utils_1.createGossipRpc([], { graft: control.graft, prune: control.prune });\n            this._sendRpc(peer, out);\n        }\n    }\n    /**\n     * Adds new IHAVE messages to pending gossip\n     * @param {PeerStreams} peerStreams\n     * @param {Array<RPC.IControlIHave>} controlIHaveMsgs\n     * @returns {void}\n     */\n    _pushGossip(id, controlIHaveMsgs) {\n        this.log('Add gossip to %s', id);\n        const gossip = this.gossip.get(id) || [];\n        this.gossip.set(id, gossip.concat(controlIHaveMsgs));\n    }\n    /**\n     * Returns the current time in milliseconds\n     * @returns {number}\n     */\n    _now() {\n        return Date.now();\n    }\n    /**\n     * Make a PRUNE control message for a peer in a topic\n     * @param {string} id\n     * @param {string} topic\n     * @param {boolean} doPX\n     * @returns {RPC.IControlPrune}\n     */\n    _makePrune(id, topic, doPX) {\n        if (this.peers.get(id).protocol === constants.GossipsubIDv10) {\n            // Gossipsub v1.0 -- no backoff, the peer won't be able to parse it anyway\n            return {\n                topicID: topic,\n                peers: []\n            };\n        }\n        // backoff is measured in seconds\n        // GossipsubPruneBackoff is measured in milliseconds\n        const backoff = constants.GossipsubPruneBackoff / 1000;\n        const px = [];\n        if (doPX) {\n            // select peers for Peer eXchange\n            const peers = get_gossip_peers_1.getGossipPeers(this, topic, constants.GossipsubPrunePeers, (xid) => {\n                return xid !== id && this.score.score(xid) >= 0;\n            });\n            peers.forEach(p => {\n                // see if we have a signed record to send back; if we don't, just send\n                // the peer ID and let the pruned peer find them in the DHT -- we can't trust\n                // unsigned address records through PX anyways\n                // Finding signed records in the DHT is not supported at the time of writing in js-libp2p\n                const peerId = PeerId.createFromB58String(p);\n                px.push({\n                    peerID: peerId.toBytes(),\n                    signedPeerRecord: this._libp2p.peerStore.addressBook.getRawEnvelope(peerId)\n                });\n            });\n        }\n        return {\n            topicID: topic,\n            peers: px,\n            backoff: backoff\n        };\n    }\n}\nGossipsub.multicodec = constants.GossipsubIDv11;\nmodule.exports = Gossipsub;\n"]},"metadata":{},"sourceType":"script"}