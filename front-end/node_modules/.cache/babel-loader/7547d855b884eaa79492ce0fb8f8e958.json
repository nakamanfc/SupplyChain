{"ast":null,"code":"'use strict';\n\nconst dagPb = require('@ipld/dag-pb');\n\nconst {\n  Errors\n} = require('interface-datastore');\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code;\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst toCIDAndPath = require('ipfs-core-utils/src/to-cid-and-path');\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst Format = {\n  default: '<dst>',\n  edges: '<src> -> <dst>'\n};\n/**\n * @typedef {object} Node\n * @property {string} [name]\n * @property {CID} cid\n *\n * @typedef {object} TraversalResult\n * @property {Node} parent\n * @property {Node} node\n * @property {boolean} isDuplicate\n */\n\n/**\n * @param {Object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n * @param {import('ipfs-core-types/src/root').API[\"resolve\"]} config.resolve\n * @param {import('../../types').Preload} config.preload\n */\n\nmodule.exports = function ({\n  repo,\n  codecs,\n  resolve,\n  preload\n}) {\n  /**\n   * @type {import('ipfs-core-types/src/refs').API[\"refs\"]}\n   */\n  async function* refs(ipfsPath, options = {}) {\n    if (options.maxDepth === 0) {\n      return;\n    }\n\n    if (options.edges && options.format && options.format !== Format.default) {\n      throw new Error('Cannot set edges to true and also specify format');\n    }\n\n    options.format = options.edges ? Format.edges : options.format;\n\n    if (typeof options.maxDepth !== 'number') {\n      options.maxDepth = options.recursive ? Infinity : 1;\n    }\n    /** @type {(string|CID)[]} */\n\n\n    const rawPaths = Array.isArray(ipfsPath) ? ipfsPath : [ipfsPath];\n    const paths = rawPaths.map(p => getFullPath(preload, p, options));\n\n    for (const path of paths) {\n      yield* refsStream(resolve, repo, codecs, path, options);\n    }\n  }\n\n  return withTimeoutOption(refs);\n};\n\nmodule.exports.Format = Format;\n/**\n * @param {import('../../types').Preload} preload\n * @param {string | CID} ipfsPath\n * @param {import('ipfs-core-types/src/refs').RefsOptions} options\n */\n\nfunction getFullPath(preload, ipfsPath, options) {\n  const {\n    cid,\n    path\n  } = toCIDAndPath(ipfsPath);\n\n  if (options.preload !== false) {\n    preload(cid);\n  }\n\n  return `/ipfs/${cid}${path || ''}`;\n}\n/**\n * Get a stream of refs at the given path\n *\n * @param {import('ipfs-core-types/src/root').API[\"resolve\"]} resolve\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {string} path\n * @param {import('ipfs-core-types/src/refs').RefsOptions} options\n */\n\n\nasync function* refsStream(resolve, repo, codecs, path, options) {\n  // Resolve to the target CID of the path\n  const resPath = await resolve(path);\n  const {\n    cid\n  } = toCIDAndPath(resPath);\n  const maxDepth = options.maxDepth != null ? options.maxDepth : Infinity;\n  const unique = options.unique || false; // Traverse the DAG, converting it into a stream\n\n  for await (const obj of objectStream(repo, codecs, cid, maxDepth, unique)) {\n    // Root object will not have a parent\n    if (!obj.parent) {\n      continue;\n    } // Filter out duplicates (isDuplicate flag is only set if options.unique is set)\n\n\n    if (obj.isDuplicate) {\n      continue;\n    } // Format the links\n    // Clients expect refs to be in the format { ref: <ref> }\n\n\n    yield {\n      ref: formatLink(obj.parent.cid, obj.node.cid, obj.node.name, options.format)\n    };\n  }\n}\n/**\n * Get formatted link\n *\n * @param {CID} srcCid\n * @param {CID} dstCid\n * @param {string} [linkName]\n * @param {string} [format]\n */\n\n\nfunction formatLink(srcCid, dstCid, linkName = '', format = Format.default) {\n  let out = format.replace(/<src>/g, srcCid.toString());\n  out = out.replace(/<dst>/g, dstCid.toString());\n  out = out.replace(/<linkname>/g, linkName);\n  return out;\n}\n/**\n * Do a depth first search of the DAG, starting from the given root cid\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {CID} rootCid\n * @param {number} maxDepth\n * @param {boolean} uniqueOnly\n */\n\n\nasync function* objectStream(repo, codecs, rootCid, maxDepth, uniqueOnly) {\n  // eslint-disable-line require-await\n  const seen = new Set();\n  /**\n   * @param {Node} parent\n   * @param {number} depth\n   * @returns {AsyncGenerator<TraversalResult, void, undefined>}\n   */\n\n  async function* traverseLevel(parent, depth) {\n    const nextLevelDepth = depth + 1; // Check the depth\n\n    if (nextLevelDepth > maxDepth) {\n      return;\n    } // Get this object's links\n\n\n    try {\n      // Look at each link, parent and the new depth\n      for await (const link of getLinks(repo, codecs, parent.cid)) {\n        yield {\n          parent: parent,\n          node: link,\n          isDuplicate: uniqueOnly && seen.has(link.cid.toString())\n        };\n\n        if (uniqueOnly) {\n          seen.add(link.cid.toString());\n        }\n\n        yield* traverseLevel(link, nextLevelDepth);\n      }\n    } catch (err) {\n      if (err.code === ERR_NOT_FOUND) {\n        err.message = `Could not find object with CID: ${parent.cid}`;\n      }\n\n      throw err;\n    }\n  }\n\n  yield* traverseLevel({\n    cid: rootCid\n  }, 0);\n}\n/**\n * Fetch a node and then get all its links\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {CID} cid\n * @param {Array<string|number>} base\n * @returns {AsyncGenerator<{ name: string, cid: CID }, void, undefined>}\n */\n\n\nasync function* getLinks(repo, codecs, cid, base = []) {\n  const block = await repo.blocks.get(cid);\n  const codec = await codecs.getCodec(cid.code);\n  const value = codec.decode(block);\n  const isDagPb = cid.code === dagPb.code;\n\n  for (const [name, cid] of links(value, base)) {\n    // special case for dag-pb - use the name of the link\n    // instead of the path within the object\n    if (isDagPb) {\n      const match = name.match(/^Links\\/(\\d+)\\/Hash$/);\n\n      if (match) {\n        const index = Number(match[1]);\n\n        if (index < value.Links.length) {\n          yield {\n            name: value.Links[index].Name,\n            cid\n          };\n          continue;\n        }\n      }\n    }\n\n    yield {\n      name,\n      cid\n    };\n  }\n}\n/**\n * @param {*} source\n * @param {Array<string|number>} base\n * @returns {Iterable<[string, CID]>}\n */\n\n\nconst links = function* (source, base) {\n  if (source == null) {\n    return;\n  }\n\n  if (source instanceof Uint8Array) {\n    return;\n  }\n\n  for (const [key, value] of Object.entries(source)) {\n    const path = [...base, key];\n\n    if (value != null && typeof value === 'object') {\n      if (Array.isArray(value)) {\n        for (const [index, element] of value.entries()) {\n          const elementPath = [...path, index];\n          const cid = CID.asCID(element); // eslint-disable-next-line max-depth\n\n          if (cid) {\n            yield [elementPath.join('/'), cid];\n          } else if (typeof element === 'object') {\n            yield* links(element, elementPath);\n          }\n        }\n      } else {\n        const cid = CID.asCID(value);\n\n        if (cid) {\n          yield [path.join('/'), cid];\n        } else {\n          yield* links(value, path);\n        }\n      }\n    }\n  } // ts requires a @returns annotation when a function is recursive,\n  // eslint requires a return when you use a @returns annotation.\n\n\n  return [];\n};","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/ipfs-core/src/components/refs/index.js"],"names":["dagPb","require","Errors","ERR_NOT_FOUND","notFoundError","code","withTimeoutOption","toCIDAndPath","CID","Format","default","edges","module","exports","repo","codecs","resolve","preload","refs","ipfsPath","options","maxDepth","format","Error","recursive","Infinity","rawPaths","Array","isArray","paths","map","p","getFullPath","path","refsStream","cid","resPath","unique","obj","objectStream","parent","isDuplicate","ref","formatLink","node","name","srcCid","dstCid","linkName","out","replace","toString","rootCid","uniqueOnly","seen","Set","traverseLevel","depth","nextLevelDepth","link","getLinks","has","add","err","message","base","block","blocks","get","codec","getCodec","value","decode","isDagPb","links","match","index","Number","Links","length","Name","source","Uint8Array","key","Object","entries","element","elementPath","asCID","join"],"mappings":"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","sourcesContent":["'use strict'\n\nconst dagPb = require('@ipld/dag-pb')\nconst { Errors } = require('interface-datastore')\nconst ERR_NOT_FOUND = Errors.notFoundError().code\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\nconst toCIDAndPath = require('ipfs-core-utils/src/to-cid-and-path')\nconst { CID } = require('multiformats/cid')\n\nconst Format = {\n  default: '<dst>',\n  edges: '<src> -> <dst>'\n}\n\n/**\n * @typedef {object} Node\n * @property {string} [name]\n * @property {CID} cid\n *\n * @typedef {object} TraversalResult\n * @property {Node} parent\n * @property {Node} node\n * @property {boolean} isDuplicate\n */\n\n/**\n * @param {Object} config\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n * @param {import('ipfs-core-types/src/root').API[\"resolve\"]} config.resolve\n * @param {import('../../types').Preload} config.preload\n */\nmodule.exports = function ({ repo, codecs, resolve, preload }) {\n  /**\n   * @type {import('ipfs-core-types/src/refs').API[\"refs\"]}\n   */\n  async function * refs (ipfsPath, options = {}) {\n    if (options.maxDepth === 0) {\n      return\n    }\n\n    if (options.edges && options.format && options.format !== Format.default) {\n      throw new Error('Cannot set edges to true and also specify format')\n    }\n\n    options.format = options.edges ? Format.edges : options.format\n\n    if (typeof options.maxDepth !== 'number') {\n      options.maxDepth = options.recursive ? Infinity : 1\n    }\n\n    /** @type {(string|CID)[]} */\n    const rawPaths = Array.isArray(ipfsPath) ? ipfsPath : [ipfsPath]\n\n    const paths = rawPaths.map(p => getFullPath(preload, p, options))\n\n    for (const path of paths) {\n      yield * refsStream(resolve, repo, codecs, path, options)\n    }\n  }\n\n  return withTimeoutOption(refs)\n}\n\nmodule.exports.Format = Format\n\n/**\n * @param {import('../../types').Preload} preload\n * @param {string | CID} ipfsPath\n * @param {import('ipfs-core-types/src/refs').RefsOptions} options\n */\nfunction getFullPath (preload, ipfsPath, options) {\n  const {\n    cid,\n    path\n  } = toCIDAndPath(ipfsPath)\n\n  if (options.preload !== false) {\n    preload(cid)\n  }\n\n  return `/ipfs/${cid}${path || ''}`\n}\n\n/**\n * Get a stream of refs at the given path\n *\n * @param {import('ipfs-core-types/src/root').API[\"resolve\"]} resolve\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {string} path\n * @param {import('ipfs-core-types/src/refs').RefsOptions} options\n */\nasync function * refsStream (resolve, repo, codecs, path, options) {\n  // Resolve to the target CID of the path\n  const resPath = await resolve(path)\n  const {\n    cid\n  } = toCIDAndPath(resPath)\n\n  const maxDepth = options.maxDepth != null ? options.maxDepth : Infinity\n  const unique = options.unique || false\n\n  // Traverse the DAG, converting it into a stream\n  for await (const obj of objectStream(repo, codecs, cid, maxDepth, unique)) {\n    // Root object will not have a parent\n    if (!obj.parent) {\n      continue\n    }\n\n    // Filter out duplicates (isDuplicate flag is only set if options.unique is set)\n    if (obj.isDuplicate) {\n      continue\n    }\n\n    // Format the links\n    // Clients expect refs to be in the format { ref: <ref> }\n    yield {\n      ref: formatLink(obj.parent.cid, obj.node.cid, obj.node.name, options.format)\n    }\n  }\n}\n\n/**\n * Get formatted link\n *\n * @param {CID} srcCid\n * @param {CID} dstCid\n * @param {string} [linkName]\n * @param {string} [format]\n */\nfunction formatLink (srcCid, dstCid, linkName = '', format = Format.default) {\n  let out = format.replace(/<src>/g, srcCid.toString())\n  out = out.replace(/<dst>/g, dstCid.toString())\n  out = out.replace(/<linkname>/g, linkName)\n  return out\n}\n\n/**\n * Do a depth first search of the DAG, starting from the given root cid\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {CID} rootCid\n * @param {number} maxDepth\n * @param {boolean} uniqueOnly\n */\nasync function * objectStream (repo, codecs, rootCid, maxDepth, uniqueOnly) { // eslint-disable-line require-await\n  const seen = new Set()\n\n  /**\n   * @param {Node} parent\n   * @param {number} depth\n   * @returns {AsyncGenerator<TraversalResult, void, undefined>}\n   */\n  async function * traverseLevel (parent, depth) {\n    const nextLevelDepth = depth + 1\n\n    // Check the depth\n    if (nextLevelDepth > maxDepth) {\n      return\n    }\n\n    // Get this object's links\n    try {\n      // Look at each link, parent and the new depth\n      for await (const link of getLinks(repo, codecs, parent.cid)) {\n        yield {\n          parent: parent,\n          node: link,\n          isDuplicate: uniqueOnly && seen.has(link.cid.toString())\n        }\n\n        if (uniqueOnly) {\n          seen.add(link.cid.toString())\n        }\n\n        yield * traverseLevel(link, nextLevelDepth)\n      }\n    } catch (err) {\n      if (err.code === ERR_NOT_FOUND) {\n        err.message = `Could not find object with CID: ${parent.cid}`\n      }\n\n      throw err\n    }\n  }\n\n  yield * traverseLevel({ cid: rootCid }, 0)\n}\n\n/**\n * Fetch a node and then get all its links\n *\n * @param {import('ipfs-repo').IPFSRepo} repo\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {CID} cid\n * @param {Array<string|number>} base\n * @returns {AsyncGenerator<{ name: string, cid: CID }, void, undefined>}\n */\nasync function * getLinks (repo, codecs, cid, base = []) {\n  const block = await repo.blocks.get(cid)\n  const codec = await codecs.getCodec(cid.code)\n  const value = codec.decode(block)\n  const isDagPb = cid.code === dagPb.code\n\n  for (const [name, cid] of links(value, base)) {\n    // special case for dag-pb - use the name of the link\n    // instead of the path within the object\n    if (isDagPb) {\n      const match = name.match(/^Links\\/(\\d+)\\/Hash$/)\n\n      if (match) {\n        const index = Number(match[1])\n\n        if (index < value.Links.length) {\n          yield {\n            name: value.Links[index].Name,\n            cid\n          }\n\n          continue\n        }\n      }\n    }\n\n    yield {\n      name,\n      cid\n    }\n  }\n}\n\n/**\n * @param {*} source\n * @param {Array<string|number>} base\n * @returns {Iterable<[string, CID]>}\n */\nconst links = function * (source, base) {\n  if (source == null) {\n    return\n  }\n\n  if (source instanceof Uint8Array) {\n    return\n  }\n\n  for (const [key, value] of Object.entries(source)) {\n    const path = [...base, key]\n\n    if (value != null && typeof value === 'object') {\n      if (Array.isArray(value)) {\n        for (const [index, element] of value.entries()) {\n          const elementPath = [...path, index]\n          const cid = CID.asCID(element)\n\n          // eslint-disable-next-line max-depth\n          if (cid) {\n            yield [elementPath.join('/'), cid]\n          } else if (typeof element === 'object') {\n            yield * links(element, elementPath)\n          }\n        }\n      } else {\n        const cid = CID.asCID(value)\n\n        if (cid) {\n          yield [path.join('/'), cid]\n        } else {\n          yield * links(value, path)\n        }\n      }\n    }\n  }\n\n  // ts requires a @returns annotation when a function is recursive,\n  // eslint requires a return when you use a @returns annotation.\n  return []\n}\n"]},"metadata":{},"sourceType":"script"}