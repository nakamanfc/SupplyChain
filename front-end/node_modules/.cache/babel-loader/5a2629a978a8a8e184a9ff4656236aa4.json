{"ast":null,"code":"'use strict';\n\nconst errcode = require('err-code');\n\nconst {\n  equals: uint8ArrayEquals\n} = require('uint8arrays/equals');\n\nconst {\n  sha256\n} = require('multiformats/hashes/sha2');\n\nconst {\n  base58btc\n} = require('multiformats/bases/base58');\n\nconst {\n  identity\n} = require('multiformats/hashes/identity');\n\nconst crypto = require('./ed25519');\n\nconst pbm = require('./keys');\n\nconst exporter = require('./exporter');\n\nclass Ed25519PublicKey {\n  constructor(key) {\n    this._key = ensureKey(key, crypto.publicKeyLength);\n  }\n\n  async verify(data, sig) {\n    // eslint-disable-line require-await\n    return crypto.hashAndVerify(this._key, sig, data);\n  }\n\n  marshal() {\n    return this._key;\n  }\n\n  get bytes() {\n    return pbm.PublicKey.encode({\n      Type: pbm.KeyType.Ed25519,\n      Data: this.marshal()\n    }).finish();\n  }\n\n  equals(key) {\n    return uint8ArrayEquals(this.bytes, key.bytes);\n  }\n\n  async hash() {\n    const {\n      bytes\n    } = await sha256.digest(this.bytes);\n    return bytes;\n  }\n\n}\n\nclass Ed25519PrivateKey {\n  // key       - 64 byte Uint8Array containing private key\n  // publicKey - 32 byte Uint8Array containing public key\n  constructor(key, publicKey) {\n    this._key = ensureKey(key, crypto.privateKeyLength);\n    this._publicKey = ensureKey(publicKey, crypto.publicKeyLength);\n  }\n\n  async sign(message) {\n    // eslint-disable-line require-await\n    return crypto.hashAndSign(this._key, message);\n  }\n\n  get public() {\n    return new Ed25519PublicKey(this._publicKey);\n  }\n\n  marshal() {\n    return this._key;\n  }\n\n  get bytes() {\n    return pbm.PrivateKey.encode({\n      Type: pbm.KeyType.Ed25519,\n      Data: this.marshal()\n    }).finish();\n  }\n\n  equals(key) {\n    return uint8ArrayEquals(this.bytes, key.bytes);\n  }\n\n  async hash() {\n    const {\n      bytes\n    } = await sha256.digest(this.bytes);\n    return bytes;\n  }\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the identity multihash containing its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   *\n   * @returns {Promise<string>}\n   */\n\n\n  async id() {\n    const encoding = await identity.digest(this.public.bytes);\n    return base58btc.encode(encoding.bytes).substring(1);\n  }\n  /**\n   * Exports the key into a password protected `format`\n   *\n   * @param {string} password - The password to encrypt the key\n   * @param {string} [format=libp2p-key] - The format in which to export as\n   * @returns {Promise<Uint8Array>} The encrypted private key\n   */\n\n\n  async export(password, format = 'libp2p-key') {\n    // eslint-disable-line require-await\n    if (format === 'libp2p-key') {\n      return exporter.export(this.bytes, password);\n    } else {\n      throw errcode(new Error(`export format '${format}' is not supported`), 'ERR_INVALID_EXPORT_FORMAT');\n    }\n  }\n\n}\n\nfunction unmarshalEd25519PrivateKey(bytes) {\n  // Try the old, redundant public key version\n  if (bytes.length > crypto.privateKeyLength) {\n    bytes = ensureKey(bytes, crypto.privateKeyLength + crypto.publicKeyLength);\n    const privateKeyBytes = bytes.slice(0, crypto.privateKeyLength);\n    const publicKeyBytes = bytes.slice(crypto.privateKeyLength, bytes.length);\n    return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);\n  }\n\n  bytes = ensureKey(bytes, crypto.privateKeyLength);\n  const privateKeyBytes = bytes.slice(0, crypto.privateKeyLength);\n  const publicKeyBytes = bytes.slice(crypto.publicKeyLength);\n  return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);\n}\n\nfunction unmarshalEd25519PublicKey(bytes) {\n  bytes = ensureKey(bytes, crypto.publicKeyLength);\n  return new Ed25519PublicKey(bytes);\n}\n\nasync function generateKeyPair() {\n  const {\n    privateKey,\n    publicKey\n  } = await crypto.generateKey();\n  return new Ed25519PrivateKey(privateKey, publicKey);\n}\n\nasync function generateKeyPairFromSeed(seed) {\n  const {\n    privateKey,\n    publicKey\n  } = await crypto.generateKeyFromSeed(seed);\n  return new Ed25519PrivateKey(privateKey, publicKey);\n}\n\nfunction ensureKey(key, length) {\n  key = Uint8Array.from(key || []);\n\n  if (key.length !== length) {\n    throw errcode(new Error(`Key must be a Uint8Array of length ${length}, got ${key.length}`), 'ERR_INVALID_KEY_TYPE');\n  }\n\n  return key;\n}\n\nmodule.exports = {\n  Ed25519PublicKey,\n  Ed25519PrivateKey,\n  unmarshalEd25519PrivateKey,\n  unmarshalEd25519PublicKey,\n  generateKeyPair,\n  generateKeyPairFromSeed\n};","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/libp2p-crypto/src/keys/ed25519-class.js"],"names":["errcode","require","equals","uint8ArrayEquals","sha256","base58btc","identity","crypto","pbm","exporter","Ed25519PublicKey","constructor","key","_key","ensureKey","publicKeyLength","verify","data","sig","hashAndVerify","marshal","bytes","PublicKey","encode","Type","KeyType","Ed25519","Data","finish","hash","digest","Ed25519PrivateKey","publicKey","privateKeyLength","_publicKey","sign","message","hashAndSign","public","PrivateKey","id","encoding","substring","export","password","format","Error","unmarshalEd25519PrivateKey","length","privateKeyBytes","slice","publicKeyBytes","unmarshalEd25519PublicKey","generateKeyPair","privateKey","generateKey","generateKeyPairFromSeed","seed","generateKeyFromSeed","Uint8Array","from","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAM;AAAEC,EAAAA,MAAM,EAAEC;AAAV,IAA+BF,OAAO,CAAC,oBAAD,CAA5C;;AACA,MAAM;AAAEG,EAAAA;AAAF,IAAaH,OAAO,CAAC,0BAAD,CAA1B;;AACA,MAAM;AAAEI,EAAAA;AAAF,IAAgBJ,OAAO,CAAC,2BAAD,CAA7B;;AACA,MAAM;AAAEK,EAAAA;AAAF,IAAeL,OAAO,CAAC,8BAAD,CAA5B;;AACA,MAAMM,MAAM,GAAGN,OAAO,CAAC,WAAD,CAAtB;;AACA,MAAMO,GAAG,GAAGP,OAAO,CAAC,QAAD,CAAnB;;AACA,MAAMQ,QAAQ,GAAGR,OAAO,CAAC,YAAD,CAAxB;;AAEA,MAAMS,gBAAN,CAAuB;AACrBC,EAAAA,WAAW,CAAEC,GAAF,EAAO;AAChB,SAAKC,IAAL,GAAYC,SAAS,CAACF,GAAD,EAAML,MAAM,CAACQ,eAAb,CAArB;AACD;;AAEW,QAANC,MAAM,CAAEC,IAAF,EAAQC,GAAR,EAAa;AAAE;AACzB,WAAOX,MAAM,CAACY,aAAP,CAAqB,KAAKN,IAA1B,EAAgCK,GAAhC,EAAqCD,IAArC,CAAP;AACD;;AAEDG,EAAAA,OAAO,GAAI;AACT,WAAO,KAAKP,IAAZ;AACD;;AAEQ,MAALQ,KAAK,GAAI;AACX,WAAOb,GAAG,CAACc,SAAJ,CAAcC,MAAd,CAAqB;AAC1BC,MAAAA,IAAI,EAAEhB,GAAG,CAACiB,OAAJ,CAAYC,OADQ;AAE1BC,MAAAA,IAAI,EAAE,KAAKP,OAAL;AAFoB,KAArB,EAGJQ,MAHI,EAAP;AAID;;AAED1B,EAAAA,MAAM,CAAEU,GAAF,EAAO;AACX,WAAOT,gBAAgB,CAAC,KAAKkB,KAAN,EAAaT,GAAG,CAACS,KAAjB,CAAvB;AACD;;AAES,QAAJQ,IAAI,GAAI;AACZ,UAAM;AAAER,MAAAA;AAAF,QAAY,MAAMjB,MAAM,CAAC0B,MAAP,CAAc,KAAKT,KAAnB,CAAxB;AAEA,WAAOA,KAAP;AACD;;AA5BoB;;AA+BvB,MAAMU,iBAAN,CAAwB;AACtB;AACA;AACApB,EAAAA,WAAW,CAAEC,GAAF,EAAOoB,SAAP,EAAkB;AAC3B,SAAKnB,IAAL,GAAYC,SAAS,CAACF,GAAD,EAAML,MAAM,CAAC0B,gBAAb,CAArB;AACA,SAAKC,UAAL,GAAkBpB,SAAS,CAACkB,SAAD,EAAYzB,MAAM,CAACQ,eAAnB,CAA3B;AACD;;AAES,QAAJoB,IAAI,CAAEC,OAAF,EAAW;AAAE;AACrB,WAAO7B,MAAM,CAAC8B,WAAP,CAAmB,KAAKxB,IAAxB,EAA8BuB,OAA9B,CAAP;AACD;;AAES,MAANE,MAAM,GAAI;AACZ,WAAO,IAAI5B,gBAAJ,CAAqB,KAAKwB,UAA1B,CAAP;AACD;;AAEDd,EAAAA,OAAO,GAAI;AACT,WAAO,KAAKP,IAAZ;AACD;;AAEQ,MAALQ,KAAK,GAAI;AACX,WAAOb,GAAG,CAAC+B,UAAJ,CAAehB,MAAf,CAAsB;AAC3BC,MAAAA,IAAI,EAAEhB,GAAG,CAACiB,OAAJ,CAAYC,OADS;AAE3BC,MAAAA,IAAI,EAAE,KAAKP,OAAL;AAFqB,KAAtB,EAGJQ,MAHI,EAAP;AAID;;AAED1B,EAAAA,MAAM,CAAEU,GAAF,EAAO;AACX,WAAOT,gBAAgB,CAAC,KAAKkB,KAAN,EAAaT,GAAG,CAACS,KAAjB,CAAvB;AACD;;AAES,QAAJQ,IAAI,GAAI;AACZ,UAAM;AAAER,MAAAA;AAAF,QAAY,MAAMjB,MAAM,CAAC0B,MAAP,CAAc,KAAKT,KAAnB,CAAxB;AAEA,WAAOA,KAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACU,QAAFmB,EAAE,GAAI;AACV,UAAMC,QAAQ,GAAG,MAAMnC,QAAQ,CAACwB,MAAT,CAAgB,KAAKQ,MAAL,CAAYjB,KAA5B,CAAvB;AACA,WAAOhB,SAAS,CAACkB,MAAV,CAAiBkB,QAAQ,CAACpB,KAA1B,EAAiCqB,SAAjC,CAA2C,CAA3C,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AACc,QAANC,MAAM,CAAEC,QAAF,EAAYC,MAAM,GAAG,YAArB,EAAmC;AAAE;AAC/C,QAAIA,MAAM,KAAK,YAAf,EAA6B;AAC3B,aAAOpC,QAAQ,CAACkC,MAAT,CAAgB,KAAKtB,KAArB,EAA4BuB,QAA5B,CAAP;AACD,KAFD,MAEO;AACL,YAAM5C,OAAO,CAAC,IAAI8C,KAAJ,CAAW,kBAAiBD,MAAO,oBAAnC,CAAD,EAA0D,2BAA1D,CAAb;AACD;AACF;;AAhEqB;;AAmExB,SAASE,0BAAT,CAAqC1B,KAArC,EAA4C;AAC1C;AACA,MAAIA,KAAK,CAAC2B,MAAN,GAAezC,MAAM,CAAC0B,gBAA1B,EAA4C;AAC1CZ,IAAAA,KAAK,GAAGP,SAAS,CAACO,KAAD,EAAQd,MAAM,CAAC0B,gBAAP,GAA0B1B,MAAM,CAACQ,eAAzC,CAAjB;AACA,UAAMkC,eAAe,GAAG5B,KAAK,CAAC6B,KAAN,CAAY,CAAZ,EAAe3C,MAAM,CAAC0B,gBAAtB,CAAxB;AACA,UAAMkB,cAAc,GAAG9B,KAAK,CAAC6B,KAAN,CAAY3C,MAAM,CAAC0B,gBAAnB,EAAqCZ,KAAK,CAAC2B,MAA3C,CAAvB;AACA,WAAO,IAAIjB,iBAAJ,CAAsBkB,eAAtB,EAAuCE,cAAvC,CAAP;AACD;;AAED9B,EAAAA,KAAK,GAAGP,SAAS,CAACO,KAAD,EAAQd,MAAM,CAAC0B,gBAAf,CAAjB;AACA,QAAMgB,eAAe,GAAG5B,KAAK,CAAC6B,KAAN,CAAY,CAAZ,EAAe3C,MAAM,CAAC0B,gBAAtB,CAAxB;AACA,QAAMkB,cAAc,GAAG9B,KAAK,CAAC6B,KAAN,CAAY3C,MAAM,CAACQ,eAAnB,CAAvB;AACA,SAAO,IAAIgB,iBAAJ,CAAsBkB,eAAtB,EAAuCE,cAAvC,CAAP;AACD;;AAED,SAASC,yBAAT,CAAoC/B,KAApC,EAA2C;AACzCA,EAAAA,KAAK,GAAGP,SAAS,CAACO,KAAD,EAAQd,MAAM,CAACQ,eAAf,CAAjB;AACA,SAAO,IAAIL,gBAAJ,CAAqBW,KAArB,CAAP;AACD;;AAED,eAAegC,eAAf,GAAkC;AAChC,QAAM;AAAEC,IAAAA,UAAF;AAActB,IAAAA;AAAd,MAA4B,MAAMzB,MAAM,CAACgD,WAAP,EAAxC;AACA,SAAO,IAAIxB,iBAAJ,CAAsBuB,UAAtB,EAAkCtB,SAAlC,CAAP;AACD;;AAED,eAAewB,uBAAf,CAAwCC,IAAxC,EAA8C;AAC5C,QAAM;AAAEH,IAAAA,UAAF;AAActB,IAAAA;AAAd,MAA4B,MAAMzB,MAAM,CAACmD,mBAAP,CAA2BD,IAA3B,CAAxC;AACA,SAAO,IAAI1B,iBAAJ,CAAsBuB,UAAtB,EAAkCtB,SAAlC,CAAP;AACD;;AAED,SAASlB,SAAT,CAAoBF,GAApB,EAAyBoC,MAAzB,EAAiC;AAC/BpC,EAAAA,GAAG,GAAG+C,UAAU,CAACC,IAAX,CAAgBhD,GAAG,IAAI,EAAvB,CAAN;;AACA,MAAIA,GAAG,CAACoC,MAAJ,KAAeA,MAAnB,EAA2B;AACzB,UAAMhD,OAAO,CAAC,IAAI8C,KAAJ,CAAW,sCAAqCE,MAAO,SAAQpC,GAAG,CAACoC,MAAO,EAA1E,CAAD,EAA+E,sBAA/E,CAAb;AACD;;AACD,SAAOpC,GAAP;AACD;;AAEDiD,MAAM,CAACC,OAAP,GAAiB;AACfpD,EAAAA,gBADe;AAEfqB,EAAAA,iBAFe;AAGfgB,EAAAA,0BAHe;AAIfK,EAAAA,yBAJe;AAKfC,EAAAA,eALe;AAMfG,EAAAA;AANe,CAAjB","sourcesContent":["'use strict'\n\nconst errcode = require('err-code')\nconst { equals: uint8ArrayEquals } = require('uint8arrays/equals')\nconst { sha256 } = require('multiformats/hashes/sha2')\nconst { base58btc } = require('multiformats/bases/base58')\nconst { identity } = require('multiformats/hashes/identity')\nconst crypto = require('./ed25519')\nconst pbm = require('./keys')\nconst exporter = require('./exporter')\n\nclass Ed25519PublicKey {\n  constructor (key) {\n    this._key = ensureKey(key, crypto.publicKeyLength)\n  }\n\n  async verify (data, sig) { // eslint-disable-line require-await\n    return crypto.hashAndVerify(this._key, sig, data)\n  }\n\n  marshal () {\n    return this._key\n  }\n\n  get bytes () {\n    return pbm.PublicKey.encode({\n      Type: pbm.KeyType.Ed25519,\n      Data: this.marshal()\n    }).finish()\n  }\n\n  equals (key) {\n    return uint8ArrayEquals(this.bytes, key.bytes)\n  }\n\n  async hash () {\n    const { bytes } = await sha256.digest(this.bytes)\n\n    return bytes\n  }\n}\n\nclass Ed25519PrivateKey {\n  // key       - 64 byte Uint8Array containing private key\n  // publicKey - 32 byte Uint8Array containing public key\n  constructor (key, publicKey) {\n    this._key = ensureKey(key, crypto.privateKeyLength)\n    this._publicKey = ensureKey(publicKey, crypto.publicKeyLength)\n  }\n\n  async sign (message) { // eslint-disable-line require-await\n    return crypto.hashAndSign(this._key, message)\n  }\n\n  get public () {\n    return new Ed25519PublicKey(this._publicKey)\n  }\n\n  marshal () {\n    return this._key\n  }\n\n  get bytes () {\n    return pbm.PrivateKey.encode({\n      Type: pbm.KeyType.Ed25519,\n      Data: this.marshal()\n    }).finish()\n  }\n\n  equals (key) {\n    return uint8ArrayEquals(this.bytes, key.bytes)\n  }\n\n  async hash () {\n    const { bytes } = await sha256.digest(this.bytes)\n\n    return bytes\n  }\n\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the identity multihash containing its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   *\n   * @returns {Promise<string>}\n   */\n  async id () {\n    const encoding = await identity.digest(this.public.bytes)\n    return base58btc.encode(encoding.bytes).substring(1)\n  }\n\n  /**\n   * Exports the key into a password protected `format`\n   *\n   * @param {string} password - The password to encrypt the key\n   * @param {string} [format=libp2p-key] - The format in which to export as\n   * @returns {Promise<Uint8Array>} The encrypted private key\n   */\n  async export (password, format = 'libp2p-key') { // eslint-disable-line require-await\n    if (format === 'libp2p-key') {\n      return exporter.export(this.bytes, password)\n    } else {\n      throw errcode(new Error(`export format '${format}' is not supported`), 'ERR_INVALID_EXPORT_FORMAT')\n    }\n  }\n}\n\nfunction unmarshalEd25519PrivateKey (bytes) {\n  // Try the old, redundant public key version\n  if (bytes.length > crypto.privateKeyLength) {\n    bytes = ensureKey(bytes, crypto.privateKeyLength + crypto.publicKeyLength)\n    const privateKeyBytes = bytes.slice(0, crypto.privateKeyLength)\n    const publicKeyBytes = bytes.slice(crypto.privateKeyLength, bytes.length)\n    return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes)\n  }\n\n  bytes = ensureKey(bytes, crypto.privateKeyLength)\n  const privateKeyBytes = bytes.slice(0, crypto.privateKeyLength)\n  const publicKeyBytes = bytes.slice(crypto.publicKeyLength)\n  return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes)\n}\n\nfunction unmarshalEd25519PublicKey (bytes) {\n  bytes = ensureKey(bytes, crypto.publicKeyLength)\n  return new Ed25519PublicKey(bytes)\n}\n\nasync function generateKeyPair () {\n  const { privateKey, publicKey } = await crypto.generateKey()\n  return new Ed25519PrivateKey(privateKey, publicKey)\n}\n\nasync function generateKeyPairFromSeed (seed) {\n  const { privateKey, publicKey } = await crypto.generateKeyFromSeed(seed)\n  return new Ed25519PrivateKey(privateKey, publicKey)\n}\n\nfunction ensureKey (key, length) {\n  key = Uint8Array.from(key || [])\n  if (key.length !== length) {\n    throw errcode(new Error(`Key must be a Uint8Array of length ${length}, got ${key.length}`), 'ERR_INVALID_KEY_TYPE')\n  }\n  return key\n}\n\nmodule.exports = {\n  Ed25519PublicKey,\n  Ed25519PrivateKey,\n  unmarshalEd25519PrivateKey,\n  unmarshalEd25519PublicKey,\n  generateKeyPair,\n  generateKeyPairFromSeed\n}\n"]},"metadata":{},"sourceType":"script"}