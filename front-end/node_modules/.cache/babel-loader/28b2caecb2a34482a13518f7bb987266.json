{"ast":null,"code":"'use strict';\n\nconst {\n  Key\n} = require('interface-datastore');\n\nconst {\n  default: Queue\n} = require('p-queue');\n\nconst _get = require('just-safe-get');\n\nconst _set = require('just-safe-set');\n\nconst errCode = require('err-code');\n\nconst errors = require('./errors');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n\nconst {\n  hasWithFallback,\n  getWithFallback // @ts-ignore\n\n} = require('ipfs-repo-migrations/src/utils');\n\nconst configKey = new Key('config');\n/**\n * @typedef {import('./types').Config} Config\n */\n\n/**\n * @param {import('interface-datastore').Datastore} store\n */\n\nmodule.exports = store => {\n  const setQueue = new Queue({\n    concurrency: 1\n  });\n  const configStore = {\n    /**\n     * Get the current configuration from the repo.\n     *\n     * @param {Object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config read\n     * @returns {Promise<Config>}\n     */\n    async getAll(options = {}) {\n      // eslint-disable-line require-await\n      // level-js@5.x cannot read keys from level-js@4.x dbs so fall back to\n      // using IndexedDB API with string keys - only necessary until we do\n      // the migratiion to v10 or above\n      const encodedValue = await getWithFallback(configKey, store.get.bind(store), store.has.bind(store), store, {\n        signal: options.signal\n      });\n      return JSON.parse(uint8ArrayToString(encodedValue));\n    },\n\n    /**\n     * Get the value for the passed configuration key from the repo.\n     *\n     * @param {string} key - the config key to get\n     * @param {Object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config read\n     */\n    async get(key, options = {}) {\n      if (key == null) {\n        throw new errors.NotFoundError(`Key ${key} does not exist in config`);\n      }\n\n      const config = await this.getAll(options);\n\n      const value = _get(config, key);\n\n      if (value === undefined) {\n        throw new errors.NotFoundError(`Key ${key} does not exist in config`);\n      }\n\n      return value;\n    },\n\n    /**\n     * Set the current configuration for this repo.\n     *\n     * @param {string} key - the config key to be written\n     * @param {any} [value] - the config value to be written\n     * @param {Object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config write\n     */\n    set(key, value, options = {}) {\n      // @ts-ignore ts thinks key will only be a string, but it may not be\n      if (typeof key !== 'string' && !(key instanceof String)) {\n        throw errCode(new Error('Invalid key type: ' + typeof key), 'ERR_INVALID_KEY');\n      }\n\n      if (value === undefined || value instanceof Uint8Array) {\n        throw errCode(new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE');\n      }\n\n      return setQueue.add(() => _maybeDoSet({\n        key: key,\n        value: value\n      }, options.signal));\n    },\n\n    /**\n     * Set the current configuration for this repo.\n     *\n     * @param {Config} [value] - the config value to be written\n     * @param {Object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config write\n     */\n    replace(value, options = {}) {\n      if (!value || value instanceof Uint8Array) {\n        throw errCode(new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE');\n      }\n\n      return setQueue.add(() => _maybeDoSet({\n        key: undefined,\n        value: value\n      }, options.signal));\n    },\n\n    /**\n     * Check if a config file exists.\n     *\n     */\n    async exists() {\n      // eslint-disable-line require-await\n      // level-js@5.x cannot read keys from level-js@4.x dbs so fall back to\n      // using IndexedDB API with string keys - only necessary until we do\n      // the migratiion to v10 or above\n      return hasWithFallback(configKey, store.has.bind(store), store);\n    }\n\n  };\n  return configStore;\n  /**\n   * @param {{ key: any; value: any; }} m\n   * @param {AbortSignal | undefined} signal\n   */\n\n  async function _maybeDoSet(m, signal) {\n    if (signal && signal.aborted) {\n      return;\n    }\n\n    const key = m.key;\n    const value = m.value;\n\n    if (key) {\n      const config = await configStore.getAll();\n\n      if (typeof config === 'object' && config !== null) {\n        _set(config, key, value);\n      }\n\n      return _saveAll(config);\n    }\n\n    return _saveAll(value);\n  }\n  /**\n   * @param {unknown} config\n   */\n\n\n  function _saveAll(config) {\n    const buf = uint8ArrayFromString(JSON.stringify(config, null, 2));\n    return store.put(configKey, buf);\n  }\n};","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/ipfs-repo/src/config.js"],"names":["Key","require","default","Queue","_get","_set","errCode","errors","toString","uint8ArrayToString","fromString","uint8ArrayFromString","hasWithFallback","getWithFallback","configKey","module","exports","store","setQueue","concurrency","configStore","getAll","options","encodedValue","get","bind","has","signal","JSON","parse","key","NotFoundError","config","value","undefined","set","String","Error","Uint8Array","add","_maybeDoSet","replace","exists","m","aborted","_saveAll","buf","stringify","put"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Key } = require('interface-datastore')\nconst { default: Queue } = require('p-queue')\nconst _get = require('just-safe-get')\nconst _set = require('just-safe-set')\nconst errCode = require('err-code')\nconst errors = require('./errors')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\nconst {\n  hasWithFallback,\n  getWithFallback\n// @ts-ignore\n} = require('ipfs-repo-migrations/src/utils')\n\nconst configKey = new Key('config')\n\n/**\n * @typedef {import('./types').Config} Config\n */\n\n/**\n * @param {import('interface-datastore').Datastore} store\n */\nmodule.exports = (store) => {\n  const setQueue = new Queue({ concurrency: 1 })\n\n  const configStore = {\n    /**\n     * Get the current configuration from the repo.\n     *\n     * @param {Object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config read\n     * @returns {Promise<Config>}\n     */\n    async getAll (options = {}) { // eslint-disable-line require-await\n      // level-js@5.x cannot read keys from level-js@4.x dbs so fall back to\n      // using IndexedDB API with string keys - only necessary until we do\n      // the migratiion to v10 or above\n      const encodedValue = await getWithFallback(configKey, store.get.bind(store), store.has.bind(store), store, {\n        signal: options.signal\n      })\n\n      return JSON.parse(uint8ArrayToString(encodedValue))\n    },\n\n    /**\n     * Get the value for the passed configuration key from the repo.\n     *\n     * @param {string} key - the config key to get\n     * @param {Object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config read\n     */\n    async get (key, options = {}) {\n      if (key == null) {\n        throw new errors.NotFoundError(`Key ${key} does not exist in config`)\n      }\n\n      const config = await this.getAll(options)\n      const value = _get(config, key)\n\n      if (value === undefined) {\n        throw new errors.NotFoundError(`Key ${key} does not exist in config`)\n      }\n\n      return value\n    },\n\n    /**\n     * Set the current configuration for this repo.\n     *\n     * @param {string} key - the config key to be written\n     * @param {any} [value] - the config value to be written\n     * @param {Object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config write\n     */\n    set (key, value, options = {}) {\n      // @ts-ignore ts thinks key will only be a string, but it may not be\n      if (typeof key !== 'string' && !(key instanceof String)) {\n        throw errCode(new Error('Invalid key type: ' + typeof key), 'ERR_INVALID_KEY')\n      }\n\n      if (value === undefined || (value instanceof Uint8Array)) {\n        throw errCode(new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE')\n      }\n\n      return setQueue.add(() => _maybeDoSet({\n        key: key,\n        value: value\n      }, options.signal))\n    },\n\n    /**\n     * Set the current configuration for this repo.\n     *\n     * @param {Config} [value] - the config value to be written\n     * @param {Object} [options] - options\n     * @param {AbortSignal} [options.signal] - abort this config write\n     */\n    replace (value, options = {}) {\n      if (!value || (value instanceof Uint8Array)) {\n        throw errCode(new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE')\n      }\n\n      return setQueue.add(() => _maybeDoSet({\n        key: undefined,\n        value: value\n      }, options.signal))\n    },\n\n    /**\n     * Check if a config file exists.\n     *\n     */\n    async exists () { // eslint-disable-line require-await\n      // level-js@5.x cannot read keys from level-js@4.x dbs so fall back to\n      // using IndexedDB API with string keys - only necessary until we do\n      // the migratiion to v10 or above\n      return hasWithFallback(configKey, store.has.bind(store), store)\n    }\n  }\n\n  return configStore\n\n  /**\n   * @param {{ key: any; value: any; }} m\n   * @param {AbortSignal | undefined} signal\n   */\n  async function _maybeDoSet (m, signal) {\n    if (signal && signal.aborted) {\n      return\n    }\n\n    const key = m.key\n    const value = m.value\n    if (key) {\n      const config = await configStore.getAll()\n      if (typeof config === 'object' && config !== null) {\n        _set(config, key, value)\n      }\n      return _saveAll(config)\n    }\n    return _saveAll(value)\n  }\n\n  /**\n   * @param {unknown} config\n   */\n  function _saveAll (config) {\n    const buf = uint8ArrayFromString(JSON.stringify(config, null, 2))\n    return store.put(configKey, buf)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}