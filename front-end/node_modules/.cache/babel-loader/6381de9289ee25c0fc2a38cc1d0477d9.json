{"ast":null,"code":"'use strict';\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst dagPb = require('@ipld/dag-pb');\n\nconst cbor = require('cborg');\n\nconst pinset = require('./pin-set');\n\nconst {\n  cidToKey,\n  PIN_DS_KEY,\n  PinTypes\n} = require('./utils');\n\nconst length = require('it-length');\n\nconst {\n  sha256\n} = require('multiformats/hashes/sha2');\n\nconst mhd = require('multiformats/hashes/digest');\n\nconst {\n  base32\n} = require('multiformats/bases/base32');\n/**\n * @typedef {import('../../src/types').Migration} Migration\n * @typedef {import('../../src/types').MigrationProgressCallback} MigrationProgressCallback\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n */\n\n/**\n * @param {Blockstore} blockstore\n * @param {Datastore} datastore\n * @param {Datastore} pinstore\n * @param {MigrationProgressCallback} onProgress\n */\n\n\nasync function pinsToDatastore(blockstore, datastore, pinstore, onProgress) {\n  if (!(await datastore.has(PIN_DS_KEY))) {\n    return;\n  }\n\n  const mh = await datastore.get(PIN_DS_KEY);\n  const cid = CID.decode(mh);\n  const pinRootBuf = await blockstore.get(cid);\n  const pinRoot = dagPb.decode(pinRootBuf);\n  let counter = 0;\n  const pinCount = (await length(pinset.loadSet(blockstore, pinRoot, PinTypes.recursive))) + (await length(pinset.loadSet(blockstore, pinRoot, PinTypes.direct)));\n\n  for await (const cid of pinset.loadSet(blockstore, pinRoot, PinTypes.recursive)) {\n    counter++;\n    /** @type {{ depth: number, version?: CIDVersion, codec?: number }} */\n\n    const pin = {\n      depth: Infinity\n    };\n\n    if (cid.version !== 0) {\n      pin.version = cid.version;\n    }\n\n    if (cid.code !== dagPb.code) {\n      pin.codec = cid.code;\n    }\n\n    await pinstore.put(cidToKey(cid), cbor.encode(pin));\n    onProgress(counter / pinCount * 100, `Migrated recursive pin ${cid}`);\n  }\n\n  for await (const cid of pinset.loadSet(blockstore, pinRoot, PinTypes.direct)) {\n    counter++;\n    /** @type {{ depth: number, version?: CIDVersion, codec?: number }} */\n\n    const pin = {\n      depth: 0\n    };\n\n    if (cid.version !== 0) {\n      pin.version = cid.version;\n    }\n\n    if (cid.code !== dagPb.code) {\n      pin.codec = cid.code;\n    }\n\n    await pinstore.put(cidToKey(cid), cbor.encode(pin));\n    onProgress(counter / pinCount * 100, `Migrated direct pin ${cid}`);\n  }\n\n  await blockstore.delete(cid);\n  await datastore.delete(PIN_DS_KEY);\n}\n/**\n * @param {Blockstore} blockstore\n * @param {Datastore} datastore\n * @param {Datastore} pinstore\n * @param {MigrationProgressCallback} onProgress\n */\n\n\nasync function pinsToDAG(blockstore, datastore, pinstore, onProgress) {\n  const recursivePins = [];\n  const directPins = [];\n  let counter = 0;\n  const pinCount = await length(pinstore.queryKeys({}));\n\n  for await (const {\n    key,\n    value\n  } of pinstore.query({})) {\n    counter++;\n    const pin = cbor.decode(value);\n    const cid = CID.create(pin.version || 0, pin.codec || dagPb.code, mhd.decode(base32.decode('b' + key.toString().toLowerCase().split('/').pop())));\n\n    if (pin.depth === 0) {\n      onProgress(counter / pinCount * 100, `Reverted direct pin ${cid}`);\n      directPins.push(cid);\n    } else {\n      onProgress(counter / pinCount * 100, `Reverted recursive pin ${cid}`);\n      recursivePins.push(cid);\n    }\n  }\n\n  onProgress(100, 'Updating pin root');\n  const pinRoot = {\n    Links: [await pinset.storeSet(blockstore, PinTypes.direct, directPins), await pinset.storeSet(blockstore, PinTypes.recursive, recursivePins)]\n  };\n  const buf = dagPb.encode(pinRoot);\n  const digest = await sha256.digest(buf);\n  const cid = CID.createV0(digest);\n  await blockstore.put(cid, buf);\n  await datastore.put(PIN_DS_KEY, cid.bytes);\n}\n/**\n * @param {import('../../src/types').Backends} backends\n * @param {MigrationProgressCallback} onProgress\n * @param {*} fn\n */\n\n\nasync function process(backends, onProgress, fn) {\n  const blockstore = backends.blocks;\n  const datastore = backends.datastore;\n  const pinstore = backends.pins;\n  await blockstore.open();\n  await datastore.open();\n  await pinstore.open();\n\n  try {\n    await fn(blockstore, datastore, pinstore, onProgress);\n  } finally {\n    await pinstore.close();\n    await datastore.close();\n    await blockstore.close();\n  }\n}\n/** @type {Migration} */\n\n\nmodule.exports = {\n  version: 9,\n  description: 'Migrates pins to datastore',\n  migrate: (backends, onProgress = () => {}) => {\n    return process(backends, onProgress, pinsToDatastore);\n  },\n  revert: (backends, onProgress = () => {}) => {\n    return process(backends, onProgress, pinsToDAG);\n  }\n};","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/ipfs-repo-migrations/migrations/migration-9/index.js"],"names":["CID","require","dagPb","cbor","pinset","cidToKey","PIN_DS_KEY","PinTypes","length","sha256","mhd","base32","pinsToDatastore","blockstore","datastore","pinstore","onProgress","has","mh","get","cid","decode","pinRootBuf","pinRoot","counter","pinCount","loadSet","recursive","direct","pin","depth","Infinity","version","code","codec","put","encode","delete","pinsToDAG","recursivePins","directPins","queryKeys","key","value","query","create","toString","toLowerCase","split","pop","push","Links","storeSet","buf","digest","createV0","bytes","process","backends","fn","blocks","pins","open","close","module","exports","description","migrate","revert"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { CID } = require('multiformats/cid')\nconst dagPb = require('@ipld/dag-pb')\nconst cbor = require('cborg')\nconst pinset = require('./pin-set')\nconst { cidToKey, PIN_DS_KEY, PinTypes } = require('./utils')\nconst length = require('it-length')\nconst { sha256 } = require('multiformats/hashes/sha2')\nconst mhd = require('multiformats/hashes/digest')\nconst { base32 } = require('multiformats/bases/base32')\n\n/**\n * @typedef {import('../../src/types').Migration} Migration\n * @typedef {import('../../src/types').MigrationProgressCallback} MigrationProgressCallback\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('multiformats/cid').CIDVersion} CIDVersion\n */\n\n/**\n * @param {Blockstore} blockstore\n * @param {Datastore} datastore\n * @param {Datastore} pinstore\n * @param {MigrationProgressCallback} onProgress\n */\nasync function pinsToDatastore (blockstore, datastore, pinstore, onProgress) {\n  if (!await datastore.has(PIN_DS_KEY)) {\n    return\n  }\n\n  const mh = await datastore.get(PIN_DS_KEY)\n  const cid = CID.decode(mh)\n  const pinRootBuf = await blockstore.get(cid)\n  const pinRoot = dagPb.decode(pinRootBuf)\n  let counter = 0\n  const pinCount = (await length(pinset.loadSet(blockstore, pinRoot, PinTypes.recursive))) + (await length(pinset.loadSet(blockstore, pinRoot, PinTypes.direct)))\n\n  for await (const cid of pinset.loadSet(blockstore, pinRoot, PinTypes.recursive)) {\n    counter++\n\n    /** @type {{ depth: number, version?: CIDVersion, codec?: number }} */\n    const pin = {\n      depth: Infinity\n    }\n\n    if (cid.version !== 0) {\n      pin.version = cid.version\n    }\n\n    if (cid.code !== dagPb.code) {\n      pin.codec = cid.code\n    }\n\n    await pinstore.put(cidToKey(cid), cbor.encode(pin))\n\n    onProgress((counter / pinCount) * 100, `Migrated recursive pin ${cid}`)\n  }\n\n  for await (const cid of pinset.loadSet(blockstore, pinRoot, PinTypes.direct)) {\n    counter++\n\n    /** @type {{ depth: number, version?: CIDVersion, codec?: number }} */\n    const pin = {\n      depth: 0\n    }\n\n    if (cid.version !== 0) {\n      pin.version = cid.version\n    }\n\n    if (cid.code !== dagPb.code) {\n      pin.codec = cid.code\n    }\n\n    await pinstore.put(cidToKey(cid), cbor.encode(pin))\n\n    onProgress((counter / pinCount) * 100, `Migrated direct pin ${cid}`)\n  }\n\n  await blockstore.delete(cid)\n  await datastore.delete(PIN_DS_KEY)\n}\n\n/**\n * @param {Blockstore} blockstore\n * @param {Datastore} datastore\n * @param {Datastore} pinstore\n * @param {MigrationProgressCallback} onProgress\n */\nasync function pinsToDAG (blockstore, datastore, pinstore, onProgress) {\n  const recursivePins = []\n  const directPins = []\n  let counter = 0\n  const pinCount = await length(pinstore.queryKeys({}))\n\n  for await (const { key, value } of pinstore.query({})) {\n    counter++\n    const pin = cbor.decode(value)\n    const cid = CID.create(\n      pin.version || 0,\n      pin.codec || dagPb.code,\n      mhd.decode(base32.decode('b' + key.toString().toLowerCase().split('/').pop()))\n    )\n\n    if (pin.depth === 0) {\n      onProgress((counter / pinCount) * 100, `Reverted direct pin ${cid}`)\n\n      directPins.push(cid)\n    } else {\n      onProgress((counter / pinCount) * 100, `Reverted recursive pin ${cid}`)\n\n      recursivePins.push(cid)\n    }\n  }\n\n  onProgress(100, 'Updating pin root')\n  const pinRoot = {\n    Links: [\n      await pinset.storeSet(blockstore, PinTypes.direct, directPins),\n      await pinset.storeSet(blockstore, PinTypes.recursive, recursivePins)\n    ]\n  }\n  const buf = dagPb.encode(pinRoot)\n  const digest = await sha256.digest(buf)\n  const cid = CID.createV0(digest)\n\n  await blockstore.put(cid, buf)\n  await datastore.put(PIN_DS_KEY, cid.bytes)\n}\n\n/**\n * @param {import('../../src/types').Backends} backends\n * @param {MigrationProgressCallback} onProgress\n * @param {*} fn\n */\nasync function process (backends, onProgress, fn) {\n  const blockstore = backends.blocks\n  const datastore = backends.datastore\n  const pinstore = backends.pins\n\n  await blockstore.open()\n  await datastore.open()\n  await pinstore.open()\n\n  try {\n    await fn(blockstore, datastore, pinstore, onProgress)\n  } finally {\n    await pinstore.close()\n    await datastore.close()\n    await blockstore.close()\n  }\n}\n\n/** @type {Migration} */\nmodule.exports = {\n  version: 9,\n  description: 'Migrates pins to datastore',\n  migrate: (backends, onProgress = () => {}) => {\n    return process(backends, onProgress, pinsToDatastore)\n  },\n  revert: (backends, onProgress = () => {}) => {\n    return process(backends, onProgress, pinsToDAG)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}