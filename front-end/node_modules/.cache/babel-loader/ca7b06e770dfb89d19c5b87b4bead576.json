{"ast":null,"code":"'use strict';\n\nconst {\n  CarBlockIterator\n} = require('@ipld/car/iterator');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst itPeekable = require('it-peekable');\n\nconst drain = require('it-drain');\n\nconst map = require('it-map');\n\nconst log = require('debug')('ipfs:components:dag:import');\n/**\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('ipfs-core-types/src/dag/').ImportRootStatus} RootStatus\n */\n\n/**\n * @param {Object} config\n * @param {IPFSRepo} config.repo\n */\n\n\nmodule.exports = ({\n  repo\n}) => {\n  /**\n   * @type {import('ipfs-core-types/src/dag').API[\"import\"]}\n   */\n  async function* dagImport(sources, options = {}) {\n    const release = await repo.gcLock.readLock();\n\n    try {\n      const abortOptions = {\n        signal: options.signal,\n        timeout: options.timeout\n      };\n      const peekable = itPeekable(sources);\n      const {\n        value,\n        done\n      } = await peekable.peek();\n\n      if (done) {\n        return;\n      }\n\n      if (value) {\n        // @ts-ignore\n        peekable.push(value);\n      }\n      /**\n       * @type {AsyncIterable<AsyncIterable<Uint8Array>> | Iterable<AsyncIterable<Uint8Array>>}\n       */\n\n\n      let cars;\n\n      if (value instanceof Uint8Array) {\n        // @ts-ignore\n        cars = [peekable];\n      } else {\n        // @ts-ignore\n        cars = peekable;\n      }\n\n      for await (const car of cars) {\n        const roots = await importCar(repo, abortOptions, car);\n\n        if (options.pinRoots !== false) {\n          // default=true\n          for (const cid of roots) {\n            let pinErrorMsg = '';\n\n            try {\n              // eslint-disable-line max-depth\n              if (await repo.blocks.has(cid)) {\n                // eslint-disable-line max-depth\n                log(`Pinning root ${cid}`);\n                await repo.pins.pinRecursively(cid);\n              } else {\n                pinErrorMsg = 'blockstore: block not found';\n              }\n            } catch (err) {\n              pinErrorMsg = err.message;\n            }\n\n            yield {\n              root: {\n                cid,\n                pinErrorMsg\n              }\n            };\n          }\n        }\n      }\n    } finally {\n      release();\n    }\n  }\n\n  return withTimeoutOption(dagImport);\n};\n/**\n * @param {IPFSRepo} repo\n * @param {AbortOptions} options\n * @param {AsyncIterable<Uint8Array>} source\n * @returns {Promise<CID[]>}\n */\n\n\nasync function importCar(repo, options, source) {\n  const reader = await CarBlockIterator.fromIterable(source);\n  const roots = await reader.getRoots();\n  await drain(repo.blocks.putMany(map(reader, ({\n    cid: key,\n    bytes: value\n  }) => {\n    log(`Import block ${key}`);\n    return {\n      key,\n      value\n    };\n  }), {\n    signal: options.signal\n  }));\n  return roots;\n}","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/ipfs-core/src/components/dag/import.js"],"names":["CarBlockIterator","require","withTimeoutOption","itPeekable","drain","map","log","module","exports","repo","dagImport","sources","options","release","gcLock","readLock","abortOptions","signal","timeout","peekable","value","done","peek","push","cars","Uint8Array","car","roots","importCar","pinRoots","cid","pinErrorMsg","blocks","has","pins","pinRecursively","err","message","root","source","reader","fromIterable","getRoots","putMany","key","bytes"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { CarBlockIterator } = require('@ipld/car/iterator')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\nconst itPeekable = require('it-peekable')\nconst drain = require('it-drain')\nconst map = require('it-map')\nconst log = require('debug')('ipfs:components:dag:import')\n\n/**\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('ipfs-repo').IPFSRepo} IPFSRepo\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n * @typedef {import('ipfs-core-types/src/dag/').ImportRootStatus} RootStatus\n */\n\n/**\n * @param {Object} config\n * @param {IPFSRepo} config.repo\n */\nmodule.exports = ({ repo }) => {\n  /**\n   * @type {import('ipfs-core-types/src/dag').API[\"import\"]}\n   */\n  async function * dagImport (sources, options = {}) {\n    const release = await repo.gcLock.readLock()\n\n    try {\n      const abortOptions = { signal: options.signal, timeout: options.timeout }\n      const peekable = itPeekable(sources)\n\n      const { value, done } = await peekable.peek()\n\n      if (done) {\n        return\n      }\n\n      if (value) {\n        // @ts-ignore\n        peekable.push(value)\n      }\n\n      /**\n       * @type {AsyncIterable<AsyncIterable<Uint8Array>> | Iterable<AsyncIterable<Uint8Array>>}\n       */\n      let cars\n\n      if (value instanceof Uint8Array) {\n        // @ts-ignore\n        cars = [peekable]\n      } else {\n        // @ts-ignore\n        cars = peekable\n      }\n\n      for await (const car of cars) {\n        const roots = await importCar(repo, abortOptions, car)\n\n        if (options.pinRoots !== false) { // default=true\n          for (const cid of roots) {\n            let pinErrorMsg = ''\n\n            try { // eslint-disable-line max-depth\n              if (await repo.blocks.has(cid)) { // eslint-disable-line max-depth\n                log(`Pinning root ${cid}`)\n                await repo.pins.pinRecursively(cid)\n              } else {\n                pinErrorMsg = 'blockstore: block not found'\n              }\n            } catch (err) {\n              pinErrorMsg = err.message\n            }\n\n            yield { root: { cid, pinErrorMsg } }\n          }\n        }\n      }\n    } finally {\n      release()\n    }\n  }\n\n  return withTimeoutOption(dagImport)\n}\n\n/**\n * @param {IPFSRepo} repo\n * @param {AbortOptions} options\n * @param {AsyncIterable<Uint8Array>} source\n * @returns {Promise<CID[]>}\n */\nasync function importCar (repo, options, source) {\n  const reader = await CarBlockIterator.fromIterable(source)\n  const roots = await reader.getRoots()\n\n  await drain(\n    repo.blocks.putMany(\n      map(reader, ({ cid: key, bytes: value }) => {\n        log(`Import block ${key}`)\n\n        return { key, value }\n      }),\n      { signal: options.signal }\n    )\n  )\n\n  return roots\n}\n"]},"metadata":{},"sourceType":"script"}