{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict';\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst errCode = require('err-code');\n\nconst debug = require('debug');\n\nconst first = require('it-first');\n\nconst Block = require('multiformats/block');\n\nconst cborg = require('cborg');\n\nconst dagPb = require('@ipld/dag-pb');\n\nconst {\n  cidToKey,\n  keyToMultihash\n} = require('./utils/blockstore');\n\nconst walkDag = require('./utils/walk-dag');\n/**\n * @typedef {object} PinInternal\n * @property {number} depth\n * @property {import('multiformats/cid').CIDVersion} [version]\n * @property {number} [codec]\n * @property {Record<string, any>} [metadata]\n */\n\n/**\n * @typedef {import('./types').PinType} PinType\n * @typedef {import('./types').PinQueryType} PinQueryType\n * @typedef {import('multiformats/codecs/interface').BlockCodec<any, any>} BlockCodec\n * @typedef {import('./types').PinOptions} PinOptions\n * @typedef {import('./types').AbortOptions} AbortOptions\n * @typedef {import('./types').Pins} Pins\n */\n\n/**\n * @param {string} type\n */\n\n\nfunction invalidPinTypeErr(type) {\n  const errMsg = `Invalid type '${type}', must be one of {direct, indirect, recursive, all}`;\n  return errCode(new Error(errMsg), 'ERR_INVALID_PIN_TYPE');\n}\n\nconst PinTypes = {\n  /** @type {'direct'} */\n  direct: 'direct',\n\n  /** @type {'recursive'} */\n  recursive: 'recursive',\n\n  /** @type {'indirect'} */\n  indirect: 'indirect',\n\n  /** @type {'all'} */\n  all: 'all'\n};\n/**\n * @implements {Pins}\n */\n\nclass PinManager {\n  /**\n   * @param {Object} config\n   * @param {import('interface-datastore').Datastore} config.pinstore\n   * @param {import('interface-blockstore').Blockstore} config.blockstore\n   * @param {import('./types').loadCodec} config.loadCodec\n   */\n  constructor({\n    pinstore,\n    blockstore,\n    loadCodec\n  }) {\n    this.pinstore = pinstore;\n    this.blockstore = blockstore;\n    this.loadCodec = loadCodec;\n    this.log = debug('ipfs:repo:pin');\n    this.directPins = new Set();\n    this.recursivePins = new Set();\n  }\n  /**\n   * @param {CID} cid\n   * @param {PinOptions & AbortOptions} [options]\n   */\n\n\n  async pinDirectly(cid, options = {}) {\n    await this.blockstore.get(cid, options);\n    /** @type {PinInternal} */\n\n    const pin = {\n      depth: 0\n    };\n\n    if (cid.version !== 0) {\n      pin.version = cid.version;\n    }\n\n    if (cid.code !== dagPb.code) {\n      pin.codec = cid.code;\n    }\n\n    if (options.metadata) {\n      pin.metadata = options.metadata;\n    }\n\n    return this.pinstore.put(cidToKey(cid), cborg.encode(pin));\n  }\n  /**\n   * @param {CID} cid\n   * @param {AbortOptions} [options]\n   */\n\n\n  unpin(cid, options) {\n    return this.pinstore.delete(cidToKey(cid), options);\n  }\n  /**\n   * @param {CID} cid\n   * @param {PinOptions & AbortOptions} [options]\n   */\n\n\n  async pinRecursively(cid, options = {}) {\n    await this.fetchCompleteDag(cid, options);\n    /** @type {PinInternal} */\n\n    const pin = {\n      depth: Infinity\n    };\n\n    if (cid.version !== 0) {\n      pin.version = cid.version;\n    }\n\n    if (cid.code !== dagPb.code) {\n      pin.codec = cid.code;\n    }\n\n    if (options.metadata) {\n      pin.metadata = options.metadata;\n    }\n\n    await this.pinstore.put(cidToKey(cid), cborg.encode(pin));\n  }\n  /**\n   * @param {AbortOptions} [options]\n   */\n\n\n  async *directKeys(options) {\n    for await (const entry of this.pinstore.query({\n      filters: [entry => {\n        const pin = cborg.decode(entry.value);\n        return pin.depth === 0;\n      }]\n    })) {\n      const pin = cborg.decode(entry.value);\n      const version = pin.version || 0;\n      const codec = pin.codec != null ? pin.codec : dagPb.code;\n      const multihash = keyToMultihash(entry.key);\n      yield {\n        cid: CID.create(version, codec, multihash),\n        metadata: pin.metadata\n      };\n    }\n  }\n  /**\n   * @param {AbortOptions} [options]\n   */\n\n\n  async *recursiveKeys(options) {\n    for await (const entry of this.pinstore.query({\n      filters: [entry => {\n        const pin = cborg.decode(entry.value);\n        return pin.depth === Infinity;\n      }]\n    })) {\n      const pin = cborg.decode(entry.value);\n      const version = pin.version || 0;\n      const codec = pin.codec != null ? pin.codec : dagPb.code;\n      const multihash = keyToMultihash(entry.key);\n      yield {\n        cid: CID.create(version, codec, multihash),\n        metadata: pin.metadata\n      };\n    }\n  }\n  /**\n   * @param {AbortOptions} [options]\n   */\n\n\n  async *indirectKeys(options) {\n    for await (const {\n      cid\n    } of this.recursiveKeys()) {\n      for await (const childCid of walkDag(cid, this.blockstore, this.loadCodec, options)) {\n        // recursive pins override indirect pins\n        const types = [PinTypes.recursive];\n        const result = await this.isPinnedWithType(childCid, types);\n\n        if (result.pinned) {\n          continue;\n        }\n\n        yield childCid;\n      }\n    }\n  }\n  /**\n   * @param {CID} cid\n   * @param {PinQueryType|PinQueryType[]} types\n   * @param {AbortOptions} [options]\n   */\n\n\n  async isPinnedWithType(cid, types, options) {\n    if (!Array.isArray(types)) {\n      types = [types];\n    }\n\n    const all = types.includes(PinTypes.all);\n    const direct = types.includes(PinTypes.direct);\n    const recursive = types.includes(PinTypes.recursive);\n    const indirect = types.includes(PinTypes.indirect);\n\n    if (recursive || direct || all) {\n      const result = await first(this.pinstore.query({\n        prefix: cidToKey(cid).toString(),\n        filters: [entry => {\n          if (all) {\n            return true;\n          }\n\n          const pin = cborg.decode(entry.value);\n          return types.includes(pin.depth === 0 ? PinTypes.direct : PinTypes.recursive);\n        }],\n        limit: 1\n      }));\n\n      if (result) {\n        const pin = cborg.decode(result.value);\n        return {\n          cid,\n          pinned: true,\n          reason: pin.depth === 0 ? PinTypes.direct : PinTypes.recursive,\n          metadata: pin.metadata\n        };\n      }\n    }\n\n    const self = this;\n    /**\n     * @param {CID} key\n     * @param {AsyncIterable<{ cid: CID, metadata: any }>} source\n     */\n\n    async function* findChild(key, source) {\n      for await (const {\n        cid: parentCid\n      } of source) {\n        for await (const childCid of walkDag(parentCid, self.blockstore, self.loadCodec)) {\n          if (childCid.equals(key)) {\n            yield parentCid;\n            return;\n          }\n        }\n      }\n    }\n\n    if (all || indirect) {\n      // indirect (default)\n      // check each recursive key to see if multihash is under it\n      const parentCid = await first(findChild(cid, this.recursiveKeys()));\n\n      if (parentCid) {\n        return {\n          cid,\n          pinned: true,\n          reason: PinTypes.indirect,\n          parent: parentCid\n        };\n      }\n    }\n\n    return {\n      cid,\n      pinned: false\n    };\n  }\n  /**\n   * @param {CID} cid\n   * @param {AbortOptions} options\n   */\n\n\n  async fetchCompleteDag(cid, options) {\n    const seen = new Set();\n    /**\n     * @param {CID} cid\n     * @param {AbortOptions} options\n     */\n\n    const walkDag = async (cid, options) => {\n      if (seen.has(cid.toString())) {\n        return;\n      }\n\n      seen.add(cid.toString());\n      const bytes = await this.blockstore.get(cid, options);\n      const codec = await this.loadCodec(cid.code);\n      const block = Block.createUnsafe({\n        bytes,\n        cid,\n        codec\n      });\n      await Promise.all([...block.links()].map(([, childCid]) => walkDag(childCid, options)));\n    };\n\n    await walkDag(cid, options);\n  }\n  /**\n   * Throws an error if the pin type is invalid\n   *\n   * @param {any} type\n   * @returns {type is PinType}\n   */\n\n\n  static checkPinType(type) {\n    if (typeof type !== 'string' || !Object.keys(PinTypes).includes(type)) {\n      throw invalidPinTypeErr(type);\n    }\n\n    return true;\n  }\n\n}\n\nmodule.exports = {\n  PinManager,\n  PinTypes\n};","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/ipfs-repo/src/pins.js"],"names":["CID","require","errCode","debug","first","Block","cborg","dagPb","cidToKey","keyToMultihash","walkDag","invalidPinTypeErr","type","errMsg","Error","PinTypes","direct","recursive","indirect","all","PinManager","constructor","pinstore","blockstore","loadCodec","log","directPins","Set","recursivePins","pinDirectly","cid","options","get","pin","depth","version","code","codec","metadata","put","encode","unpin","delete","pinRecursively","fetchCompleteDag","Infinity","directKeys","entry","query","filters","decode","value","multihash","key","create","recursiveKeys","indirectKeys","childCid","types","result","isPinnedWithType","pinned","Array","isArray","includes","prefix","toString","limit","reason","self","findChild","source","parentCid","equals","parent","seen","has","add","bytes","block","createUnsafe","Promise","links","map","checkPinType","Object","keys","module","exports"],"mappings":"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","sourcesContent":["/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict'\n\nconst { CID } = require('multiformats/cid')\nconst errCode = require('err-code')\nconst debug = require('debug')\nconst first = require('it-first')\nconst Block = require('multiformats/block')\nconst cborg = require('cborg')\nconst dagPb = require('@ipld/dag-pb')\nconst {\n  cidToKey,\n  keyToMultihash\n} = require('./utils/blockstore')\nconst walkDag = require('./utils/walk-dag')\n\n/**\n * @typedef {object} PinInternal\n * @property {number} depth\n * @property {import('multiformats/cid').CIDVersion} [version]\n * @property {number} [codec]\n * @property {Record<string, any>} [metadata]\n */\n\n/**\n * @typedef {import('./types').PinType} PinType\n * @typedef {import('./types').PinQueryType} PinQueryType\n * @typedef {import('multiformats/codecs/interface').BlockCodec<any, any>} BlockCodec\n * @typedef {import('./types').PinOptions} PinOptions\n * @typedef {import('./types').AbortOptions} AbortOptions\n * @typedef {import('./types').Pins} Pins\n */\n\n/**\n * @param {string} type\n */\nfunction invalidPinTypeErr (type) {\n  const errMsg = `Invalid type '${type}', must be one of {direct, indirect, recursive, all}`\n  return errCode(new Error(errMsg), 'ERR_INVALID_PIN_TYPE')\n}\n\nconst PinTypes = {\n  /** @type {'direct'} */\n  direct: ('direct'),\n  /** @type {'recursive'} */\n  recursive: ('recursive'),\n  /** @type {'indirect'} */\n  indirect: ('indirect'),\n  /** @type {'all'} */\n  all: ('all')\n}\n\n/**\n * @implements {Pins}\n */\nclass PinManager {\n  /**\n   * @param {Object} config\n   * @param {import('interface-datastore').Datastore} config.pinstore\n   * @param {import('interface-blockstore').Blockstore} config.blockstore\n   * @param {import('./types').loadCodec} config.loadCodec\n   */\n  constructor ({ pinstore, blockstore, loadCodec }) {\n    this.pinstore = pinstore\n    this.blockstore = blockstore\n    this.loadCodec = loadCodec\n    this.log = debug('ipfs:repo:pin')\n    this.directPins = new Set()\n    this.recursivePins = new Set()\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {PinOptions & AbortOptions} [options]\n   */\n  async pinDirectly (cid, options = {}) {\n    await this.blockstore.get(cid, options)\n\n    /** @type {PinInternal} */\n    const pin = {\n      depth: 0\n    }\n\n    if (cid.version !== 0) {\n      pin.version = cid.version\n    }\n\n    if (cid.code !== dagPb.code) {\n      pin.codec = cid.code\n    }\n\n    if (options.metadata) {\n      pin.metadata = options.metadata\n    }\n\n    return this.pinstore.put(cidToKey(cid), cborg.encode(pin))\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {AbortOptions} [options]\n   */\n  unpin (cid, options) {\n    return this.pinstore.delete(cidToKey(cid), options)\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {PinOptions & AbortOptions} [options]\n   */\n  async pinRecursively (cid, options = {}) {\n    await this.fetchCompleteDag(cid, options)\n\n    /** @type {PinInternal} */\n    const pin = {\n      depth: Infinity\n    }\n\n    if (cid.version !== 0) {\n      pin.version = cid.version\n    }\n\n    if (cid.code !== dagPb.code) {\n      pin.codec = cid.code\n    }\n\n    if (options.metadata) {\n      pin.metadata = options.metadata\n    }\n\n    await this.pinstore.put(cidToKey(cid), cborg.encode(pin))\n  }\n\n  /**\n   * @param {AbortOptions} [options]\n   */\n  async * directKeys (options) {\n    for await (const entry of this.pinstore.query({\n      filters: [(entry) => {\n        const pin = cborg.decode(entry.value)\n\n        return pin.depth === 0\n      }]\n    })) {\n      const pin = cborg.decode(entry.value)\n      const version = pin.version || 0\n      const codec = pin.codec != null ? pin.codec : dagPb.code\n      const multihash = keyToMultihash(entry.key)\n\n      yield {\n        cid: CID.create(version, codec, multihash),\n        metadata: pin.metadata\n      }\n    }\n  }\n\n  /**\n   * @param {AbortOptions} [options]\n   */\n  async * recursiveKeys (options) {\n    for await (const entry of this.pinstore.query({\n      filters: [(entry) => {\n        const pin = cborg.decode(entry.value)\n\n        return pin.depth === Infinity\n      }]\n    })) {\n      const pin = cborg.decode(entry.value)\n      const version = pin.version || 0\n      const codec = pin.codec != null ? pin.codec : dagPb.code\n      const multihash = keyToMultihash(entry.key)\n\n      yield {\n        cid: CID.create(version, codec, multihash),\n        metadata: pin.metadata\n      }\n    }\n  }\n\n  /**\n   * @param {AbortOptions} [options]\n   */\n  async * indirectKeys (options) {\n    for await (const { cid } of this.recursiveKeys()) {\n      for await (const childCid of walkDag(cid, this.blockstore, this.loadCodec, options)) {\n        // recursive pins override indirect pins\n        const types = [\n          PinTypes.recursive\n        ]\n\n        const result = await this.isPinnedWithType(childCid, types)\n\n        if (result.pinned) {\n          continue\n        }\n\n        yield childCid\n      }\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {PinQueryType|PinQueryType[]} types\n   * @param {AbortOptions} [options]\n   */\n  async isPinnedWithType (cid, types, options) {\n    if (!Array.isArray(types)) {\n      types = [types]\n    }\n\n    const all = types.includes(PinTypes.all)\n    const direct = types.includes(PinTypes.direct)\n    const recursive = types.includes(PinTypes.recursive)\n    const indirect = types.includes(PinTypes.indirect)\n\n    if (recursive || direct || all) {\n      const result = await first(this.pinstore.query({\n        prefix: cidToKey(cid).toString(),\n        filters: [entry => {\n          if (all) {\n            return true\n          }\n\n          const pin = cborg.decode(entry.value)\n\n          return types.includes(pin.depth === 0 ? PinTypes.direct : PinTypes.recursive)\n        }],\n        limit: 1\n      }))\n\n      if (result) {\n        const pin = cborg.decode(result.value)\n\n        return {\n          cid,\n          pinned: true,\n          reason: pin.depth === 0 ? PinTypes.direct : PinTypes.recursive,\n          metadata: pin.metadata\n        }\n      }\n    }\n\n    const self = this\n\n    /**\n     * @param {CID} key\n     * @param {AsyncIterable<{ cid: CID, metadata: any }>} source\n     */\n    async function * findChild (key, source) {\n      for await (const { cid: parentCid } of source) {\n        for await (const childCid of walkDag(parentCid, self.blockstore, self.loadCodec)) {\n          if (childCid.equals(key)) {\n            yield parentCid\n            return\n          }\n        }\n      }\n    }\n\n    if (all || indirect) {\n      // indirect (default)\n      // check each recursive key to see if multihash is under it\n\n      const parentCid = await first(findChild(cid, this.recursiveKeys()))\n\n      if (parentCid) {\n        return {\n          cid,\n          pinned: true,\n          reason: PinTypes.indirect,\n          parent: parentCid\n        }\n      }\n    }\n\n    return {\n      cid,\n      pinned: false\n    }\n  }\n\n  /**\n   * @param {CID} cid\n   * @param {AbortOptions} options\n   */\n  async fetchCompleteDag (cid, options) {\n    const seen = new Set()\n\n    /**\n     * @param {CID} cid\n     * @param {AbortOptions} options\n     */\n    const walkDag = async (cid, options) => {\n      if (seen.has(cid.toString())) {\n        return\n      }\n\n      seen.add(cid.toString())\n\n      const bytes = await this.blockstore.get(cid, options)\n      const codec = await this.loadCodec(cid.code)\n      const block = Block.createUnsafe({ bytes, cid, codec })\n\n      await Promise.all(\n        [...block.links()].map(([, childCid]) => walkDag(childCid, options))\n      )\n    }\n\n    await walkDag(cid, options)\n  }\n\n  /**\n   * Throws an error if the pin type is invalid\n   *\n   * @param {any} type\n   * @returns {type is PinType}\n   */\n  static checkPinType (type) {\n    if (typeof type !== 'string' || !Object.keys(PinTypes).includes(type)) {\n      throw invalidPinTypeErr(type)\n    }\n    return true\n  }\n}\n\nmodule.exports = {\n  PinManager,\n  PinTypes\n}\n"]},"metadata":{},"sourceType":"script"}