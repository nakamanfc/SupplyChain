{"ast":null,"code":"'use strict';\n\nconst {\n  sha256\n} = require('multiformats/hashes/sha2');\n\nconst errcode = require('err-code');\n\nconst {\n  equals: uint8ArrayEquals\n} = require('uint8arrays/equals');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nrequire('node-forge/lib/sha512');\n\nrequire('node-forge/lib/ed25519');\n\nconst forge = require('node-forge/lib/forge');\n\nconst crypto = require('./rsa');\n\nconst pbm = require('./keys');\n\nconst exporter = require('./exporter');\n\nclass RsaPublicKey {\n  constructor(key) {\n    this._key = key;\n  }\n\n  async verify(data, sig) {\n    // eslint-disable-line require-await\n    return crypto.hashAndVerify(this._key, sig, data);\n  }\n\n  marshal() {\n    return crypto.utils.jwkToPkix(this._key);\n  }\n\n  get bytes() {\n    return pbm.PublicKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    }).finish();\n  }\n\n  encrypt(bytes) {\n    return crypto.encrypt(this._key, bytes);\n  }\n\n  equals(key) {\n    return uint8ArrayEquals(this.bytes, key.bytes);\n  }\n\n  async hash() {\n    const {\n      bytes\n    } = await sha256.digest(this.bytes);\n    return bytes;\n  }\n\n}\n\nclass RsaPrivateKey {\n  // key       - Object of the jwk format\n  // publicKey - Uint8Array of the spki format\n  constructor(key, publicKey) {\n    this._key = key;\n    this._publicKey = publicKey;\n  }\n\n  genSecret() {\n    return crypto.getRandomValues(16);\n  }\n\n  async sign(message) {\n    // eslint-disable-line require-await\n    return crypto.hashAndSign(this._key, message);\n  }\n\n  get public() {\n    if (!this._publicKey) {\n      throw errcode(new Error('public key not provided'), 'ERR_PUBKEY_NOT_PROVIDED');\n    }\n\n    return new RsaPublicKey(this._publicKey);\n  }\n\n  decrypt(bytes) {\n    return crypto.decrypt(this._key, bytes);\n  }\n\n  marshal() {\n    return crypto.utils.jwkToPkcs1(this._key);\n  }\n\n  get bytes() {\n    return pbm.PrivateKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    }).finish();\n  }\n\n  equals(key) {\n    return uint8ArrayEquals(this.bytes, key.bytes);\n  }\n\n  async hash() {\n    const {\n      bytes\n    } = await sha256.digest(this.bytes);\n    return bytes;\n  }\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   *\n   * @returns {Promise<string>}\n   */\n\n\n  async id() {\n    const hash = await this.public.hash();\n    return uint8ArrayToString(hash, 'base58btc');\n  }\n  /**\n   * Exports the key into a password protected PEM format\n   *\n   * @param {string} password - The password to read the encrypted PEM\n   * @param {string} [format=pkcs-8] - The format in which to export as\n   */\n\n\n  async export(password, format = 'pkcs-8') {\n    // eslint-disable-line require-await\n    if (format === 'pkcs-8') {\n      const buffer = new forge.util.ByteBuffer(this.marshal());\n      const asn1 = forge.asn1.fromDer(buffer);\n      const privateKey = forge.pki.privateKeyFromAsn1(asn1);\n      const options = {\n        algorithm: 'aes256',\n        count: 10000,\n        saltSize: 128 / 8,\n        prfAlgorithm: 'sha512'\n      };\n      return forge.pki.encryptRsaPrivateKey(privateKey, password, options);\n    } else if (format === 'libp2p-key') {\n      return exporter.export(this.bytes, password);\n    } else {\n      throw errcode(new Error(`export format '${format}' is not supported`), 'ERR_INVALID_EXPORT_FORMAT');\n    }\n  }\n\n}\n\nasync function unmarshalRsaPrivateKey(bytes) {\n  const jwk = crypto.utils.pkcs1ToJwk(bytes);\n  const keys = await crypto.unmarshalPrivateKey(jwk);\n  return new RsaPrivateKey(keys.privateKey, keys.publicKey);\n}\n\nfunction unmarshalRsaPublicKey(bytes) {\n  const jwk = crypto.utils.pkixToJwk(bytes);\n  return new RsaPublicKey(jwk);\n}\n\nasync function fromJwk(jwk) {\n  const keys = await crypto.unmarshalPrivateKey(jwk);\n  return new RsaPrivateKey(keys.privateKey, keys.publicKey);\n}\n\nasync function generateKeyPair(bits) {\n  const keys = await crypto.generateKey(bits);\n  return new RsaPrivateKey(keys.privateKey, keys.publicKey);\n}\n\nmodule.exports = {\n  RsaPublicKey,\n  RsaPrivateKey,\n  unmarshalRsaPublicKey,\n  unmarshalRsaPrivateKey,\n  generateKeyPair,\n  fromJwk\n};","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/libp2p-crypto/src/keys/rsa-class.js"],"names":["sha256","require","errcode","equals","uint8ArrayEquals","toString","uint8ArrayToString","forge","crypto","pbm","exporter","RsaPublicKey","constructor","key","_key","verify","data","sig","hashAndVerify","marshal","utils","jwkToPkix","bytes","PublicKey","encode","Type","KeyType","RSA","Data","finish","encrypt","hash","digest","RsaPrivateKey","publicKey","_publicKey","genSecret","getRandomValues","sign","message","hashAndSign","public","Error","decrypt","jwkToPkcs1","PrivateKey","id","export","password","format","buffer","util","ByteBuffer","asn1","fromDer","privateKey","pki","privateKeyFromAsn1","options","algorithm","count","saltSize","prfAlgorithm","encryptRsaPrivateKey","unmarshalRsaPrivateKey","jwk","pkcs1ToJwk","keys","unmarshalPrivateKey","unmarshalRsaPublicKey","pkixToJwk","fromJwk","generateKeyPair","bits","generateKey","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { sha256 } = require('multiformats/hashes/sha2')\nconst errcode = require('err-code')\nconst { equals: uint8ArrayEquals } = require('uint8arrays/equals')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\n\nrequire('node-forge/lib/sha512')\nrequire('node-forge/lib/ed25519')\nconst forge = require('node-forge/lib/forge')\n\nconst crypto = require('./rsa')\nconst pbm = require('./keys')\nconst exporter = require('./exporter')\n\nclass RsaPublicKey {\n  constructor (key) {\n    this._key = key\n  }\n\n  async verify (data, sig) { // eslint-disable-line require-await\n    return crypto.hashAndVerify(this._key, sig, data)\n  }\n\n  marshal () {\n    return crypto.utils.jwkToPkix(this._key)\n  }\n\n  get bytes () {\n    return pbm.PublicKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    }).finish()\n  }\n\n  encrypt (bytes) {\n    return crypto.encrypt(this._key, bytes)\n  }\n\n  equals (key) {\n    return uint8ArrayEquals(this.bytes, key.bytes)\n  }\n\n  async hash () {\n    const { bytes } = await sha256.digest(this.bytes)\n\n    return bytes\n  }\n}\n\nclass RsaPrivateKey {\n  // key       - Object of the jwk format\n  // publicKey - Uint8Array of the spki format\n  constructor (key, publicKey) {\n    this._key = key\n    this._publicKey = publicKey\n  }\n\n  genSecret () {\n    return crypto.getRandomValues(16)\n  }\n\n  async sign (message) { // eslint-disable-line require-await\n    return crypto.hashAndSign(this._key, message)\n  }\n\n  get public () {\n    if (!this._publicKey) {\n      throw errcode(new Error('public key not provided'), 'ERR_PUBKEY_NOT_PROVIDED')\n    }\n\n    return new RsaPublicKey(this._publicKey)\n  }\n\n  decrypt (bytes) {\n    return crypto.decrypt(this._key, bytes)\n  }\n\n  marshal () {\n    return crypto.utils.jwkToPkcs1(this._key)\n  }\n\n  get bytes () {\n    return pbm.PrivateKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    }).finish()\n  }\n\n  equals (key) {\n    return uint8ArrayEquals(this.bytes, key.bytes)\n  }\n\n  async hash () {\n    const { bytes } = await sha256.digest(this.bytes)\n\n    return bytes\n  }\n\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   *\n   * @returns {Promise<string>}\n   */\n  async id () {\n    const hash = await this.public.hash()\n    return uint8ArrayToString(hash, 'base58btc')\n  }\n\n  /**\n   * Exports the key into a password protected PEM format\n   *\n   * @param {string} password - The password to read the encrypted PEM\n   * @param {string} [format=pkcs-8] - The format in which to export as\n   */\n  async export (password, format = 'pkcs-8') { // eslint-disable-line require-await\n    if (format === 'pkcs-8') {\n      const buffer = new forge.util.ByteBuffer(this.marshal())\n      const asn1 = forge.asn1.fromDer(buffer)\n      const privateKey = forge.pki.privateKeyFromAsn1(asn1)\n\n      const options = {\n        algorithm: 'aes256',\n        count: 10000,\n        saltSize: 128 / 8,\n        prfAlgorithm: 'sha512'\n      }\n      return forge.pki.encryptRsaPrivateKey(privateKey, password, options)\n    } else if (format === 'libp2p-key') {\n      return exporter.export(this.bytes, password)\n    } else {\n      throw errcode(new Error(`export format '${format}' is not supported`), 'ERR_INVALID_EXPORT_FORMAT')\n    }\n  }\n}\n\nasync function unmarshalRsaPrivateKey (bytes) {\n  const jwk = crypto.utils.pkcs1ToJwk(bytes)\n  const keys = await crypto.unmarshalPrivateKey(jwk)\n  return new RsaPrivateKey(keys.privateKey, keys.publicKey)\n}\n\nfunction unmarshalRsaPublicKey (bytes) {\n  const jwk = crypto.utils.pkixToJwk(bytes)\n  return new RsaPublicKey(jwk)\n}\n\nasync function fromJwk (jwk) {\n  const keys = await crypto.unmarshalPrivateKey(jwk)\n  return new RsaPrivateKey(keys.privateKey, keys.publicKey)\n}\n\nasync function generateKeyPair (bits) {\n  const keys = await crypto.generateKey(bits)\n  return new RsaPrivateKey(keys.privateKey, keys.publicKey)\n}\n\nmodule.exports = {\n  RsaPublicKey,\n  RsaPrivateKey,\n  unmarshalRsaPublicKey,\n  unmarshalRsaPrivateKey,\n  generateKeyPair,\n  fromJwk\n}\n"]},"metadata":{},"sourceType":"script"}