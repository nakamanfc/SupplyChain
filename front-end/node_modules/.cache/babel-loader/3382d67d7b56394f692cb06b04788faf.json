{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.computeScore = void 0;\n\nfunction computeScore(peer, pstats, params, peerIPs) {\n  let score = 0; // topic stores\n\n  Object.entries(pstats.topics).forEach(([topic, tstats]) => {\n    // the topic parameters\n    const topicParams = params.topics[topic];\n\n    if (!topicParams) {\n      // we are not scoring this topic\n      return;\n    }\n\n    let topicScore = 0; // P1: time in Mesh\n\n    if (tstats.inMesh) {\n      let p1 = tstats.meshTime / topicParams.timeInMeshQuantum;\n\n      if (p1 > topicParams.timeInMeshCap) {\n        p1 = topicParams.timeInMeshCap;\n      }\n\n      topicScore += p1 * topicParams.timeInMeshWeight;\n    } // P2: first message deliveries\n\n\n    const p2 = tstats.firstMessageDeliveries;\n    topicScore += p2 * topicParams.firstMessageDeliveriesWeight; // P3: mesh message deliveries\n\n    if (tstats.meshMessageDeliveriesActive) {\n      if (tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold) {\n        const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries;\n        const p3 = deficit * deficit;\n        topicScore += p3 * topicParams.meshMessageDeliveriesWeight;\n      }\n    } // P3b:\n    // NOTE: the weight of P3b is negative (validated in validateTopicScoreParams) so this detracts\n\n\n    const p3b = tstats.meshFailurePenalty;\n    topicScore += p3b * topicParams.meshFailurePenaltyWeight; // P4: invalid messages\n    // NOTE: the weight of P4 is negative (validated in validateTopicScoreParams) so this detracts\n\n    const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries;\n    topicScore += p4 * topicParams.invalidMessageDeliveriesWeight; // update score, mixing with topic weight\n\n    score += topicScore * topicParams.topicWeight;\n  }); // apply the topic score cap, if any\n\n  if (params.topicScoreCap > 0 && score > params.topicScoreCap) {\n    score = params.topicScoreCap;\n  } // P5: application-specific score\n\n\n  const p5 = params.appSpecificScore(peer);\n  score += p5 * params.appSpecificWeight; // P6: IP colocation factor\n\n  pstats.ips.forEach(ip => {\n    if (params.IPColocationFactorWhitelist.has(ip)) {\n      return;\n    } // P6 has a cliff (IPColocationFactorThreshold)\n    // It's only applied if at least that many peers are connected to us from that source IP addr.\n    // It is quadratic, and the weight is negative (validated in validatePeerScoreParams)\n\n\n    const peersInIP = peerIPs.get(ip);\n    const numPeersInIP = peersInIP ? peersInIP.size : 0;\n\n    if (numPeersInIP > params.IPColocationFactorThreshold) {\n      const surplus = numPeersInIP - params.IPColocationFactorThreshold;\n      const p6 = surplus * surplus;\n      score += p6 * params.IPColocationFactorWeight;\n    }\n  }); // P7: behavioural pattern penalty\n\n  const p7 = pstats.behaviourPenalty * pstats.behaviourPenalty;\n  score += p7 * params.behaviourPenaltyWeight;\n  return score;\n}\n\nexports.computeScore = computeScore;","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/libp2p-gossipsub/src/score/compute-score.js"],"names":["Object","defineProperty","exports","value","computeScore","peer","pstats","params","peerIPs","score","entries","topics","forEach","topic","tstats","topicParams","topicScore","inMesh","p1","meshTime","timeInMeshQuantum","timeInMeshCap","timeInMeshWeight","p2","firstMessageDeliveries","firstMessageDeliveriesWeight","meshMessageDeliveriesActive","meshMessageDeliveries","meshMessageDeliveriesThreshold","deficit","p3","meshMessageDeliveriesWeight","p3b","meshFailurePenalty","meshFailurePenaltyWeight","p4","invalidMessageDeliveries","invalidMessageDeliveriesWeight","topicWeight","topicScoreCap","p5","appSpecificScore","appSpecificWeight","ips","ip","IPColocationFactorWhitelist","has","peersInIP","get","numPeersInIP","size","IPColocationFactorThreshold","surplus","p6","IPColocationFactorWeight","p7","behaviourPenalty","behaviourPenaltyWeight"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.computeScore = void 0;\nfunction computeScore(peer, pstats, params, peerIPs) {\n    let score = 0;\n    // topic stores\n    Object.entries(pstats.topics).forEach(([topic, tstats]) => {\n        // the topic parameters\n        const topicParams = params.topics[topic];\n        if (!topicParams) {\n            // we are not scoring this topic\n            return;\n        }\n        let topicScore = 0;\n        // P1: time in Mesh\n        if (tstats.inMesh) {\n            let p1 = tstats.meshTime / topicParams.timeInMeshQuantum;\n            if (p1 > topicParams.timeInMeshCap) {\n                p1 = topicParams.timeInMeshCap;\n            }\n            topicScore += p1 * topicParams.timeInMeshWeight;\n        }\n        // P2: first message deliveries\n        const p2 = tstats.firstMessageDeliveries;\n        topicScore += p2 * topicParams.firstMessageDeliveriesWeight;\n        // P3: mesh message deliveries\n        if (tstats.meshMessageDeliveriesActive) {\n            if (tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold) {\n                const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries;\n                const p3 = deficit * deficit;\n                topicScore += p3 * topicParams.meshMessageDeliveriesWeight;\n            }\n        }\n        // P3b:\n        // NOTE: the weight of P3b is negative (validated in validateTopicScoreParams) so this detracts\n        const p3b = tstats.meshFailurePenalty;\n        topicScore += p3b * topicParams.meshFailurePenaltyWeight;\n        // P4: invalid messages\n        // NOTE: the weight of P4 is negative (validated in validateTopicScoreParams) so this detracts\n        const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries;\n        topicScore += p4 * topicParams.invalidMessageDeliveriesWeight;\n        // update score, mixing with topic weight\n        score += topicScore * topicParams.topicWeight;\n    });\n    // apply the topic score cap, if any\n    if (params.topicScoreCap > 0 && score > params.topicScoreCap) {\n        score = params.topicScoreCap;\n    }\n    // P5: application-specific score\n    const p5 = params.appSpecificScore(peer);\n    score += p5 * params.appSpecificWeight;\n    // P6: IP colocation factor\n    pstats.ips.forEach(ip => {\n        if (params.IPColocationFactorWhitelist.has(ip)) {\n            return;\n        }\n        // P6 has a cliff (IPColocationFactorThreshold)\n        // It's only applied if at least that many peers are connected to us from that source IP addr.\n        // It is quadratic, and the weight is negative (validated in validatePeerScoreParams)\n        const peersInIP = peerIPs.get(ip);\n        const numPeersInIP = peersInIP ? peersInIP.size : 0;\n        if (numPeersInIP > params.IPColocationFactorThreshold) {\n            const surplus = numPeersInIP - params.IPColocationFactorThreshold;\n            const p6 = surplus * surplus;\n            score += p6 * params.IPColocationFactorWeight;\n        }\n    });\n    // P7: behavioural pattern penalty\n    const p7 = pstats.behaviourPenalty * pstats.behaviourPenalty;\n    score += p7 * params.behaviourPenaltyWeight;\n    return score;\n}\nexports.computeScore = computeScore;\n"]},"metadata":{},"sourceType":"script"}