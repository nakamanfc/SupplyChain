{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:persistent-peer-store'), {\n  error: debug('libp2p:persistent-peer-store:err')\n});\n\nconst {\n  Key\n} = require('interface-datastore');\n\nconst {\n  Multiaddr\n} = require('multiaddr');\n\nconst PeerId = require('peer-id');\n\nconst {\n  base32\n} = require('multiformats/bases/base32');\n\nconst PeerStore = require('..');\n\nconst {\n  NAMESPACE_ADDRESS,\n  NAMESPACE_COMMON,\n  NAMESPACE_KEYS,\n  NAMESPACE_METADATA,\n  NAMESPACE_PROTOCOL\n} = require('./consts');\n\nconst {\n  Addresses\n} = require('./pb/address-book');\n\nconst {\n  Protocols\n} = require('./pb/proto-book');\n/**\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('../address-book.js').Address} Address\n */\n\n/**\n * @typedef {Object} PersistentPeerStoreProperties\n * @property {PeerId} peerId\n * @property {import('interface-datastore').Datastore} datastore\n *\n * @typedef {Object} PersistentPeerStoreOptions\n * @property {number} [threshold = 5] - Number of dirty peers allowed before commit data.\n */\n\n/**\n * Responsible for managing the persistence of data in the PeerStore.\n */\n\n\nclass PersistentPeerStore extends PeerStore {\n  /**\n   * @class\n   * @param {PersistentPeerStoreProperties & PersistentPeerStoreOptions} properties\n   */\n  constructor({\n    peerId,\n    datastore,\n    threshold = 5\n  }) {\n    super({\n      peerId\n    });\n    /**\n     * Backend datastore used to persist data.\n     */\n\n    this._datastore = datastore;\n    /**\n     * Peers modified after the latest data persisted.\n     */\n\n    this._dirtyPeers = new Set();\n    /**\n     * Peers metadata changed mapping peer identifers to metadata changed.\n     *\n     * @type {Map<string, Set<string>>}\n     */\n\n    this._dirtyMetadata = new Map();\n    this.threshold = threshold;\n    this._addDirtyPeer = this._addDirtyPeer.bind(this);\n  }\n  /**\n   * Start Persistent PeerStore.\n   *\n   * @returns {Promise<void>}\n   */\n\n\n  async start() {\n    log('PeerStore is starting'); // Handlers for dirty peers\n\n    this.on('change:protocols', this._addDirtyPeer);\n    this.on('change:multiaddrs', this._addDirtyPeer);\n    this.on('change:pubkey', this._addDirtyPeerKey);\n    this.on('change:metadata', this._addDirtyPeerMetadata); // Load data\n\n    for await (const entry of this._datastore.query({\n      prefix: NAMESPACE_COMMON\n    })) {\n      await this._processDatastoreEntry(entry);\n    }\n\n    log('PeerStore started');\n  }\n  /**\n   * Stop Persistent PeerStore.\n   *\n   * @returns {Promise<void>}\n   */\n\n\n  async stop() {\n    log('PeerStore is stopping');\n    this.removeAllListeners();\n    await this._commitData();\n    log('PeerStore stopped');\n  }\n  /**\n   * Add modified peer to the dirty set\n   *\n   * @private\n   * @param {Object} params\n   * @param {PeerId} params.peerId\n   */\n\n\n  _addDirtyPeer({\n    peerId\n  }) {\n    const peerIdstr = peerId.toB58String();\n    log('add dirty peer', peerIdstr);\n\n    this._dirtyPeers.add(peerIdstr);\n\n    if (this._dirtyPeers.size >= this.threshold) {\n      // Commit current data\n      this._commitData().catch(err => {\n        log.error('error committing data', err);\n      });\n    }\n  }\n  /**\n   * Add modified peer key to the dirty set\n   *\n   * @private\n   * @param {Object} params\n   * @param {PeerId} params.peerId\n   */\n\n\n  _addDirtyPeerKey({\n    peerId\n  }) {\n    // Not add if inline key available\n    if (peerId.hasInlinePublicKey()) {\n      return;\n    }\n\n    const peerIdstr = peerId.toB58String();\n    log('add dirty peer key', peerIdstr);\n\n    this._dirtyPeers.add(peerIdstr);\n\n    if (this._dirtyPeers.size >= this.threshold) {\n      // Commit current data\n      this._commitData().catch(err => {\n        log.error('error committing data', err);\n      });\n    }\n  }\n  /**\n   * Add modified metadata peer to the set.\n   *\n   * @private\n   * @param {Object} params\n   * @param {PeerId} params.peerId\n   * @param {string} params.metadata\n   */\n\n\n  _addDirtyPeerMetadata({\n    peerId,\n    metadata\n  }) {\n    const peerIdstr = peerId.toB58String();\n    log('add dirty metadata peer', peerIdstr);\n\n    this._dirtyPeers.add(peerIdstr); // Add dirty metadata key\n\n\n    const mData = this._dirtyMetadata.get(peerIdstr) || new Set();\n    mData.add(metadata);\n\n    this._dirtyMetadata.set(peerIdstr, mData);\n\n    if (this._dirtyPeers.size >= this.threshold) {\n      // Commit current data\n      this._commitData().catch(err => {\n        log.error('error committing data', err);\n      });\n    }\n  }\n  /**\n   * Add all the peers current data to a datastore batch and commit it.\n   *\n   * @private\n   * @returns {Promise<void>}\n   */\n\n\n  async _commitData() {\n    const commitPeers = Array.from(this._dirtyPeers);\n\n    if (!commitPeers.length) {\n      return;\n    } // Clear Dirty Peers set\n\n\n    this._dirtyPeers.clear();\n\n    log('create batch commit');\n\n    const batch = this._datastore.batch();\n\n    for (const peerIdStr of commitPeers) {\n      // PeerId\n      const peerId = this.keyBook.data.get(peerIdStr) || PeerId.createFromB58String(peerIdStr); // Address Book\n\n      this._batchAddressBook(peerId, batch); // Key Book\n\n\n      !peerId.hasInlinePublicKey() && this._batchKeyBook(peerId, batch); // Metadata Book\n\n      this._batchMetadataBook(peerId, batch); // Proto Book\n\n\n      this._batchProtoBook(peerId, batch);\n    }\n\n    await batch.commit();\n    log('batch committed');\n  }\n  /**\n   * Add address book data of the peer to the batch.\n   *\n   * @private\n   * @param {PeerId} peerId\n   * @param {Batch} batch\n   */\n\n\n  _batchAddressBook(peerId, batch) {\n    const b32key = peerId.toString();\n    const key = new Key(`${NAMESPACE_ADDRESS}${b32key}`);\n    const entry = this.addressBook.data.get(peerId.toB58String());\n\n    try {\n      // Deleted from the book\n      if (!entry) {\n        batch.delete(key);\n        return;\n      }\n\n      const encodedData = Addresses.encode({\n        addrs: entry.addresses.map(address => ({\n          multiaddr: address.multiaddr.bytes,\n          isCertified: address.isCertified\n        })),\n        certifiedRecord: entry.record ? {\n          seq: entry.record.seqNumber,\n          raw: entry.record.raw\n        } : undefined\n      }).finish();\n      batch.put(key, encodedData);\n    } catch (err) {\n      log.error(err);\n    }\n  }\n  /**\n   * Add Key book data of the peer to the batch.\n   *\n   * @private\n   * @param {PeerId} peerId\n   * @param {Batch} batch\n   */\n\n\n  _batchKeyBook(peerId, batch) {\n    const b32key = peerId.toString();\n    const key = new Key(`${NAMESPACE_KEYS}${b32key}`);\n\n    try {\n      // Deleted from the book\n      if (!peerId.pubKey) {\n        batch.delete(key);\n        return;\n      }\n\n      const encodedData = peerId.marshalPubKey();\n      batch.put(key, encodedData);\n    } catch (err) {\n      log.error(err);\n    }\n  }\n  /**\n   * Add metadata book data of the peer to the batch.\n   *\n   * @private\n   * @param {PeerId} peerId\n   * @param {Batch} batch\n   */\n\n\n  _batchMetadataBook(peerId, batch) {\n    const b32key = peerId.toString();\n    const dirtyMetada = this._dirtyMetadata.get(peerId.toB58String()) || [];\n\n    try {\n      dirtyMetada.forEach((\n      /** @type {string} */\n      dirtyKey) => {\n        const key = new Key(`${NAMESPACE_METADATA}${b32key}/${dirtyKey}`);\n        const dirtyValue = this.metadataBook.getValue(peerId, dirtyKey);\n\n        if (dirtyValue) {\n          batch.put(key, dirtyValue);\n        } else {\n          batch.delete(key);\n        }\n      });\n    } catch (err) {\n      log.error(err);\n    }\n  }\n  /**\n   * Add proto book data of the peer to the batch.\n   *\n   * @private\n   * @param {PeerId} peerId\n   * @param {Batch} batch\n   */\n\n\n  _batchProtoBook(peerId, batch) {\n    const b32key = peerId.toString();\n    const key = new Key(`${NAMESPACE_PROTOCOL}${b32key}`);\n    const protocols = this.protoBook.get(peerId);\n\n    try {\n      // Deleted from the book\n      if (!protocols) {\n        batch.delete(key);\n        return;\n      }\n\n      const encodedData = Protocols.encode({\n        protocols\n      }).finish();\n      batch.put(key, encodedData);\n    } catch (err) {\n      log.error(err);\n    }\n  }\n  /**\n   * Process datastore entry and add its data to the correct book.\n   *\n   * @private\n   * @param {Object} params\n   * @param {Key} params.key - datastore key\n   * @param {Uint8Array} params.value - datastore value stored\n   * @returns {Promise<void>}\n   */\n\n\n  async _processDatastoreEntry({\n    key,\n    value\n  }) {\n    try {\n      const keyParts = key.toString().split('/');\n      const peerId = PeerId.createFromBytes(base32.decode(keyParts[3]));\n      let decoded;\n\n      switch (keyParts[2]) {\n        case 'addrs':\n          decoded = Addresses.decode(value); // @ts-ignore protected function\n\n          this.addressBook._setData(peerId, {\n            addresses: decoded.addrs.map(address => ({\n              multiaddr: new Multiaddr(address.multiaddr),\n              isCertified: Boolean(address.isCertified)\n            })),\n            record: decoded.certifiedRecord ? {\n              raw: decoded.certifiedRecord.raw,\n              seqNumber: decoded.certifiedRecord.seq\n            } : undefined\n          }, {\n            emit: false\n          });\n\n          break;\n\n        case 'keys':\n          decoded = await PeerId.createFromPubKey(value); // @ts-ignore protected function\n\n          this.keyBook._setData(decoded, decoded, {\n            emit: false\n          });\n\n          break;\n\n        case 'metadata':\n          this.metadataBook._setValue(peerId, keyParts[4], value, {\n            emit: false\n          });\n\n          break;\n\n        case 'protos':\n          decoded = Protocols.decode(value); // @ts-ignore protected function\n\n          this.protoBook._setData(peerId, new Set(decoded.protocols), {\n            emit: false\n          });\n\n          break;\n\n        default:\n          log('invalid data persisted for: ', key.toString());\n      }\n    } catch (err) {\n      log.error(err);\n    }\n  }\n\n}\n\nmodule.exports = PersistentPeerStore;","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/libp2p/src/peer-store/persistent/index.js"],"names":["debug","require","log","Object","assign","error","Key","Multiaddr","PeerId","base32","PeerStore","NAMESPACE_ADDRESS","NAMESPACE_COMMON","NAMESPACE_KEYS","NAMESPACE_METADATA","NAMESPACE_PROTOCOL","Addresses","Protocols","PersistentPeerStore","constructor","peerId","datastore","threshold","_datastore","_dirtyPeers","Set","_dirtyMetadata","Map","_addDirtyPeer","bind","start","on","_addDirtyPeerKey","_addDirtyPeerMetadata","entry","query","prefix","_processDatastoreEntry","stop","removeAllListeners","_commitData","peerIdstr","toB58String","add","size","catch","err","hasInlinePublicKey","metadata","mData","get","set","commitPeers","Array","from","length","clear","batch","peerIdStr","keyBook","data","createFromB58String","_batchAddressBook","_batchKeyBook","_batchMetadataBook","_batchProtoBook","commit","b32key","toString","key","addressBook","delete","encodedData","encode","addrs","addresses","map","address","multiaddr","bytes","isCertified","certifiedRecord","record","seq","seqNumber","raw","undefined","finish","put","pubKey","marshalPubKey","dirtyMetada","forEach","dirtyKey","dirtyValue","metadataBook","getValue","protocols","protoBook","value","keyParts","split","createFromBytes","decode","decoded","_setData","Boolean","emit","createFromPubKey","_setValue","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = Object.assign(debug('libp2p:persistent-peer-store'), {\n  error: debug('libp2p:persistent-peer-store:err')\n})\nconst { Key } = require('interface-datastore')\nconst { Multiaddr } = require('multiaddr')\nconst PeerId = require('peer-id')\nconst { base32 } = require('multiformats/bases/base32')\n\nconst PeerStore = require('..')\n\nconst {\n  NAMESPACE_ADDRESS,\n  NAMESPACE_COMMON,\n  NAMESPACE_KEYS,\n  NAMESPACE_METADATA,\n  NAMESPACE_PROTOCOL\n} = require('./consts')\n\nconst { Addresses } = require('./pb/address-book')\nconst { Protocols } = require('./pb/proto-book')\n\n/**\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('../address-book.js').Address} Address\n */\n\n/**\n * @typedef {Object} PersistentPeerStoreProperties\n * @property {PeerId} peerId\n * @property {import('interface-datastore').Datastore} datastore\n *\n * @typedef {Object} PersistentPeerStoreOptions\n * @property {number} [threshold = 5] - Number of dirty peers allowed before commit data.\n */\n\n/**\n * Responsible for managing the persistence of data in the PeerStore.\n */\nclass PersistentPeerStore extends PeerStore {\n  /**\n   * @class\n   * @param {PersistentPeerStoreProperties & PersistentPeerStoreOptions} properties\n   */\n  constructor ({ peerId, datastore, threshold = 5 }) {\n    super({ peerId })\n\n    /**\n     * Backend datastore used to persist data.\n     */\n    this._datastore = datastore\n\n    /**\n     * Peers modified after the latest data persisted.\n     */\n    this._dirtyPeers = new Set()\n\n    /**\n     * Peers metadata changed mapping peer identifers to metadata changed.\n     *\n     * @type {Map<string, Set<string>>}\n     */\n    this._dirtyMetadata = new Map()\n\n    this.threshold = threshold\n    this._addDirtyPeer = this._addDirtyPeer.bind(this)\n  }\n\n  /**\n   * Start Persistent PeerStore.\n   *\n   * @returns {Promise<void>}\n   */\n  async start () {\n    log('PeerStore is starting')\n\n    // Handlers for dirty peers\n    this.on('change:protocols', this._addDirtyPeer)\n    this.on('change:multiaddrs', this._addDirtyPeer)\n    this.on('change:pubkey', this._addDirtyPeerKey)\n    this.on('change:metadata', this._addDirtyPeerMetadata)\n\n    // Load data\n    for await (const entry of this._datastore.query({ prefix: NAMESPACE_COMMON })) {\n      await this._processDatastoreEntry(entry)\n    }\n\n    log('PeerStore started')\n  }\n\n  /**\n   * Stop Persistent PeerStore.\n   *\n   * @returns {Promise<void>}\n   */\n  async stop () {\n    log('PeerStore is stopping')\n    this.removeAllListeners()\n    await this._commitData()\n    log('PeerStore stopped')\n  }\n\n  /**\n   * Add modified peer to the dirty set\n   *\n   * @private\n   * @param {Object} params\n   * @param {PeerId} params.peerId\n   */\n  _addDirtyPeer ({ peerId }) {\n    const peerIdstr = peerId.toB58String()\n\n    log('add dirty peer', peerIdstr)\n    this._dirtyPeers.add(peerIdstr)\n\n    if (this._dirtyPeers.size >= this.threshold) {\n      // Commit current data\n      this._commitData().catch(err => {\n        log.error('error committing data', err)\n      })\n    }\n  }\n\n  /**\n   * Add modified peer key to the dirty set\n   *\n   * @private\n   * @param {Object} params\n   * @param {PeerId} params.peerId\n   */\n  _addDirtyPeerKey ({ peerId }) {\n    // Not add if inline key available\n    if (peerId.hasInlinePublicKey()) {\n      return\n    }\n\n    const peerIdstr = peerId.toB58String()\n\n    log('add dirty peer key', peerIdstr)\n    this._dirtyPeers.add(peerIdstr)\n\n    if (this._dirtyPeers.size >= this.threshold) {\n      // Commit current data\n      this._commitData().catch(err => {\n        log.error('error committing data', err)\n      })\n    }\n  }\n\n  /**\n   * Add modified metadata peer to the set.\n   *\n   * @private\n   * @param {Object} params\n   * @param {PeerId} params.peerId\n   * @param {string} params.metadata\n   */\n  _addDirtyPeerMetadata ({ peerId, metadata }) {\n    const peerIdstr = peerId.toB58String()\n\n    log('add dirty metadata peer', peerIdstr)\n    this._dirtyPeers.add(peerIdstr)\n\n    // Add dirty metadata key\n    const mData = this._dirtyMetadata.get(peerIdstr) || new Set()\n    mData.add(metadata)\n    this._dirtyMetadata.set(peerIdstr, mData)\n\n    if (this._dirtyPeers.size >= this.threshold) {\n      // Commit current data\n      this._commitData().catch(err => {\n        log.error('error committing data', err)\n      })\n    }\n  }\n\n  /**\n   * Add all the peers current data to a datastore batch and commit it.\n   *\n   * @private\n   * @returns {Promise<void>}\n   */\n  async _commitData () {\n    const commitPeers = Array.from(this._dirtyPeers)\n\n    if (!commitPeers.length) {\n      return\n    }\n\n    // Clear Dirty Peers set\n    this._dirtyPeers.clear()\n\n    log('create batch commit')\n    const batch = this._datastore.batch()\n    for (const peerIdStr of commitPeers) {\n      // PeerId\n      const peerId = this.keyBook.data.get(peerIdStr) || PeerId.createFromB58String(peerIdStr)\n\n      // Address Book\n      this._batchAddressBook(peerId, batch)\n\n      // Key Book\n      !peerId.hasInlinePublicKey() && this._batchKeyBook(peerId, batch)\n\n      // Metadata Book\n      this._batchMetadataBook(peerId, batch)\n\n      // Proto Book\n      this._batchProtoBook(peerId, batch)\n    }\n\n    await batch.commit()\n    log('batch committed')\n  }\n\n  /**\n   * Add address book data of the peer to the batch.\n   *\n   * @private\n   * @param {PeerId} peerId\n   * @param {Batch} batch\n   */\n  _batchAddressBook (peerId, batch) {\n    const b32key = peerId.toString()\n    const key = new Key(`${NAMESPACE_ADDRESS}${b32key}`)\n\n    const entry = this.addressBook.data.get(peerId.toB58String())\n\n    try {\n      // Deleted from the book\n      if (!entry) {\n        batch.delete(key)\n        return\n      }\n\n      const encodedData = Addresses.encode({\n        addrs: entry.addresses.map((address) => ({\n          multiaddr: address.multiaddr.bytes,\n          isCertified: address.isCertified\n        })),\n        certifiedRecord: entry.record\n          ? {\n              seq: entry.record.seqNumber,\n              raw: entry.record.raw\n            }\n          : undefined\n      }).finish()\n\n      batch.put(key, encodedData)\n    } catch (err) {\n      log.error(err)\n    }\n  }\n\n  /**\n   * Add Key book data of the peer to the batch.\n   *\n   * @private\n   * @param {PeerId} peerId\n   * @param {Batch} batch\n   */\n  _batchKeyBook (peerId, batch) {\n    const b32key = peerId.toString()\n    const key = new Key(`${NAMESPACE_KEYS}${b32key}`)\n\n    try {\n      // Deleted from the book\n      if (!peerId.pubKey) {\n        batch.delete(key)\n        return\n      }\n\n      const encodedData = peerId.marshalPubKey()\n\n      batch.put(key, encodedData)\n    } catch (err) {\n      log.error(err)\n    }\n  }\n\n  /**\n   * Add metadata book data of the peer to the batch.\n   *\n   * @private\n   * @param {PeerId} peerId\n   * @param {Batch} batch\n   */\n  _batchMetadataBook (peerId, batch) {\n    const b32key = peerId.toString()\n    const dirtyMetada = this._dirtyMetadata.get(peerId.toB58String()) || []\n\n    try {\n      dirtyMetada.forEach((/** @type {string} */ dirtyKey) => {\n        const key = new Key(`${NAMESPACE_METADATA}${b32key}/${dirtyKey}`)\n        const dirtyValue = this.metadataBook.getValue(peerId, dirtyKey)\n\n        if (dirtyValue) {\n          batch.put(key, dirtyValue)\n        } else {\n          batch.delete(key)\n        }\n      })\n    } catch (err) {\n      log.error(err)\n    }\n  }\n\n  /**\n   * Add proto book data of the peer to the batch.\n   *\n   * @private\n   * @param {PeerId} peerId\n   * @param {Batch} batch\n   */\n  _batchProtoBook (peerId, batch) {\n    const b32key = peerId.toString()\n    const key = new Key(`${NAMESPACE_PROTOCOL}${b32key}`)\n\n    const protocols = this.protoBook.get(peerId)\n\n    try {\n      // Deleted from the book\n      if (!protocols) {\n        batch.delete(key)\n        return\n      }\n\n      const encodedData = Protocols.encode({ protocols }).finish()\n\n      batch.put(key, encodedData)\n    } catch (err) {\n      log.error(err)\n    }\n  }\n\n  /**\n   * Process datastore entry and add its data to the correct book.\n   *\n   * @private\n   * @param {Object} params\n   * @param {Key} params.key - datastore key\n   * @param {Uint8Array} params.value - datastore value stored\n   * @returns {Promise<void>}\n   */\n  async _processDatastoreEntry ({ key, value }) {\n    try {\n      const keyParts = key.toString().split('/')\n      const peerId = PeerId.createFromBytes(base32.decode(keyParts[3]))\n\n      let decoded\n      switch (keyParts[2]) {\n        case 'addrs':\n          decoded = Addresses.decode(value)\n\n          // @ts-ignore protected function\n          this.addressBook._setData(\n            peerId,\n            {\n              addresses: decoded.addrs.map((address) => ({\n                multiaddr: new Multiaddr(address.multiaddr),\n                isCertified: Boolean(address.isCertified)\n              })),\n              record: decoded.certifiedRecord\n                ? {\n                    raw: decoded.certifiedRecord.raw,\n                    seqNumber: decoded.certifiedRecord.seq\n                  }\n                : undefined\n            },\n            { emit: false })\n          break\n        case 'keys':\n          decoded = await PeerId.createFromPubKey(value)\n\n          // @ts-ignore protected function\n          this.keyBook._setData(\n            decoded,\n            decoded,\n            { emit: false })\n          break\n        case 'metadata':\n          this.metadataBook._setValue(\n            peerId,\n            keyParts[4],\n            value,\n            { emit: false })\n          break\n        case 'protos':\n          decoded = Protocols.decode(value)\n\n          // @ts-ignore protected function\n          this.protoBook._setData(\n            peerId,\n            new Set(decoded.protocols),\n            { emit: false })\n          break\n        default:\n          log('invalid data persisted for: ', key.toString())\n      }\n    } catch (err) {\n      log.error(err)\n    }\n  }\n}\n\nmodule.exports = PersistentPeerStore\n"]},"metadata":{},"sourceType":"script"}