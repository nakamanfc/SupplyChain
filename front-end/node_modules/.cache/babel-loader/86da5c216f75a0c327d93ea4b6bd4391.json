{"ast":null,"code":"'use strict';\n\nconst errcode = require('err-code');\n\nconst pTimeout = require('p-timeout');\n\nconst {\n  equals: uint8ArrayEquals\n} = require('uint8arrays/equals');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst libp2pRecord = require('libp2p-record');\n\nconst c = require('../constants');\n\nconst Query = require('../query');\n\nconst utils = require('../utils');\n\nconst Record = libp2pRecord.Record;\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../query').DHTQueryResult} DHTQueryResult\n */\n\n/**\n * @param {import('../')} dht\n */\n\nmodule.exports = dht => {\n  /**\n   * @param {Uint8Array} key\n   * @param {Uint8Array} rec\n   */\n  const putLocal = async (key, rec) => {\n    // eslint-disable-line require-await\n    return dht.datastore.put(utils.bufferToKey(key), rec);\n  };\n  /**\n   * Attempt to retrieve the value for the given key from\n   * the local datastore.\n   *\n   * @param {Uint8Array} key\n   */\n\n\n  const getLocal = async key => {\n    dht._log(`getLocal ${uint8ArrayToString(key, 'base32')}`);\n\n    const raw = await dht.datastore.get(utils.bufferToKey(key));\n\n    dht._log(`found ${uint8ArrayToString(key, 'base32')} in local datastore`);\n\n    const rec = Record.deserialize(raw);\n    await dht._verifyRecordLocally(rec);\n    return rec;\n  };\n  /**\n   * Send the best record found to any peers that have an out of date record.\n   *\n   * @param {Uint8Array} key\n   * @param {import('../query').DHTQueryValue[]} vals - values retrieved from the DHT\n   * @param {Uint8Array} best - the best record that was found\n   */\n\n\n  const sendCorrectionRecord = async (key, vals, best) => {\n    const fixupRec = await utils.createPutRecord(key, best);\n    return Promise.all(vals.map(async v => {\n      // no need to do anything\n      if (uint8ArrayEquals(v.val, best)) {\n        return;\n      } // correct ourself\n\n\n      if (dht._isSelf(v.from)) {\n        try {\n          await dht._putLocal(key, fixupRec);\n        } catch (err) {\n          dht._log.error('Failed error correcting self', err);\n        }\n\n        return;\n      } // send correction\n\n\n      try {\n        await dht._putValueToPeer(key, fixupRec, v.from);\n      } catch (err) {\n        dht._log.error('Failed error correcting entry', err);\n      }\n    }));\n  };\n\n  return {\n    /**\n     * Store the given key/value pair locally, in the datastore.\n     *\n     * @param {Uint8Array} key\n     * @param {Uint8Array} rec - encoded record\n     */\n    async _putLocal(key, rec) {\n      // eslint-disable-line require-await\n      return putLocal(key, rec);\n    },\n\n    /**\n     * Store the given key/value  pair in the DHT.\n     *\n     * @param {Uint8Array} key\n     * @param {Uint8Array} value\n     * @param {object} [options] - put options\n     * @param {number} [options.minPeers] - minimum number of peers required to successfully put (default: closestPeers.length)\n     */\n    async put(key, value, options = {}) {\n      dht._log('PutValue %b', key); // create record in the dht format\n\n\n      const record = await utils.createPutRecord(key, value); // store the record locally\n\n      await putLocal(key, record); // put record to the closest peers\n\n      let counterAll = 0;\n      let counterSuccess = 0;\n      await utils.mapParallel(dht.getClosestPeers(key, {\n        shallow: true\n      }), async peer => {\n        try {\n          counterAll += 1;\n          await dht._putValueToPeer(key, record, peer);\n          counterSuccess += 1;\n        } catch (err) {\n          dht._log.error('Failed to put to peer (%b): %s', peer.id, err);\n        }\n      }); // verify if we were able to put to enough peers\n\n      const minPeers = options.minPeers || counterAll; // Ensure we have a default `minPeers`\n\n      if (minPeers > counterSuccess) {\n        const error = errcode(new Error(`Failed to put value to enough peers: ${counterSuccess}/${minPeers}`), 'ERR_NOT_ENOUGH_PUT_PEERS');\n\n        dht._log.error(error);\n\n        throw error;\n      }\n    },\n\n    /**\n     * Get the value to the given key.\n     * Times out after 1 minute by default.\n     *\n     * @param {Uint8Array} key\n     * @param {object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     */\n    async get(key, options = {}) {\n      options.timeout = options.timeout || c.minute;\n\n      dht._log('_get %b', key);\n\n      const vals = await dht.getMany(key, c.GET_MANY_RECORD_COUNT, options);\n      const recs = vals.map(v => v.val);\n      let i = 0;\n\n      try {\n        i = libp2pRecord.selection.bestRecord(dht.selectors, key, recs);\n      } catch (err) {\n        // Assume the first record if no selector available\n        if (err.code !== 'ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY') {\n          throw err;\n        }\n      }\n\n      const best = recs[i];\n\n      dht._log('GetValue %b %s', key, best);\n\n      if (!best) {\n        throw errcode(new Error('best value was not found'), 'ERR_NOT_FOUND');\n      }\n\n      await sendCorrectionRecord(key, vals, best);\n      return best;\n    },\n\n    /**\n     * Get the `n` values to the given key without sorting.\n     *\n     * @param {Uint8Array} key\n     * @param {number} nvals\n     * @param {object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     */\n    async getMany(key, nvals, options = {}) {\n      options.timeout = options.timeout || c.minute;\n\n      dht._log('getMany %b (%s)', key, nvals);\n\n      const vals = [];\n      let localRec;\n\n      try {\n        localRec = await getLocal(key);\n      } catch (err) {\n        if (nvals === 0) {\n          throw err;\n        }\n      }\n\n      if (localRec) {\n        vals.push({\n          val: localRec.value,\n          from: dht.peerId\n        });\n      }\n\n      if (vals.length >= nvals) {\n        return vals;\n      }\n\n      const id = await utils.convertBuffer(key);\n      const rtp = dht.routingTable.closestPeers(id, dht.kBucketSize);\n\n      dht._log('peers in rt: %d', rtp.length);\n\n      if (rtp.length === 0) {\n        const errMsg = 'Failed to lookup key! No peers from routing table!';\n\n        dht._log.error(errMsg);\n\n        if (vals.length === 0) {\n          throw errcode(new Error(errMsg), 'ERR_NO_PEERS_IN_ROUTING_TABLE');\n        }\n\n        return vals;\n      }\n\n      const valsLength = vals.length;\n      /**\n       * @param {number} pathIndex\n       * @param {number} numPaths\n       */\n\n      function createQuery(pathIndex, numPaths) {\n        // This function body runs once per disjoint path\n        const pathSize = utils.pathSize(nvals - valsLength, numPaths);\n        let queryResults = 0;\n        /**\n         * Here we return the query function to use on this particular disjoint path\n         *\n         * @param {PeerId} peer\n         */\n\n        async function disjointPathQuery(peer) {\n          let rec, peers, lookupErr;\n\n          try {\n            const results = await dht._getValueOrPeers(peer, key);\n            rec = results.record;\n            peers = results.peers;\n          } catch (err) {\n            // If we have an invalid record we just want to continue and fetch a new one.\n            if (err.code !== 'ERR_INVALID_RECORD') {\n              throw err;\n            }\n\n            lookupErr = err;\n          }\n          /** @type {import('../query').QueryResult} */\n\n\n          const res = {\n            closerPeers: peers\n          };\n\n          if (rec && rec.value) {\n            vals.push({\n              val: rec.value,\n              from: peer\n            });\n            queryResults++;\n          } else if (lookupErr) {\n            vals.push({\n              err: lookupErr,\n              from: peer\n            });\n            queryResults++;\n          } // enough is enough\n\n\n          if (queryResults >= pathSize) {\n            res.pathComplete = true;\n          }\n\n          return res;\n        }\n\n        return disjointPathQuery;\n      } // we have peers, lets send the actual query to them\n\n\n      const query = new Query(dht, key, createQuery);\n\n      try {\n        await pTimeout(query.run(rtp), options.timeout);\n      } catch (err) {\n        if (vals.length === 0) {\n          throw err;\n        }\n      } finally {\n        query.stop();\n      }\n\n      return vals;\n    }\n\n  };\n};","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/libp2p-kad-dht/src/content-fetching/index.js"],"names":["errcode","require","pTimeout","equals","uint8ArrayEquals","toString","uint8ArrayToString","libp2pRecord","c","Query","utils","Record","module","exports","dht","putLocal","key","rec","datastore","put","bufferToKey","getLocal","_log","raw","get","deserialize","_verifyRecordLocally","sendCorrectionRecord","vals","best","fixupRec","createPutRecord","Promise","all","map","v","val","_isSelf","from","_putLocal","err","error","_putValueToPeer","value","options","record","counterAll","counterSuccess","mapParallel","getClosestPeers","shallow","peer","id","minPeers","Error","timeout","minute","getMany","GET_MANY_RECORD_COUNT","recs","i","selection","bestRecord","selectors","code","nvals","localRec","push","peerId","length","convertBuffer","rtp","routingTable","closestPeers","kBucketSize","errMsg","valsLength","createQuery","pathIndex","numPaths","pathSize","queryResults","disjointPathQuery","peers","lookupErr","results","_getValueOrPeers","res","closerPeers","pathComplete","query","run","stop"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errcode = require('err-code')\nconst pTimeout = require('p-timeout')\nconst { equals: uint8ArrayEquals } = require('uint8arrays/equals')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst libp2pRecord = require('libp2p-record')\nconst c = require('../constants')\nconst Query = require('../query')\nconst utils = require('../utils')\nconst Record = libp2pRecord.Record\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../query').DHTQueryResult} DHTQueryResult\n */\n\n/**\n * @param {import('../')} dht\n */\nmodule.exports = (dht) => {\n  /**\n   * @param {Uint8Array} key\n   * @param {Uint8Array} rec\n   */\n  const putLocal = async (key, rec) => { // eslint-disable-line require-await\n    return dht.datastore.put(utils.bufferToKey(key), rec)\n  }\n\n  /**\n   * Attempt to retrieve the value for the given key from\n   * the local datastore.\n   *\n   * @param {Uint8Array} key\n   */\n  const getLocal = async (key) => {\n    dht._log(`getLocal ${uint8ArrayToString(key, 'base32')}`)\n\n    const raw = await dht.datastore.get(utils.bufferToKey(key))\n    dht._log(`found ${uint8ArrayToString(key, 'base32')} in local datastore`)\n\n    const rec = Record.deserialize(raw)\n\n    await dht._verifyRecordLocally(rec)\n\n    return rec\n  }\n\n  /**\n   * Send the best record found to any peers that have an out of date record.\n   *\n   * @param {Uint8Array} key\n   * @param {import('../query').DHTQueryValue[]} vals - values retrieved from the DHT\n   * @param {Uint8Array} best - the best record that was found\n   */\n  const sendCorrectionRecord = async (key, vals, best) => {\n    const fixupRec = await utils.createPutRecord(key, best)\n\n    return Promise.all(vals.map(async (v) => {\n      // no need to do anything\n      if (uint8ArrayEquals(v.val, best)) {\n        return\n      }\n\n      // correct ourself\n      if (dht._isSelf(v.from)) {\n        try {\n          await dht._putLocal(key, fixupRec)\n        } catch (err) {\n          dht._log.error('Failed error correcting self', err)\n        }\n        return\n      }\n\n      // send correction\n      try {\n        await dht._putValueToPeer(key, fixupRec, v.from)\n      } catch (err) {\n        dht._log.error('Failed error correcting entry', err)\n      }\n    }))\n  }\n\n  return {\n    /**\n     * Store the given key/value pair locally, in the datastore.\n     *\n     * @param {Uint8Array} key\n     * @param {Uint8Array} rec - encoded record\n     */\n    async _putLocal (key, rec) { // eslint-disable-line require-await\n      return putLocal(key, rec)\n    },\n\n    /**\n     * Store the given key/value  pair in the DHT.\n     *\n     * @param {Uint8Array} key\n     * @param {Uint8Array} value\n     * @param {object} [options] - put options\n     * @param {number} [options.minPeers] - minimum number of peers required to successfully put (default: closestPeers.length)\n     */\n    async put (key, value, options = {}) {\n      dht._log('PutValue %b', key)\n\n      // create record in the dht format\n      const record = await utils.createPutRecord(key, value)\n\n      // store the record locally\n      await putLocal(key, record)\n\n      // put record to the closest peers\n      let counterAll = 0\n      let counterSuccess = 0\n\n      await utils.mapParallel(dht.getClosestPeers(key, { shallow: true }), async (peer) => {\n        try {\n          counterAll += 1\n          await dht._putValueToPeer(key, record, peer)\n          counterSuccess += 1\n        } catch (err) {\n          dht._log.error('Failed to put to peer (%b): %s', peer.id, err)\n        }\n      })\n\n      // verify if we were able to put to enough peers\n      const minPeers = options.minPeers || counterAll // Ensure we have a default `minPeers`\n\n      if (minPeers > counterSuccess) {\n        const error = errcode(new Error(`Failed to put value to enough peers: ${counterSuccess}/${minPeers}`), 'ERR_NOT_ENOUGH_PUT_PEERS')\n        dht._log.error(error)\n        throw error\n      }\n    },\n\n    /**\n     * Get the value to the given key.\n     * Times out after 1 minute by default.\n     *\n     * @param {Uint8Array} key\n     * @param {object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     */\n    async get (key, options = {}) {\n      options.timeout = options.timeout || c.minute\n\n      dht._log('_get %b', key)\n\n      const vals = await dht.getMany(key, c.GET_MANY_RECORD_COUNT, options)\n      const recs = vals.map((v) => v.val)\n      let i = 0\n\n      try {\n        i = libp2pRecord.selection.bestRecord(dht.selectors, key, recs)\n      } catch (err) {\n        // Assume the first record if no selector available\n        if (err.code !== 'ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY') {\n          throw err\n        }\n      }\n\n      const best = recs[i]\n      dht._log('GetValue %b %s', key, best)\n\n      if (!best) {\n        throw errcode(new Error('best value was not found'), 'ERR_NOT_FOUND')\n      }\n\n      await sendCorrectionRecord(key, vals, best)\n\n      return best\n    },\n\n    /**\n     * Get the `n` values to the given key without sorting.\n     *\n     * @param {Uint8Array} key\n     * @param {number} nvals\n     * @param {object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     */\n    async getMany (key, nvals, options = {}) {\n      options.timeout = options.timeout || c.minute\n\n      dht._log('getMany %b (%s)', key, nvals)\n\n      const vals = []\n      let localRec\n\n      try {\n        localRec = await getLocal(key)\n      } catch (err) {\n        if (nvals === 0) {\n          throw err\n        }\n      }\n\n      if (localRec) {\n        vals.push({\n          val: localRec.value,\n          from: dht.peerId\n        })\n      }\n\n      if (vals.length >= nvals) {\n        return vals\n      }\n\n      const id = await utils.convertBuffer(key)\n      const rtp = dht.routingTable.closestPeers(id, dht.kBucketSize)\n\n      dht._log('peers in rt: %d', rtp.length)\n\n      if (rtp.length === 0) {\n        const errMsg = 'Failed to lookup key! No peers from routing table!'\n\n        dht._log.error(errMsg)\n        if (vals.length === 0) {\n          throw errcode(new Error(errMsg), 'ERR_NO_PEERS_IN_ROUTING_TABLE')\n        }\n        return vals\n      }\n\n      const valsLength = vals.length\n\n      /**\n       * @param {number} pathIndex\n       * @param {number} numPaths\n       */\n      function createQuery (pathIndex, numPaths) {\n        // This function body runs once per disjoint path\n        const pathSize = utils.pathSize(nvals - valsLength, numPaths)\n        let queryResults = 0\n\n        /**\n         * Here we return the query function to use on this particular disjoint path\n         *\n         * @param {PeerId} peer\n         */\n        async function disjointPathQuery (peer) {\n          let rec, peers, lookupErr\n          try {\n            const results = await dht._getValueOrPeers(peer, key)\n            rec = results.record\n            peers = results.peers\n          } catch (err) {\n            // If we have an invalid record we just want to continue and fetch a new one.\n            if (err.code !== 'ERR_INVALID_RECORD') {\n              throw err\n            }\n            lookupErr = err\n          }\n\n          /** @type {import('../query').QueryResult} */\n          const res = {\n            closerPeers: peers\n          }\n\n          if (rec && rec.value) {\n            vals.push({\n              val: rec.value,\n              from: peer\n            })\n\n            queryResults++\n          } else if (lookupErr) {\n            vals.push({\n              err: lookupErr,\n              from: peer\n            })\n\n            queryResults++\n          }\n\n          // enough is enough\n          if (queryResults >= pathSize) {\n            res.pathComplete = true\n          }\n\n          return res\n        }\n\n        return disjointPathQuery\n      }\n\n      // we have peers, lets send the actual query to them\n      const query = new Query(dht, key, createQuery)\n\n      try {\n        await pTimeout(query.run(rtp), options.timeout)\n      } catch (err) {\n        if (vals.length === 0) {\n          throw err\n        }\n      } finally {\n        query.stop()\n      }\n\n      return vals\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}