{"ast":null,"code":"'use strict';\n\nconst {\n  Key,\n  Adapter\n} = require('interface-datastore');\n\nconst {\n  encodeBase32,\n  keyToTopic,\n  topicToKey\n} = require('./utils');\n\nconst {\n  equals: uint8ArrayEquals\n} = require('uint8arrays/equals');\n\nconst errcode = require('err-code');\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('datastore-pubsub:publisher'), {\n  error: debug('datastore-pubsub:publisher:error')\n});\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('./types').Validator} Validator\n * @typedef {import('./types').SubscriptionKeyFn} SubscriptionKeyFn\n * @typedef {import('libp2p-interfaces/src/pubsub').InMessage} PubSubMessage\n */\n// DatastorePubsub is responsible for providing an api for pubsub to be used as a datastore with\n// [TieredDatastore]{@link https://github.com/ipfs/js-datastore-core/blob/master/src/tiered.js}\n\nclass DatastorePubsub extends Adapter {\n  /**\n   * Creates an instance of DatastorePubsub.\n   *\n   * @param {import('libp2p-interfaces/src/pubsub')} pubsub - pubsub implementation\n   * @param {import('interface-datastore').Datastore} datastore - datastore instance\n   * @param {PeerId} peerId - peer-id instance\n   * @param {Validator} validator - validator functions\n   * @param {SubscriptionKeyFn} [subscriptionKeyFn] - function to manipulate the key topic received before processing it\n   * @memberof DatastorePubsub\n   */\n  constructor(pubsub, datastore, peerId, validator, subscriptionKeyFn) {\n    super();\n\n    if (!validator) {\n      throw errcode(new TypeError('missing validator'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    if (typeof validator.validate !== 'function') {\n      throw errcode(new TypeError('missing validate function'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    if (typeof validator.select !== 'function') {\n      throw errcode(new TypeError('missing select function'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    if (subscriptionKeyFn && typeof subscriptionKeyFn !== 'function') {\n      throw errcode(new TypeError('invalid subscriptionKeyFn received'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    this._pubsub = pubsub;\n    this._datastore = datastore;\n    this._peerId = peerId;\n    this._validator = validator;\n    this._handleSubscriptionKeyFn = subscriptionKeyFn; // Bind _onMessage function, which is called by pubsub.\n\n    this._onMessage = this._onMessage.bind(this);\n  }\n  /**\n   * Publishes a value through pubsub.\n   *\n   * @param {Uint8Array} key - identifier of the value to be published.\n   * @param {Uint8Array} val - value to be propagated.\n   */\n  // @ts-ignore Datastores take keys as Keys, this one takes Uint8Arrays\n\n\n  async put(key, val) {\n    if (!(key instanceof Uint8Array)) {\n      const errMsg = 'datastore key does not have a valid format';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n    }\n\n    if (!(val instanceof Uint8Array)) {\n      const errMsg = 'received value is not a Uint8Array';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_VALUE_RECEIVED');\n    }\n\n    const stringifiedTopic = keyToTopic(key);\n    log(`publish value for topic ${stringifiedTopic}`); // Publish record to pubsub\n\n    await this._pubsub.publish(stringifiedTopic, val);\n  }\n  /**\n   * Try to subscribe a topic with Pubsub and returns the local value if available.\n   *\n   * @param {Uint8Array} key - identifier of the value to be subscribed.\n   */\n  // @ts-ignore Datastores take keys as Keys, this one takes Uint8Arrays\n\n\n  async get(key) {\n    if (!(key instanceof Uint8Array)) {\n      const errMsg = 'datastore key does not have a valid format';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n    }\n\n    const stringifiedTopic = keyToTopic(key);\n    const subscriptions = await this._pubsub.getTopics(); // If already subscribed, just try to get it\n\n    if (subscriptions && Array.isArray(subscriptions) && subscriptions.indexOf(stringifiedTopic) > -1) {\n      return this._getLocal(key);\n    } // subscribe\n\n\n    try {\n      this._pubsub.on(stringifiedTopic, this._onMessage);\n\n      await this._pubsub.subscribe(stringifiedTopic);\n    } catch (err) {\n      const errMsg = `cannot subscribe topic ${stringifiedTopic}`;\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_SUBSCRIBING_TOPIC');\n    }\n\n    log(`subscribed values for key ${stringifiedTopic}`);\n    return this._getLocal(key);\n  }\n  /**\n   * Unsubscribe topic.\n   *\n   * @param {Uint8Array} key - identifier of the value to unsubscribe.\n   * @returns {void}\n   */\n\n\n  unsubscribe(key) {\n    const stringifiedTopic = keyToTopic(key);\n\n    this._pubsub.removeListener(stringifiedTopic, this._onMessage);\n\n    return this._pubsub.unsubscribe(stringifiedTopic);\n  }\n  /**\n   * Get record from local datastore\n   *\n   * @private\n   * @param {Uint8Array} key\n   */\n\n\n  async _getLocal(key) {\n    // encode key - base32(/ipns/{cid})\n    const routingKey = new Key('/' + encodeBase32(key), false);\n    let dsVal;\n\n    try {\n      dsVal = await this._datastore.get(routingKey);\n    } catch (err) {\n      if (err.code !== 'ERR_NOT_FOUND') {\n        const errMsg = `unexpected error getting the ipns record for ${routingKey.toString()}`;\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD');\n      }\n\n      const errMsg = `local record requested was not found for ${routingKey.toString()}`;\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_NOT_FOUND');\n    }\n\n    if (!(dsVal instanceof Uint8Array)) {\n      const errMsg = 'found record that we couldn\\'t convert to a value';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_RECORD_RECEIVED');\n    }\n\n    return dsVal;\n  }\n  /**\n   * handles pubsub subscription messages\n   *\n   * @param {PubSubMessage} msg\n   */\n\n\n  async _onMessage(msg) {\n    const {\n      data,\n      from,\n      topicIDs\n    } = msg;\n    let key;\n\n    try {\n      key = topicToKey(topicIDs[0]);\n    } catch (err) {\n      log.error(err);\n      return;\n    }\n\n    log(`message received for topic ${topicIDs[0]}`); // Stop if the message is from the peer (it already stored it while publishing to pubsub)\n\n    if (from === this._peerId.toB58String()) {\n      log('message discarded as it is from the same peer');\n      return;\n    }\n\n    if (this._handleSubscriptionKeyFn) {\n      let res;\n\n      try {\n        res = await this._handleSubscriptionKeyFn(key);\n      } catch (err) {\n        log.error('message discarded by the subscriptionKeyFn');\n        return;\n      }\n\n      key = res;\n    }\n\n    try {\n      await this._storeIfSubscriptionIsBetter(key, data);\n    } catch (err) {\n      log.error(err);\n    }\n  }\n  /**\n   * Store the received record if it is better than the current stored\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} data\n   */\n\n\n  async _storeIfSubscriptionIsBetter(key, data) {\n    let isBetter = false;\n\n    try {\n      isBetter = await this._isBetter(key, data);\n    } catch (err) {\n      if (err.code !== 'ERR_NOT_VALID_RECORD') {\n        throw err;\n      }\n    }\n\n    if (isBetter) {\n      await this._storeRecord(key, data);\n    }\n  }\n  /**\n   * Validate record according to the received validation function\n   *\n   * @param {Uint8Array} value\n   * @param {Uint8Array} peerId\n   */\n\n\n  async _validateRecord(value, peerId) {\n    // eslint-disable-line require-await\n    return this._validator.validate(value, peerId);\n  }\n  /**\n   * Select the best record according to the received select function\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array[]} records\n   */\n\n\n  async _selectRecord(key, records) {\n    const res = await this._validator.select(key, records); // If the selected was the first (0), it should be stored (true)\n\n    return res === 0;\n  }\n  /**\n   * Verify if the record received through pubsub is valid and better than the one currently stored\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} val\n   */\n\n\n  async _isBetter(key, val) {\n    try {\n      await this._validateRecord(val, key);\n    } catch (err) {\n      // If not valid, it is not better than the one currently available\n      const errMsg = 'record received through pubsub is not valid';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_NOT_VALID_RECORD');\n    } // Get Local record\n\n\n    const dsKey = new Key(key);\n    let currentRecord;\n\n    try {\n      currentRecord = await this._getLocal(dsKey.uint8Array());\n    } catch (err) {\n      // if the old one is invalid, the new one is *always* better\n      return true;\n    } // if the same record, do not need to store\n\n\n    if (uint8ArrayEquals(currentRecord, val)) {\n      return false;\n    } // verify if the received record should replace the current one\n\n\n    return this._selectRecord(key, [currentRecord, val]);\n  }\n  /**\n   * add record to datastore\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} data\n   */\n\n\n  async _storeRecord(key, data) {\n    // encode key - base32(/ipns/{cid})\n    const routingKey = new Key('/' + encodeBase32(key), false);\n    await this._datastore.put(routingKey, data);\n    log(`record for ${keyToTopic(key)} was stored in the datastore`);\n  }\n\n}\n\nexports = module.exports = DatastorePubsub;","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/datastore-pubsub/src/index.js"],"names":["Key","Adapter","require","encodeBase32","keyToTopic","topicToKey","equals","uint8ArrayEquals","errcode","debug","log","Object","assign","error","DatastorePubsub","constructor","pubsub","datastore","peerId","validator","subscriptionKeyFn","TypeError","validate","select","_pubsub","_datastore","_peerId","_validator","_handleSubscriptionKeyFn","_onMessage","bind","put","key","val","Uint8Array","errMsg","Error","stringifiedTopic","publish","get","subscriptions","getTopics","Array","isArray","indexOf","_getLocal","on","subscribe","err","unsubscribe","removeListener","routingKey","dsVal","code","toString","msg","data","from","topicIDs","toB58String","res","_storeIfSubscriptionIsBetter","isBetter","_isBetter","_storeRecord","_validateRecord","value","_selectRecord","records","dsKey","currentRecord","uint8Array","exports","module"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Key, Adapter } = require('interface-datastore')\nconst { encodeBase32, keyToTopic, topicToKey } = require('./utils')\nconst { equals: uint8ArrayEquals } = require('uint8arrays/equals')\n\nconst errcode = require('err-code')\nconst debug = require('debug')\nconst log = Object.assign(debug('datastore-pubsub:publisher'), {\n  error: debug('datastore-pubsub:publisher:error')\n})\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('./types').Validator} Validator\n * @typedef {import('./types').SubscriptionKeyFn} SubscriptionKeyFn\n * @typedef {import('libp2p-interfaces/src/pubsub').InMessage} PubSubMessage\n */\n\n// DatastorePubsub is responsible for providing an api for pubsub to be used as a datastore with\n// [TieredDatastore]{@link https://github.com/ipfs/js-datastore-core/blob/master/src/tiered.js}\nclass DatastorePubsub extends Adapter {\n  /**\n   * Creates an instance of DatastorePubsub.\n   *\n   * @param {import('libp2p-interfaces/src/pubsub')} pubsub - pubsub implementation\n   * @param {import('interface-datastore').Datastore} datastore - datastore instance\n   * @param {PeerId} peerId - peer-id instance\n   * @param {Validator} validator - validator functions\n   * @param {SubscriptionKeyFn} [subscriptionKeyFn] - function to manipulate the key topic received before processing it\n   * @memberof DatastorePubsub\n   */\n  constructor (pubsub, datastore, peerId, validator, subscriptionKeyFn) {\n    super()\n\n    if (!validator) {\n      throw errcode(new TypeError('missing validator'), 'ERR_INVALID_PARAMETERS')\n    }\n\n    if (typeof validator.validate !== 'function') {\n      throw errcode(new TypeError('missing validate function'), 'ERR_INVALID_PARAMETERS')\n    }\n\n    if (typeof validator.select !== 'function') {\n      throw errcode(new TypeError('missing select function'), 'ERR_INVALID_PARAMETERS')\n    }\n\n    if (subscriptionKeyFn && typeof subscriptionKeyFn !== 'function') {\n      throw errcode(new TypeError('invalid subscriptionKeyFn received'), 'ERR_INVALID_PARAMETERS')\n    }\n\n    this._pubsub = pubsub\n    this._datastore = datastore\n    this._peerId = peerId\n    this._validator = validator\n    this._handleSubscriptionKeyFn = subscriptionKeyFn\n\n    // Bind _onMessage function, which is called by pubsub.\n    this._onMessage = this._onMessage.bind(this)\n  }\n\n  /**\n   * Publishes a value through pubsub.\n   *\n   * @param {Uint8Array} key - identifier of the value to be published.\n   * @param {Uint8Array} val - value to be propagated.\n   */\n  // @ts-ignore Datastores take keys as Keys, this one takes Uint8Arrays\n  async put (key, val) {\n    if (!(key instanceof Uint8Array)) {\n      const errMsg = 'datastore key does not have a valid format'\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY')\n    }\n\n    if (!(val instanceof Uint8Array)) {\n      const errMsg = 'received value is not a Uint8Array'\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_INVALID_VALUE_RECEIVED')\n    }\n\n    const stringifiedTopic = keyToTopic(key)\n\n    log(`publish value for topic ${stringifiedTopic}`)\n\n    // Publish record to pubsub\n    await this._pubsub.publish(stringifiedTopic, val)\n  }\n\n  /**\n   * Try to subscribe a topic with Pubsub and returns the local value if available.\n   *\n   * @param {Uint8Array} key - identifier of the value to be subscribed.\n   */\n  // @ts-ignore Datastores take keys as Keys, this one takes Uint8Arrays\n  async get (key) {\n    if (!(key instanceof Uint8Array)) {\n      const errMsg = 'datastore key does not have a valid format'\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY')\n    }\n\n    const stringifiedTopic = keyToTopic(key)\n    const subscriptions = await this._pubsub.getTopics()\n\n    // If already subscribed, just try to get it\n    if (subscriptions && Array.isArray(subscriptions) && subscriptions.indexOf(stringifiedTopic) > -1) {\n      return this._getLocal(key)\n    }\n\n    // subscribe\n    try {\n      this._pubsub.on(stringifiedTopic, this._onMessage)\n      await this._pubsub.subscribe(stringifiedTopic)\n    } catch (err) {\n      const errMsg = `cannot subscribe topic ${stringifiedTopic}`\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_SUBSCRIBING_TOPIC')\n    }\n    log(`subscribed values for key ${stringifiedTopic}`)\n\n    return this._getLocal(key)\n  }\n\n  /**\n   * Unsubscribe topic.\n   *\n   * @param {Uint8Array} key - identifier of the value to unsubscribe.\n   * @returns {void}\n   */\n  unsubscribe (key) {\n    const stringifiedTopic = keyToTopic(key)\n\n    this._pubsub.removeListener(stringifiedTopic, this._onMessage)\n    return this._pubsub.unsubscribe(stringifiedTopic)\n  }\n\n  /**\n   * Get record from local datastore\n   *\n   * @private\n   * @param {Uint8Array} key\n   */\n  async _getLocal (key) {\n    // encode key - base32(/ipns/{cid})\n    const routingKey = new Key('/' + encodeBase32(key), false)\n    let dsVal\n\n    try {\n      dsVal = await this._datastore.get(routingKey)\n    } catch (err) {\n      if (err.code !== 'ERR_NOT_FOUND') {\n        const errMsg = `unexpected error getting the ipns record for ${routingKey.toString()}`\n\n        log.error(errMsg)\n        throw errcode(new Error(errMsg), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD')\n      }\n      const errMsg = `local record requested was not found for ${routingKey.toString()}`\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_NOT_FOUND')\n    }\n\n    if (!(dsVal instanceof Uint8Array)) {\n      const errMsg = 'found record that we couldn\\'t convert to a value'\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_INVALID_RECORD_RECEIVED')\n    }\n\n    return dsVal\n  }\n\n  /**\n   * handles pubsub subscription messages\n   *\n   * @param {PubSubMessage} msg\n   */\n  async _onMessage (msg) {\n    const { data, from, topicIDs } = msg\n    let key\n    try {\n      key = topicToKey(topicIDs[0])\n    } catch (err) {\n      log.error(err)\n      return\n    }\n\n    log(`message received for topic ${topicIDs[0]}`)\n\n    // Stop if the message is from the peer (it already stored it while publishing to pubsub)\n    if (from === this._peerId.toB58String()) {\n      log('message discarded as it is from the same peer')\n      return\n    }\n\n    if (this._handleSubscriptionKeyFn) {\n      let res\n\n      try {\n        res = await this._handleSubscriptionKeyFn(key)\n      } catch (err) {\n        log.error('message discarded by the subscriptionKeyFn')\n        return\n      }\n\n      key = res\n    }\n\n    try {\n      await this._storeIfSubscriptionIsBetter(key, data)\n    } catch (err) {\n      log.error(err)\n    }\n  }\n\n  /**\n   * Store the received record if it is better than the current stored\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} data\n   */\n  async _storeIfSubscriptionIsBetter (key, data) {\n    let isBetter = false\n\n    try {\n      isBetter = await this._isBetter(key, data)\n    } catch (err) {\n      if (err.code !== 'ERR_NOT_VALID_RECORD') {\n        throw err\n      }\n    }\n\n    if (isBetter) {\n      await this._storeRecord(key, data)\n    }\n  }\n\n  /**\n   * Validate record according to the received validation function\n   *\n   * @param {Uint8Array} value\n   * @param {Uint8Array} peerId\n   */\n  async _validateRecord (value, peerId) { // eslint-disable-line require-await\n    return this._validator.validate(value, peerId)\n  }\n\n  /**\n   * Select the best record according to the received select function\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array[]} records\n   */\n  async _selectRecord (key, records) {\n    const res = await this._validator.select(key, records)\n\n    // If the selected was the first (0), it should be stored (true)\n    return res === 0\n  }\n\n  /**\n   * Verify if the record received through pubsub is valid and better than the one currently stored\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} val\n   */\n  async _isBetter (key, val) {\n    try {\n      await this._validateRecord(val, key)\n    } catch (err) {\n      // If not valid, it is not better than the one currently available\n      const errMsg = 'record received through pubsub is not valid'\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_NOT_VALID_RECORD')\n    }\n\n    // Get Local record\n    const dsKey = new Key(key)\n    let currentRecord\n\n    try {\n      currentRecord = await this._getLocal(dsKey.uint8Array())\n    } catch (err) {\n      // if the old one is invalid, the new one is *always* better\n      return true\n    }\n\n    // if the same record, do not need to store\n    if (uint8ArrayEquals(currentRecord, val)) {\n      return false\n    }\n\n    // verify if the received record should replace the current one\n    return this._selectRecord(key, [currentRecord, val])\n  }\n\n  /**\n   * add record to datastore\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} data\n   */\n  async _storeRecord (key, data) {\n    // encode key - base32(/ipns/{cid})\n    const routingKey = new Key('/' + encodeBase32(key), false)\n\n    await this._datastore.put(routingKey, data)\n    log(`record for ${keyToTopic(key)} was stored in the datastore`)\n  }\n}\n\nexports = module.exports = DatastorePubsub\n"]},"metadata":{},"sourceType":"script"}