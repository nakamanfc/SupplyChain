{"ast":null,"code":"'use strict';\n\nconst {\n  Multiaddr\n} = require('multiaddr');\n\nconst {\n  CircuitRelay\n} = require('../protocol');\n/**\n * @typedef {import('./stream-handler')} StreamHandler\n * @typedef {import('../protocol').ICircuitRelay} ICircuitRelay\n */\n\n/**\n * Write a response\n *\n * @param {StreamHandler} streamHandler\n * @param {import('../protocol').CircuitRelay.Status} status\n */\n\n\nfunction writeResponse(streamHandler, status) {\n  streamHandler.write({\n    type: CircuitRelay.Type.STATUS,\n    code: status\n  });\n}\n/**\n * Validate incomming HOP/STOP message\n *\n * @param {ICircuitRelay} msg - A CircuitRelay unencoded protobuf message\n * @param {StreamHandler} streamHandler\n */\n\n\nfunction validateAddrs(msg, streamHandler) {\n  try {\n    if (msg.dstPeer && msg.dstPeer.addrs) {\n      msg.dstPeer.addrs.forEach(addr => {\n        return new Multiaddr(addr);\n      });\n    }\n  } catch (err) {\n    writeResponse(streamHandler, msg.type === CircuitRelay.Type.HOP ? CircuitRelay.Status.HOP_DST_MULTIADDR_INVALID : CircuitRelay.Status.STOP_DST_MULTIADDR_INVALID);\n    throw err;\n  }\n\n  try {\n    if (msg.srcPeer && msg.srcPeer.addrs) {\n      msg.srcPeer.addrs.forEach(addr => {\n        return new Multiaddr(addr);\n      });\n    }\n  } catch (err) {\n    writeResponse(streamHandler, msg.type === CircuitRelay.Type.HOP ? CircuitRelay.Status.HOP_SRC_MULTIADDR_INVALID : CircuitRelay.Status.STOP_SRC_MULTIADDR_INVALID);\n    throw err;\n  }\n}\n\nmodule.exports = {\n  validateAddrs\n};","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/libp2p/src/circuit/circuit/utils.js"],"names":["Multiaddr","require","CircuitRelay","writeResponse","streamHandler","status","write","type","Type","STATUS","code","validateAddrs","msg","dstPeer","addrs","forEach","addr","err","HOP","Status","HOP_DST_MULTIADDR_INVALID","STOP_DST_MULTIADDR_INVALID","srcPeer","HOP_SRC_MULTIADDR_INVALID","STOP_SRC_MULTIADDR_INVALID","module","exports"],"mappings":"AAAA;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAgBC,OAAO,CAAC,WAAD,CAA7B;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAmBD,OAAO,CAAC,aAAD,CAAhC;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASE,aAAT,CAAwBC,aAAxB,EAAuCC,MAAvC,EAA+C;AAC7CD,EAAAA,aAAa,CAACE,KAAd,CAAoB;AAClBC,IAAAA,IAAI,EAAEL,YAAY,CAACM,IAAb,CAAkBC,MADN;AAElBC,IAAAA,IAAI,EAAEL;AAFY,GAApB;AAID;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASM,aAAT,CAAwBC,GAAxB,EAA6BR,aAA7B,EAA4C;AAC1C,MAAI;AACF,QAAIQ,GAAG,CAACC,OAAJ,IAAeD,GAAG,CAACC,OAAJ,CAAYC,KAA/B,EAAsC;AACpCF,MAAAA,GAAG,CAACC,OAAJ,CAAYC,KAAZ,CAAkBC,OAAlB,CAA2BC,IAAD,IAAU;AAClC,eAAO,IAAIhB,SAAJ,CAAcgB,IAAd,CAAP;AACD,OAFD;AAGD;AACF,GAND,CAME,OAAOC,GAAP,EAAY;AACZd,IAAAA,aAAa,CAACC,aAAD,EAAgBQ,GAAG,CAACL,IAAJ,KAAaL,YAAY,CAACM,IAAb,CAAkBU,GAA/B,GACzBhB,YAAY,CAACiB,MAAb,CAAoBC,yBADK,GAEzBlB,YAAY,CAACiB,MAAb,CAAoBE,0BAFX,CAAb;AAGA,UAAMJ,GAAN;AACD;;AAED,MAAI;AACF,QAAIL,GAAG,CAACU,OAAJ,IAAeV,GAAG,CAACU,OAAJ,CAAYR,KAA/B,EAAsC;AACpCF,MAAAA,GAAG,CAACU,OAAJ,CAAYR,KAAZ,CAAkBC,OAAlB,CAA2BC,IAAD,IAAU;AAClC,eAAO,IAAIhB,SAAJ,CAAcgB,IAAd,CAAP;AACD,OAFD;AAGD;AACF,GAND,CAME,OAAOC,GAAP,EAAY;AACZd,IAAAA,aAAa,CAACC,aAAD,EAAgBQ,GAAG,CAACL,IAAJ,KAAaL,YAAY,CAACM,IAAb,CAAkBU,GAA/B,GACzBhB,YAAY,CAACiB,MAAb,CAAoBI,yBADK,GAEzBrB,YAAY,CAACiB,MAAb,CAAoBK,0BAFX,CAAb;AAGA,UAAMP,GAAN;AACD;AACF;;AAEDQ,MAAM,CAACC,OAAP,GAAiB;AACff,EAAAA;AADe,CAAjB","sourcesContent":["'use strict'\n\nconst { Multiaddr } = require('multiaddr')\nconst { CircuitRelay } = require('../protocol')\n\n/**\n * @typedef {import('./stream-handler')} StreamHandler\n * @typedef {import('../protocol').ICircuitRelay} ICircuitRelay\n */\n\n/**\n * Write a response\n *\n * @param {StreamHandler} streamHandler\n * @param {import('../protocol').CircuitRelay.Status} status\n */\nfunction writeResponse (streamHandler, status) {\n  streamHandler.write({\n    type: CircuitRelay.Type.STATUS,\n    code: status\n  })\n}\n\n/**\n * Validate incomming HOP/STOP message\n *\n * @param {ICircuitRelay} msg - A CircuitRelay unencoded protobuf message\n * @param {StreamHandler} streamHandler\n */\nfunction validateAddrs (msg, streamHandler) {\n  try {\n    if (msg.dstPeer && msg.dstPeer.addrs) {\n      msg.dstPeer.addrs.forEach((addr) => {\n        return new Multiaddr(addr)\n      })\n    }\n  } catch (err) {\n    writeResponse(streamHandler, msg.type === CircuitRelay.Type.HOP\n      ? CircuitRelay.Status.HOP_DST_MULTIADDR_INVALID\n      : CircuitRelay.Status.STOP_DST_MULTIADDR_INVALID)\n    throw err\n  }\n\n  try {\n    if (msg.srcPeer && msg.srcPeer.addrs) {\n      msg.srcPeer.addrs.forEach((addr) => {\n        return new Multiaddr(addr)\n      })\n    }\n  } catch (err) {\n    writeResponse(streamHandler, msg.type === CircuitRelay.Type.HOP\n      ? CircuitRelay.Status.HOP_SRC_MULTIADDR_INVALID\n      : CircuitRelay.Status.STOP_SRC_MULTIADDR_INVALID)\n    throw err\n  }\n}\n\nmodule.exports = {\n  validateAddrs\n}\n"]},"metadata":{},"sourceType":"script"}