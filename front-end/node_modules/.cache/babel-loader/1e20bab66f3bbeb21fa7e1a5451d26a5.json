{"ast":null,"code":"'use strict';\n\nvar dirFlat = require('./dir-flat.js');\n\nvar flatToShard = require('./flat-to-shard.js');\n\nvar dir = require('./dir.js');\n\nvar toPathComponents = require('./utils/to-path-components.js');\n\nasync function addToTree(elem, tree, options) {\n  const pathElems = toPathComponents(elem.path || '');\n  const lastIndex = pathElems.length - 1;\n  let parent = tree;\n  let currentPath = '';\n\n  for (let i = 0; i < pathElems.length; i++) {\n    const pathElem = pathElems[i];\n    currentPath += `${currentPath ? '/' : ''}${pathElem}`;\n    const last = i === lastIndex;\n    parent.dirty = true;\n    parent.cid = undefined;\n    parent.size = undefined;\n\n    if (last) {\n      await parent.put(pathElem, elem);\n      tree = await flatToShard(null, parent, options.shardSplitThreshold, options);\n    } else {\n      let dir$1 = await parent.get(pathElem);\n\n      if (!dir$1 || !(dir$1 instanceof dir)) {\n        dir$1 = new dirFlat({\n          root: false,\n          dir: true,\n          parent: parent,\n          parentKey: pathElem,\n          path: currentPath,\n          dirty: true,\n          flat: true,\n          mtime: dir$1 && dir$1.unixfs && dir$1.unixfs.mtime,\n          mode: dir$1 && dir$1.unixfs && dir$1.unixfs.mode\n        }, options);\n      }\n\n      await parent.put(pathElem, dir$1);\n      parent = dir$1;\n    }\n  }\n\n  return tree;\n}\n\nasync function* flushAndYield(tree, blockstore) {\n  if (!(tree instanceof dir)) {\n    if (tree && tree.unixfs && tree.unixfs.isDirectory()) {\n      yield tree;\n    }\n\n    return;\n  }\n\n  yield* tree.flush(blockstore);\n}\n\nasync function* treeBuilder(source, block, options) {\n  let tree = new dirFlat({\n    root: true,\n    dir: true,\n    path: '',\n    dirty: true,\n    flat: true\n  }, options);\n\n  for await (const entry of source) {\n    if (!entry) {\n      continue;\n    }\n\n    tree = await addToTree(entry, tree, options);\n\n    if (!entry.unixfs || !entry.unixfs.isDirectory()) {\n      yield entry;\n    }\n  }\n\n  if (options.wrapWithDirectory) {\n    yield* flushAndYield(tree, block);\n  } else {\n    for await (const unwrapped of tree.eachChildSeries()) {\n      if (!unwrapped) {\n        continue;\n      }\n\n      yield* flushAndYield(unwrapped.child, block);\n    }\n  }\n}\n\nmodule.exports = treeBuilder;","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/ipfs-unixfs-importer/cjs/src/tree-builder.js"],"names":["dirFlat","require","flatToShard","dir","toPathComponents","addToTree","elem","tree","options","pathElems","path","lastIndex","length","parent","currentPath","i","pathElem","last","dirty","cid","undefined","size","put","shardSplitThreshold","dir$1","get","root","parentKey","flat","mtime","unixfs","mode","flushAndYield","blockstore","isDirectory","flush","treeBuilder","source","block","entry","wrapWithDirectory","unwrapped","eachChildSeries","child","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar dirFlat = require('./dir-flat.js');\nvar flatToShard = require('./flat-to-shard.js');\nvar dir = require('./dir.js');\nvar toPathComponents = require('./utils/to-path-components.js');\n\nasync function addToTree(elem, tree, options) {\n  const pathElems = toPathComponents(elem.path || '');\n  const lastIndex = pathElems.length - 1;\n  let parent = tree;\n  let currentPath = '';\n  for (let i = 0; i < pathElems.length; i++) {\n    const pathElem = pathElems[i];\n    currentPath += `${ currentPath ? '/' : '' }${ pathElem }`;\n    const last = i === lastIndex;\n    parent.dirty = true;\n    parent.cid = undefined;\n    parent.size = undefined;\n    if (last) {\n      await parent.put(pathElem, elem);\n      tree = await flatToShard(null, parent, options.shardSplitThreshold, options);\n    } else {\n      let dir$1 = await parent.get(pathElem);\n      if (!dir$1 || !(dir$1 instanceof dir)) {\n        dir$1 = new dirFlat({\n          root: false,\n          dir: true,\n          parent: parent,\n          parentKey: pathElem,\n          path: currentPath,\n          dirty: true,\n          flat: true,\n          mtime: dir$1 && dir$1.unixfs && dir$1.unixfs.mtime,\n          mode: dir$1 && dir$1.unixfs && dir$1.unixfs.mode\n        }, options);\n      }\n      await parent.put(pathElem, dir$1);\n      parent = dir$1;\n    }\n  }\n  return tree;\n}\nasync function* flushAndYield(tree, blockstore) {\n  if (!(tree instanceof dir)) {\n    if (tree && tree.unixfs && tree.unixfs.isDirectory()) {\n      yield tree;\n    }\n    return;\n  }\n  yield* tree.flush(blockstore);\n}\nasync function* treeBuilder(source, block, options) {\n  let tree = new dirFlat({\n    root: true,\n    dir: true,\n    path: '',\n    dirty: true,\n    flat: true\n  }, options);\n  for await (const entry of source) {\n    if (!entry) {\n      continue;\n    }\n    tree = await addToTree(entry, tree, options);\n    if (!entry.unixfs || !entry.unixfs.isDirectory()) {\n      yield entry;\n    }\n  }\n  if (options.wrapWithDirectory) {\n    yield* flushAndYield(tree, block);\n  } else {\n    for await (const unwrapped of tree.eachChildSeries()) {\n      if (!unwrapped) {\n        continue;\n      }\n      yield* flushAndYield(unwrapped.child, block);\n    }\n  }\n}\n\nmodule.exports = treeBuilder;\n"]},"metadata":{},"sourceType":"script"}