{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Noise = void 0;\n\nconst x25519 = __importStar(require(\"@stablelib/x25519\"));\n\nconst buffer_1 = require(\"buffer\");\n\nconst it_pb_rpc_1 = __importDefault(require(\"it-pb-rpc\"));\n\nconst duplex_1 = __importDefault(require(\"it-pair/duplex\"));\n\nconst it_buffer_1 = __importDefault(require(\"it-buffer\"));\n\nconst it_pipe_1 = __importDefault(require(\"it-pipe\"));\n\nconst it_length_prefixed_1 = require(\"it-length-prefixed\");\n\nconst handshake_xx_1 = require(\"./handshake-xx\");\n\nconst handshake_ik_1 = require(\"./handshake-ik\");\n\nconst handshake_xx_fallback_1 = require(\"./handshake-xx-fallback\");\n\nconst utils_1 = require(\"./utils\");\n\nconst encoder_1 = require(\"./encoder\");\n\nconst crypto_1 = require(\"./crypto\");\n\nconst keycache_1 = require(\"./keycache\");\n\nconst logger_1 = require(\"./logger\");\n\nconst constants_1 = require(\"./constants\");\n\nclass Noise {\n  /**\n   *\n   * @param {bytes} staticNoiseKey - x25519 private key, reuse for faster handshakes\n   * @param {bytes} earlyData\n   */\n  constructor(staticNoiseKey, earlyData) {\n    this.protocol = '/noise';\n    this.prologue = buffer_1.Buffer.alloc(0);\n    this.earlyData = earlyData !== null && earlyData !== void 0 ? earlyData : buffer_1.Buffer.alloc(0); // disabled until properly specked\n\n    this.useNoisePipes = false;\n\n    if (staticNoiseKey) {\n      // accepts x25519 private key of length 32\n      const keyPair = x25519.generateKeyPairFromSeed(staticNoiseKey);\n      this.staticKeys = {\n        privateKey: buffer_1.Buffer.from(keyPair.secretKey.buffer, keyPair.secretKey.byteOffset, keyPair.secretKey.length),\n        publicKey: buffer_1.Buffer.from(keyPair.publicKey.buffer, keyPair.publicKey.byteOffset, keyPair.publicKey.length)\n      };\n    } else {\n      this.staticKeys = utils_1.generateKeypair();\n    }\n  }\n  /**\n   * Encrypt outgoing data to the remote party (handshake as initiator)\n   *\n   * @param {PeerId} localPeer - PeerId of the receiving peer\n   * @param {any} connection - streaming iterable duplex that will be encrypted\n   * @param {PeerId} remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer.\n   * @returns {Promise<SecureOutbound>}\n   */\n\n\n  async secureOutbound(localPeer, connection, remotePeer) {\n    const wrappedConnection = it_pb_rpc_1.default(connection, {\n      lengthEncoder: encoder_1.uint16BEEncode,\n      lengthDecoder: encoder_1.uint16BEDecode,\n      maxDataLength: constants_1.NOISE_MSG_MAX_LENGTH_BYTES\n    });\n    const handshake = await this.performHandshake({\n      connection: wrappedConnection,\n      isInitiator: true,\n      localPeer,\n      remotePeer\n    });\n    const conn = await this.createSecureConnection(wrappedConnection, handshake);\n    return {\n      conn,\n      remoteEarlyData: handshake.remoteEarlyData,\n      remotePeer: handshake.remotePeer\n    };\n  }\n  /**\n   * Decrypt incoming data (handshake as responder).\n   *\n   * @param {PeerId} localPeer - PeerId of the receiving peer.\n   * @param {any} connection - streaming iterable duplex that will be encryption.\n   * @param {PeerId} remotePeer - optional PeerId of the initiating peer, if known. This may only exist during transport upgrades.\n   * @returns {Promise<SecureOutbound>}\n   */\n\n\n  async secureInbound(localPeer, connection, remotePeer) {\n    const wrappedConnection = it_pb_rpc_1.default(connection, {\n      lengthEncoder: encoder_1.uint16BEEncode,\n      lengthDecoder: encoder_1.uint16BEDecode,\n      maxDataLength: constants_1.NOISE_MSG_MAX_LENGTH_BYTES\n    });\n    const handshake = await this.performHandshake({\n      connection: wrappedConnection,\n      isInitiator: false,\n      localPeer,\n      remotePeer\n    });\n    const conn = await this.createSecureConnection(wrappedConnection, handshake);\n    return {\n      conn,\n      remoteEarlyData: handshake.remoteEarlyData,\n      remotePeer: handshake.remotePeer\n    };\n  }\n  /**\n   * If Noise pipes supported, tries IK handshake first with XX as fallback if it fails.\n   * If noise pipes disabled or remote peer static key is unknown, use XX.\n   *\n   * @param {HandshakeParams} params\n   */\n\n\n  async performHandshake(params) {\n    var _a;\n\n    const payload = await utils_1.getPayload(params.localPeer, this.staticKeys.publicKey, this.earlyData);\n    let tryIK = this.useNoisePipes;\n\n    if (params.isInitiator && keycache_1.KeyCache.load(params.remotePeer) === null) {\n      // if we are initiator and remote static key is unknown, don't try IK\n      tryIK = false;\n    } // Try IK if acting as responder or initiator that has remote's static key.\n\n\n    if (tryIK) {\n      // Try IK first\n      const {\n        remotePeer,\n        connection,\n        isInitiator\n      } = params;\n      const ikHandshake = new handshake_ik_1.IKHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, // safe to cast as we did checks\n      (_a = keycache_1.KeyCache.load(params.remotePeer)) !== null && _a !== void 0 ? _a : buffer_1.Buffer.alloc(32), remotePeer);\n\n      try {\n        return await this.performIKHandshake(ikHandshake);\n      } catch (e) {\n        // IK failed, go to XX fallback\n        let ephemeralKeys;\n\n        if (params.isInitiator) {\n          ephemeralKeys = ikHandshake.getLocalEphemeralKeys();\n        }\n\n        return await this.performXXFallbackHandshake(params, payload, e.initialMsg, ephemeralKeys);\n      }\n    } else {\n      // run XX handshake\n      return await this.performXXHandshake(params, payload);\n    }\n  }\n\n  async performXXFallbackHandshake(params, payload, initialMsg, ephemeralKeys) {\n    const {\n      isInitiator,\n      remotePeer,\n      connection\n    } = params;\n    const handshake = new handshake_xx_fallback_1.XXFallbackHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, initialMsg, remotePeer, ephemeralKeys);\n\n    try {\n      await handshake.propose();\n      await handshake.exchange();\n      await handshake.finish();\n    } catch (e) {\n      logger_1.logger(e);\n      const err = e;\n      throw new Error(`Error occurred during XX Fallback handshake: ${err.message}`);\n    }\n\n    return handshake;\n  }\n\n  async performXXHandshake(params, payload) {\n    const {\n      isInitiator,\n      remotePeer,\n      connection\n    } = params;\n    const handshake = new handshake_xx_1.XXHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, remotePeer);\n\n    try {\n      await handshake.propose();\n      await handshake.exchange();\n      await handshake.finish();\n\n      if (this.useNoisePipes && handshake.remotePeer) {\n        keycache_1.KeyCache.store(handshake.remotePeer, handshake.getRemoteStaticKey());\n      }\n    } catch (e) {\n      const err = e;\n      throw new Error(`Error occurred during XX handshake: ${err.message}`);\n    }\n\n    return handshake;\n  }\n\n  async performIKHandshake(handshake) {\n    await handshake.stage0();\n    await handshake.stage1();\n    return handshake;\n  }\n\n  async createSecureConnection(connection, handshake) {\n    // Create encryption box/unbox wrapper\n    const [secure, user] = duplex_1.default();\n    const network = connection.unwrap();\n    await it_pipe_1.default(secure, // write to wrapper\n    it_buffer_1.default, // ensure any type of data is converted to buffer\n    crypto_1.encryptStream(handshake), // data is encrypted\n    it_length_prefixed_1.encode({\n      lengthEncoder: encoder_1.uint16BEEncode\n    }), // prefix with message length\n    network, // send to the remote peer\n    it_length_prefixed_1.decode({\n      lengthDecoder: encoder_1.uint16BEDecode\n    }), // read message length prefix\n    it_buffer_1.default, // ensure any type of data is converted to buffer\n    crypto_1.decryptStream(handshake), // decrypt the incoming data\n    secure // pipe to the wrapper\n    );\n    return user;\n  }\n\n}\n\nexports.Noise = Noise;","map":{"version":3,"sources":["../../src/noise.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Noise = void 0;\nconst x25519 = __importStar(require(\"@stablelib/x25519\"));\nconst buffer_1 = require(\"buffer\");\nconst it_pb_rpc_1 = __importDefault(require(\"it-pb-rpc\"));\nconst duplex_1 = __importDefault(require(\"it-pair/duplex\"));\nconst it_buffer_1 = __importDefault(require(\"it-buffer\"));\nconst it_pipe_1 = __importDefault(require(\"it-pipe\"));\nconst it_length_prefixed_1 = require(\"it-length-prefixed\");\nconst handshake_xx_1 = require(\"./handshake-xx\");\nconst handshake_ik_1 = require(\"./handshake-ik\");\nconst handshake_xx_fallback_1 = require(\"./handshake-xx-fallback\");\nconst utils_1 = require(\"./utils\");\nconst encoder_1 = require(\"./encoder\");\nconst crypto_1 = require(\"./crypto\");\nconst keycache_1 = require(\"./keycache\");\nconst logger_1 = require(\"./logger\");\nconst constants_1 = require(\"./constants\");\nclass Noise {\n    /**\n     *\n     * @param {bytes} staticNoiseKey - x25519 private key, reuse for faster handshakes\n     * @param {bytes} earlyData\n     */\n    constructor(staticNoiseKey, earlyData) {\n        this.protocol = '/noise';\n        this.prologue = buffer_1.Buffer.alloc(0);\n        this.earlyData = earlyData !== null && earlyData !== void 0 ? earlyData : buffer_1.Buffer.alloc(0);\n        // disabled until properly specked\n        this.useNoisePipes = false;\n        if (staticNoiseKey) {\n            // accepts x25519 private key of length 32\n            const keyPair = x25519.generateKeyPairFromSeed(staticNoiseKey);\n            this.staticKeys = {\n                privateKey: buffer_1.Buffer.from(keyPair.secretKey.buffer, keyPair.secretKey.byteOffset, keyPair.secretKey.length),\n                publicKey: buffer_1.Buffer.from(keyPair.publicKey.buffer, keyPair.publicKey.byteOffset, keyPair.publicKey.length)\n            };\n        }\n        else {\n            this.staticKeys = utils_1.generateKeypair();\n        }\n    }\n    /**\n     * Encrypt outgoing data to the remote party (handshake as initiator)\n     *\n     * @param {PeerId} localPeer - PeerId of the receiving peer\n     * @param {any} connection - streaming iterable duplex that will be encrypted\n     * @param {PeerId} remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer.\n     * @returns {Promise<SecureOutbound>}\n     */\n    async secureOutbound(localPeer, connection, remotePeer) {\n        const wrappedConnection = it_pb_rpc_1.default(connection, {\n            lengthEncoder: encoder_1.uint16BEEncode,\n            lengthDecoder: encoder_1.uint16BEDecode,\n            maxDataLength: constants_1.NOISE_MSG_MAX_LENGTH_BYTES\n        });\n        const handshake = await this.performHandshake({\n            connection: wrappedConnection,\n            isInitiator: true,\n            localPeer,\n            remotePeer\n        });\n        const conn = await this.createSecureConnection(wrappedConnection, handshake);\n        return {\n            conn,\n            remoteEarlyData: handshake.remoteEarlyData,\n            remotePeer: handshake.remotePeer\n        };\n    }\n    /**\n     * Decrypt incoming data (handshake as responder).\n     *\n     * @param {PeerId} localPeer - PeerId of the receiving peer.\n     * @param {any} connection - streaming iterable duplex that will be encryption.\n     * @param {PeerId} remotePeer - optional PeerId of the initiating peer, if known. This may only exist during transport upgrades.\n     * @returns {Promise<SecureOutbound>}\n     */\n    async secureInbound(localPeer, connection, remotePeer) {\n        const wrappedConnection = it_pb_rpc_1.default(connection, {\n            lengthEncoder: encoder_1.uint16BEEncode,\n            lengthDecoder: encoder_1.uint16BEDecode,\n            maxDataLength: constants_1.NOISE_MSG_MAX_LENGTH_BYTES\n        });\n        const handshake = await this.performHandshake({\n            connection: wrappedConnection,\n            isInitiator: false,\n            localPeer,\n            remotePeer\n        });\n        const conn = await this.createSecureConnection(wrappedConnection, handshake);\n        return {\n            conn,\n            remoteEarlyData: handshake.remoteEarlyData,\n            remotePeer: handshake.remotePeer\n        };\n    }\n    /**\n     * If Noise pipes supported, tries IK handshake first with XX as fallback if it fails.\n     * If noise pipes disabled or remote peer static key is unknown, use XX.\n     *\n     * @param {HandshakeParams} params\n     */\n    async performHandshake(params) {\n        var _a;\n        const payload = await utils_1.getPayload(params.localPeer, this.staticKeys.publicKey, this.earlyData);\n        let tryIK = this.useNoisePipes;\n        if (params.isInitiator && keycache_1.KeyCache.load(params.remotePeer) === null) {\n            // if we are initiator and remote static key is unknown, don't try IK\n            tryIK = false;\n        }\n        // Try IK if acting as responder or initiator that has remote's static key.\n        if (tryIK) {\n            // Try IK first\n            const { remotePeer, connection, isInitiator } = params;\n            const ikHandshake = new handshake_ik_1.IKHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, \n            // safe to cast as we did checks\n            (_a = keycache_1.KeyCache.load(params.remotePeer)) !== null && _a !== void 0 ? _a : buffer_1.Buffer.alloc(32), remotePeer);\n            try {\n                return await this.performIKHandshake(ikHandshake);\n            }\n            catch (e) {\n                // IK failed, go to XX fallback\n                let ephemeralKeys;\n                if (params.isInitiator) {\n                    ephemeralKeys = ikHandshake.getLocalEphemeralKeys();\n                }\n                return await this.performXXFallbackHandshake(params, payload, e.initialMsg, ephemeralKeys);\n            }\n        }\n        else {\n            // run XX handshake\n            return await this.performXXHandshake(params, payload);\n        }\n    }\n    async performXXFallbackHandshake(params, payload, initialMsg, ephemeralKeys) {\n        const { isInitiator, remotePeer, connection } = params;\n        const handshake = new handshake_xx_fallback_1.XXFallbackHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, initialMsg, remotePeer, ephemeralKeys);\n        try {\n            await handshake.propose();\n            await handshake.exchange();\n            await handshake.finish();\n        }\n        catch (e) {\n            logger_1.logger(e);\n            const err = e;\n            throw new Error(`Error occurred during XX Fallback handshake: ${err.message}`);\n        }\n        return handshake;\n    }\n    async performXXHandshake(params, payload) {\n        const { isInitiator, remotePeer, connection } = params;\n        const handshake = new handshake_xx_1.XXHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, remotePeer);\n        try {\n            await handshake.propose();\n            await handshake.exchange();\n            await handshake.finish();\n            if (this.useNoisePipes && handshake.remotePeer) {\n                keycache_1.KeyCache.store(handshake.remotePeer, handshake.getRemoteStaticKey());\n            }\n        }\n        catch (e) {\n            const err = e;\n            throw new Error(`Error occurred during XX handshake: ${err.message}`);\n        }\n        return handshake;\n    }\n    async performIKHandshake(handshake) {\n        await handshake.stage0();\n        await handshake.stage1();\n        return handshake;\n    }\n    async createSecureConnection(connection, handshake) {\n        // Create encryption box/unbox wrapper\n        const [secure, user] = duplex_1.default();\n        const network = connection.unwrap();\n        await it_pipe_1.default(secure, // write to wrapper\n        it_buffer_1.default, // ensure any type of data is converted to buffer\n        crypto_1.encryptStream(handshake), // data is encrypted\n        it_length_prefixed_1.encode({ lengthEncoder: encoder_1.uint16BEEncode }), // prefix with message length\n        network, // send to the remote peer\n        it_length_prefixed_1.decode({ lengthDecoder: encoder_1.uint16BEDecode }), // read message length prefix\n        it_buffer_1.default, // ensure any type of data is converted to buffer\n        crypto_1.decryptStream(handshake), // decrypt the incoming data\n        secure // pipe to the wrapper\n        );\n        return user;\n    }\n}\nexports.Noise = Noise;\n//# sourceMappingURL=noise.js.map"]},"metadata":{},"sourceType":"script"}