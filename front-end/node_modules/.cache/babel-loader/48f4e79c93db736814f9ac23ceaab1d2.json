{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PeerScore = void 0;\n\nconst peer_score_params_1 = require(\"./peer-score-params\");\n\nconst peer_stats_1 = require(\"./peer-stats\");\n\nconst compute_score_1 = require(\"./compute-score\");\n\nconst message_deliveries_1 = require(\"./message-deliveries\");\n\nconst constants_1 = require(\"../constants\");\n\nconst peer_id_1 = __importDefault(require(\"peer-id\"));\n\nconst debug = require(\"debug\");\n\nconst pubsubErrors = require(\"libp2p-interfaces/src/pubsub/errors\");\n\nconst {\n  ERR_INVALID_SIGNATURE,\n  ERR_MISSING_SIGNATURE\n} = pubsubErrors.codes;\nconst log = debug('libp2p:gossipsub:score');\n\nclass PeerScore {\n  constructor(params, connectionManager, msgId) {\n    peer_score_params_1.validatePeerScoreParams(params);\n    this.params = params;\n    this._connectionManager = connectionManager;\n    this.peerStats = new Map();\n    this.peerIPs = new Map();\n    this.deliveryRecords = new message_deliveries_1.MessageDeliveries();\n    this.msgId = msgId;\n  }\n  /**\n   * Start PeerScore instance\n   * @returns {void}\n   */\n\n\n  start() {\n    if (this._backgroundInterval) {\n      log('Peer score already running');\n      return;\n    }\n\n    this._backgroundInterval = setInterval(() => this.background(), this.params.decayInterval);\n    log('started');\n  }\n  /**\n   * Stop PeerScore instance\n   * @returns {void}\n   */\n\n\n  stop() {\n    if (!this._backgroundInterval) {\n      log('Peer score already stopped');\n      return;\n    }\n\n    clearInterval(this._backgroundInterval);\n    delete this._backgroundInterval;\n    this.peerIPs.clear();\n    this.peerStats.clear();\n    this.deliveryRecords.clear();\n    log('stopped');\n  }\n  /**\n   * Periodic maintenance\n   * @returns {void}\n   */\n\n\n  background() {\n    this._refreshScores();\n\n    this._updateIPs();\n\n    this.deliveryRecords.gc();\n  }\n  /**\n   * Decays scores, and purges score records for disconnected peers once their expiry has elapsed.\n   * @returns {void}\n   */\n\n\n  _refreshScores() {\n    const now = Date.now();\n    const decayToZero = this.params.decayToZero;\n    this.peerStats.forEach((pstats, id) => {\n      if (!pstats.connected) {\n        // has the retention perious expired?\n        if (now > pstats.expire) {\n          // yes, throw it away (but clean up the IP tracking first)\n          this._removeIPs(id, pstats.ips);\n\n          this.peerStats.delete(id);\n        } // we don't decay retained scores, as the peer is not active.\n        // this way the peer cannot reset a negative score by simply disconnecting and reconnecting,\n        // unless the retention period has ellapsed.\n        // similarly, a well behaved peer does not lose its score by getting disconnected.\n\n\n        return;\n      }\n\n      Object.entries(pstats.topics).forEach(([topic, tstats]) => {\n        const tparams = this.params.topics[topic];\n\n        if (!tparams) {\n          // we are not scoring this topic\n          // should be unreachable, we only add scored topics to pstats\n          return;\n        } // decay counters\n\n\n        tstats.firstMessageDeliveries *= tparams.firstMessageDeliveriesDecay;\n\n        if (tstats.firstMessageDeliveries < decayToZero) {\n          tstats.firstMessageDeliveries = 0;\n        }\n\n        tstats.meshMessageDeliveries *= tparams.meshMessageDeliveriesDecay;\n\n        if (tstats.meshMessageDeliveries < decayToZero) {\n          tstats.meshMessageDeliveries = 0;\n        }\n\n        tstats.meshFailurePenalty *= tparams.meshFailurePenaltyDecay;\n\n        if (tstats.meshFailurePenalty < decayToZero) {\n          tstats.meshFailurePenalty = 0;\n        }\n\n        tstats.invalidMessageDeliveries *= tparams.invalidMessageDeliveriesDecay;\n\n        if (tstats.invalidMessageDeliveries < decayToZero) {\n          tstats.invalidMessageDeliveries = 0;\n        } // update mesh time and activate mesh message delivery parameter if need be\n\n\n        if (tstats.inMesh) {\n          tstats.meshTime = now - tstats.graftTime;\n\n          if (tstats.meshTime > tparams.meshMessageDeliveriesActivation) {\n            tstats.meshMessageDeliveriesActive = true;\n          }\n        }\n      }); // decay P7 counter\n\n      pstats.behaviourPenalty *= this.params.behaviourPenaltyDecay;\n\n      if (pstats.behaviourPenalty < decayToZero) {\n        pstats.behaviourPenalty = 0;\n      }\n    });\n  }\n  /**\n   * Return the score for a peer\n   * @param {string} id\n   * @returns {Number}\n   */\n\n\n  score(id) {\n    const pstats = this.peerStats.get(id);\n\n    if (!pstats) {\n      return 0;\n    }\n\n    return compute_score_1.computeScore(id, pstats, this.params, this.peerIPs);\n  }\n  /**\n   * Apply a behavioural penalty to a peer\n   * @param {string} id\n   * @param {Number} penalty\n   * @returns {void}\n   */\n\n\n  addPenalty(id, penalty) {\n    const pstats = this.peerStats.get(id);\n\n    if (!pstats) {\n      return;\n    }\n\n    pstats.behaviourPenalty += penalty;\n  }\n  /**\n   * @param {string} id\n   * @returns {void}\n   */\n\n\n  addPeer(id) {\n    // create peer stats (not including topic stats for each topic to be scored)\n    // topic stats will be added as needed\n    const pstats = peer_stats_1.createPeerStats({\n      connected: true\n    });\n    this.peerStats.set(id, pstats); // get + update peer IPs\n\n    const ips = this._getIPs(id);\n\n    this._setIPs(id, ips, pstats.ips);\n\n    pstats.ips = ips;\n  }\n  /**\n   * @param {string} id\n   * @returns {void}\n   */\n\n\n  removePeer(id) {\n    const pstats = this.peerStats.get(id);\n\n    if (!pstats) {\n      return;\n    } // decide whether to retain the score; this currently only retains non-positive scores\n    // to dissuade attacks on the score function.\n\n\n    if (this.score(id) > 0) {\n      this._removeIPs(id, pstats.ips);\n\n      this.peerStats.delete(id);\n      return;\n    } // furthermore, when we decide to retain the score, the firstMessageDelivery counters are\n    // reset to 0 and mesh delivery penalties applied.\n\n\n    Object.entries(pstats.topics).forEach(([topic, tstats]) => {\n      tstats.firstMessageDeliveries = 0;\n      const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;\n\n      if (tstats.inMesh && tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {\n        const deficit = threshold - tstats.meshMessageDeliveries;\n        tstats.meshFailurePenalty += deficit * deficit;\n      }\n\n      tstats.inMesh = false;\n    });\n    pstats.connected = false;\n    pstats.expire = Date.now() + this.params.retainScore;\n  }\n  /**\n   * @param {string} id\n   * @param {String} topic\n   * @returns {void}\n   */\n\n\n  graft(id, topic) {\n    const pstats = this.peerStats.get(id);\n\n    if (!pstats) {\n      return;\n    }\n\n    const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);\n\n    if (!tstats) {\n      return;\n    }\n\n    tstats.inMesh = true;\n    tstats.graftTime = Date.now();\n    tstats.meshTime = 0;\n    tstats.meshMessageDeliveriesActive = false;\n  }\n  /**\n   * @param {string} id\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  prune(id, topic) {\n    const pstats = this.peerStats.get(id);\n\n    if (!pstats) {\n      return;\n    }\n\n    const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);\n\n    if (!tstats) {\n      return;\n    } // sticky mesh delivery rate failure penalty\n\n\n    const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;\n\n    if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {\n      const deficit = threshold - tstats.meshMessageDeliveries;\n      tstats.meshFailurePenalty += deficit * deficit;\n    }\n\n    tstats.inMesh = false;\n  }\n  /**\n   * @param {InMessage} message\n   * @returns {Promise<void>}\n   */\n\n\n  validateMessage(message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.deliveryRecords.ensureRecord(yield this.msgId(message));\n    });\n  }\n  /**\n   * @param {InMessage} message\n   * @returns {Promise<void>}\n   */\n\n\n  deliverMessage(message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const id = message.receivedFrom;\n\n      this._markFirstMessageDelivery(id, message);\n\n      const drec = this.deliveryRecords.ensureRecord(yield this.msgId(message));\n      const now = Date.now(); // defensive check that this is the first delivery trace -- delivery status should be unknown\n\n      if (drec.status !== message_deliveries_1.DeliveryRecordStatus.unknown) {\n        log('unexpected delivery: message from %s was first seen %s ago and has delivery status %d', id, now - drec.firstSeen, message_deliveries_1.DeliveryRecordStatus[drec.status]);\n        return;\n      } // mark the message as valid and reward mesh peers that have already forwarded it to us\n\n\n      drec.status = message_deliveries_1.DeliveryRecordStatus.valid;\n      drec.validated = now;\n      drec.peers.forEach(p => {\n        // this check is to make sure a peer can't send us a message twice and get a double count\n        // if it is a first delivery.\n        if (p !== id) {\n          this._markDuplicateMessageDelivery(p, message);\n        }\n      });\n    });\n  }\n  /**\n   * @param {InMessage} message\n   * @param {string} reason\n   * @returns {Promise<void>}\n   */\n\n\n  rejectMessage(message, reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const id = message.receivedFrom;\n\n      switch (reason) {\n        case ERR_MISSING_SIGNATURE:\n        case ERR_INVALID_SIGNATURE:\n          this._markInvalidMessageDelivery(id, message);\n\n          return;\n      }\n\n      const drec = this.deliveryRecords.ensureRecord(yield this.msgId(message)); // defensive check that this is the first rejection -- delivery status should be unknown\n\n      if (drec.status !== message_deliveries_1.DeliveryRecordStatus.unknown) {\n        log('unexpected rejection: message from %s was first seen %s ago and has delivery status %d', id, Date.now() - drec.firstSeen, message_deliveries_1.DeliveryRecordStatus[drec.status]);\n        return;\n      }\n\n      switch (reason) {\n        case constants_1.ERR_TOPIC_VALIDATOR_IGNORE:\n          // we were explicitly instructed by the validator to ignore the message but not penalize the peer\n          drec.status = message_deliveries_1.DeliveryRecordStatus.ignored;\n          return;\n      } // mark the message as invalid and penalize peers that have already forwarded it.\n\n\n      drec.status = message_deliveries_1.DeliveryRecordStatus.invalid;\n\n      this._markInvalidMessageDelivery(id, message);\n\n      drec.peers.forEach(p => {\n        this._markInvalidMessageDelivery(p, message);\n      });\n    });\n  }\n  /**\n   * @param {InMessage} message\n   * @returns {Promise<void>}\n   */\n\n\n  duplicateMessage(message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const id = message.receivedFrom;\n      const drec = this.deliveryRecords.ensureRecord(yield this.msgId(message));\n\n      if (drec.peers.has(id)) {\n        // we have already seen this duplicate\n        return;\n      }\n\n      switch (drec.status) {\n        case message_deliveries_1.DeliveryRecordStatus.unknown:\n          // the message is being validated; track the peer delivery and wait for\n          // the Deliver/Reject/Ignore notification.\n          drec.peers.add(id);\n          break;\n\n        case message_deliveries_1.DeliveryRecordStatus.valid:\n          // mark the peer delivery time to only count a duplicate delivery once.\n          drec.peers.add(id);\n\n          this._markDuplicateMessageDelivery(id, message, drec.validated);\n\n          break;\n\n        case message_deliveries_1.DeliveryRecordStatus.invalid:\n          // we no longer track delivery time\n          this._markInvalidMessageDelivery(id, message);\n\n          break;\n      }\n    });\n  }\n  /**\n   * Increments the \"invalid message deliveries\" counter for all scored topics the message is published in.\n   * @param {string} id\n   * @param {InMessage} message\n   * @returns {void}\n   */\n\n\n  _markInvalidMessageDelivery(id, message) {\n    const pstats = this.peerStats.get(id);\n\n    if (!pstats) {\n      return;\n    }\n\n    message.topicIDs.forEach(topic => {\n      const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);\n\n      if (!tstats) {\n        return;\n      }\n\n      tstats.invalidMessageDeliveries += 1;\n    });\n  }\n  /**\n   * Increments the \"first message deliveries\" counter for all scored topics the message is published in,\n   * as well as the \"mesh message deliveries\" counter, if the peer is in the mesh for the topic.\n   * @param {string} id\n   * @param {InMessage} message\n   * @returns {void}\n   */\n\n\n  _markFirstMessageDelivery(id, message) {\n    const pstats = this.peerStats.get(id);\n\n    if (!pstats) {\n      return;\n    }\n\n    message.topicIDs.forEach(topic => {\n      const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);\n\n      if (!tstats) {\n        return;\n      }\n\n      let cap = this.params.topics[topic].firstMessageDeliveriesCap;\n      tstats.firstMessageDeliveries += 1;\n\n      if (tstats.firstMessageDeliveries > cap) {\n        tstats.firstMessageDeliveries = cap;\n      }\n\n      if (!tstats.inMesh) {\n        return;\n      }\n\n      cap = this.params.topics[topic].meshMessageDeliveriesCap;\n      tstats.meshMessageDeliveries += 1;\n\n      if (tstats.meshMessageDeliveries > cap) {\n        tstats.meshMessageDeliveries = cap;\n      }\n    });\n  }\n  /**\n   * Increments the \"mesh message deliveries\" counter for messages we've seen before,\n   * as long the message was received within the P3 window.\n   * @param {string} id\n   * @param {InMessage} message\n   * @param {number} validatedTime\n   * @returns {void}\n   */\n\n\n  _markDuplicateMessageDelivery(id, message, validatedTime = 0) {\n    const pstats = this.peerStats.get(id);\n\n    if (!pstats) {\n      return;\n    }\n\n    const now = validatedTime ? Date.now() : 0;\n    message.topicIDs.forEach(topic => {\n      const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);\n\n      if (!tstats) {\n        return;\n      }\n\n      if (!tstats.inMesh) {\n        return;\n      }\n\n      const tparams = this.params.topics[topic]; // check against the mesh delivery window -- if the validated time is passed as 0, then\n      // the message was received before we finished validation and thus falls within the mesh\n      // delivery window.\n\n      if (validatedTime && now > validatedTime + tparams.meshMessageDeliveriesWindow) {\n        return;\n      }\n\n      const cap = tparams.meshMessageDeliveriesCap;\n      tstats.meshMessageDeliveries += 1;\n\n      if (tstats.meshMessageDeliveries > cap) {\n        tstats.meshMessageDeliveries = cap;\n      }\n    });\n  }\n  /**\n   * Gets the current IPs for a peer.\n   * @param {string} id\n   * @returns {Array<string>}\n   */\n\n\n  _getIPs(id) {\n    return this._connectionManager.getAll(peer_id_1.default.createFromB58String(id)).map(c => c.remoteAddr.toOptions().host);\n  }\n  /**\n   * Adds tracking for the new IPs in the list, and removes tracking from the obsolete IPs.\n   * @param {string} id\n   * @param {Array<string>} newIPs\n   * @param {Array<string>} oldIPs\n   * @returns {void}\n   */\n\n\n  _setIPs(id, newIPs, oldIPs) {\n    // add the new IPs to the tracking\n    // eslint-disable-next-line no-labels\n    addNewIPs: for (const ip of newIPs) {\n      // check if it is in the old ips list\n      for (const xip of oldIPs) {\n        if (ip === xip) {\n          // eslint-disable-next-line no-labels\n          continue addNewIPs;\n        }\n      } // no, it's a new one -- add it to the tracker\n\n\n      let peers = this.peerIPs.get(ip);\n\n      if (!peers) {\n        peers = new Set();\n        this.peerIPs.set(ip, peers);\n      }\n\n      peers.add(id);\n    } // remove the obsolete old IPs from the tracking\n    // eslint-disable-next-line no-labels\n\n\n    removeOldIPs: for (const ip of oldIPs) {\n      // check if it is in the new ips list\n      for (const xip of newIPs) {\n        if (ip === xip) {\n          // eslint-disable-next-line no-labels\n          continue removeOldIPs;\n        }\n      } // no, its obselete -- remove it from the tracker\n\n\n      const peers = this.peerIPs.get(ip);\n\n      if (!peers) {\n        continue;\n      }\n\n      peers.delete(id);\n\n      if (!peers.size) {\n        this.peerIPs.delete(ip);\n      }\n    }\n  }\n  /**\n   * Removes an IP list from the tracking list for a peer.\n   * @param {string} id\n   * @param {Array<string>} ips\n   * @returns {void}\n   */\n\n\n  _removeIPs(id, ips) {\n    ips.forEach(ip => {\n      const peers = this.peerIPs.get(ip);\n\n      if (!peers) {\n        return;\n      }\n\n      peers.delete(id);\n\n      if (!peers.size) {\n        this.peerIPs.delete(ip);\n      }\n    });\n  }\n  /**\n   * Update all peer IPs to currently open connections\n   * @returns {void}\n   */\n\n\n  _updateIPs() {\n    this.peerStats.forEach((pstats, id) => {\n      const newIPs = this._getIPs(id);\n\n      this._setIPs(id, newIPs, pstats.ips);\n\n      pstats.ips = newIPs;\n    });\n  }\n\n}\n\nexports.PeerScore = PeerScore;","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/libp2p-gossipsub/src/score/peer-score.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","__importDefault","mod","__esModule","Object","defineProperty","exports","PeerScore","peer_score_params_1","require","peer_stats_1","compute_score_1","message_deliveries_1","constants_1","peer_id_1","debug","pubsubErrors","ERR_INVALID_SIGNATURE","ERR_MISSING_SIGNATURE","codes","log","constructor","params","connectionManager","msgId","validatePeerScoreParams","_connectionManager","peerStats","Map","peerIPs","deliveryRecords","MessageDeliveries","start","_backgroundInterval","setInterval","background","decayInterval","stop","clearInterval","clear","_refreshScores","_updateIPs","gc","now","Date","decayToZero","forEach","pstats","id","connected","expire","_removeIPs","ips","delete","entries","topics","topic","tstats","tparams","firstMessageDeliveries","firstMessageDeliveriesDecay","meshMessageDeliveries","meshMessageDeliveriesDecay","meshFailurePenalty","meshFailurePenaltyDecay","invalidMessageDeliveries","invalidMessageDeliveriesDecay","inMesh","meshTime","graftTime","meshMessageDeliveriesActivation","meshMessageDeliveriesActive","behaviourPenalty","behaviourPenaltyDecay","score","get","computeScore","addPenalty","penalty","addPeer","createPeerStats","set","_getIPs","_setIPs","removePeer","threshold","meshMessageDeliveriesThreshold","deficit","retainScore","graft","ensureTopicStats","prune","validateMessage","message","ensureRecord","deliverMessage","receivedFrom","_markFirstMessageDelivery","drec","status","DeliveryRecordStatus","unknown","firstSeen","valid","validated","peers","p","_markDuplicateMessageDelivery","rejectMessage","reason","_markInvalidMessageDelivery","ERR_TOPIC_VALIDATOR_IGNORE","ignored","invalid","duplicateMessage","has","add","topicIDs","cap","firstMessageDeliveriesCap","meshMessageDeliveriesCap","validatedTime","meshMessageDeliveriesWindow","getAll","default","createFromB58String","map","c","remoteAddr","toOptions","host","newIPs","oldIPs","addNewIPs","ip","xip","Set","removeOldIPs","size"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PeerScore = void 0;\nconst peer_score_params_1 = require(\"./peer-score-params\");\nconst peer_stats_1 = require(\"./peer-stats\");\nconst compute_score_1 = require(\"./compute-score\");\nconst message_deliveries_1 = require(\"./message-deliveries\");\nconst constants_1 = require(\"../constants\");\nconst peer_id_1 = __importDefault(require(\"peer-id\"));\nconst debug = require(\"debug\");\nconst pubsubErrors = require(\"libp2p-interfaces/src/pubsub/errors\");\nconst { ERR_INVALID_SIGNATURE, ERR_MISSING_SIGNATURE } = pubsubErrors.codes;\nconst log = debug('libp2p:gossipsub:score');\nclass PeerScore {\n    constructor(params, connectionManager, msgId) {\n        peer_score_params_1.validatePeerScoreParams(params);\n        this.params = params;\n        this._connectionManager = connectionManager;\n        this.peerStats = new Map();\n        this.peerIPs = new Map();\n        this.deliveryRecords = new message_deliveries_1.MessageDeliveries();\n        this.msgId = msgId;\n    }\n    /**\n     * Start PeerScore instance\n     * @returns {void}\n     */\n    start() {\n        if (this._backgroundInterval) {\n            log('Peer score already running');\n            return;\n        }\n        this._backgroundInterval = setInterval(() => this.background(), this.params.decayInterval);\n        log('started');\n    }\n    /**\n     * Stop PeerScore instance\n     * @returns {void}\n     */\n    stop() {\n        if (!this._backgroundInterval) {\n            log('Peer score already stopped');\n            return;\n        }\n        clearInterval(this._backgroundInterval);\n        delete this._backgroundInterval;\n        this.peerIPs.clear();\n        this.peerStats.clear();\n        this.deliveryRecords.clear();\n        log('stopped');\n    }\n    /**\n     * Periodic maintenance\n     * @returns {void}\n     */\n    background() {\n        this._refreshScores();\n        this._updateIPs();\n        this.deliveryRecords.gc();\n    }\n    /**\n     * Decays scores, and purges score records for disconnected peers once their expiry has elapsed.\n     * @returns {void}\n     */\n    _refreshScores() {\n        const now = Date.now();\n        const decayToZero = this.params.decayToZero;\n        this.peerStats.forEach((pstats, id) => {\n            if (!pstats.connected) {\n                // has the retention perious expired?\n                if (now > pstats.expire) {\n                    // yes, throw it away (but clean up the IP tracking first)\n                    this._removeIPs(id, pstats.ips);\n                    this.peerStats.delete(id);\n                }\n                // we don't decay retained scores, as the peer is not active.\n                // this way the peer cannot reset a negative score by simply disconnecting and reconnecting,\n                // unless the retention period has ellapsed.\n                // similarly, a well behaved peer does not lose its score by getting disconnected.\n                return;\n            }\n            Object.entries(pstats.topics).forEach(([topic, tstats]) => {\n                const tparams = this.params.topics[topic];\n                if (!tparams) {\n                    // we are not scoring this topic\n                    // should be unreachable, we only add scored topics to pstats\n                    return;\n                }\n                // decay counters\n                tstats.firstMessageDeliveries *= tparams.firstMessageDeliveriesDecay;\n                if (tstats.firstMessageDeliveries < decayToZero) {\n                    tstats.firstMessageDeliveries = 0;\n                }\n                tstats.meshMessageDeliveries *= tparams.meshMessageDeliveriesDecay;\n                if (tstats.meshMessageDeliveries < decayToZero) {\n                    tstats.meshMessageDeliveries = 0;\n                }\n                tstats.meshFailurePenalty *= tparams.meshFailurePenaltyDecay;\n                if (tstats.meshFailurePenalty < decayToZero) {\n                    tstats.meshFailurePenalty = 0;\n                }\n                tstats.invalidMessageDeliveries *= tparams.invalidMessageDeliveriesDecay;\n                if (tstats.invalidMessageDeliveries < decayToZero) {\n                    tstats.invalidMessageDeliveries = 0;\n                }\n                // update mesh time and activate mesh message delivery parameter if need be\n                if (tstats.inMesh) {\n                    tstats.meshTime = now - tstats.graftTime;\n                    if (tstats.meshTime > tparams.meshMessageDeliveriesActivation) {\n                        tstats.meshMessageDeliveriesActive = true;\n                    }\n                }\n            });\n            // decay P7 counter\n            pstats.behaviourPenalty *= this.params.behaviourPenaltyDecay;\n            if (pstats.behaviourPenalty < decayToZero) {\n                pstats.behaviourPenalty = 0;\n            }\n        });\n    }\n    /**\n     * Return the score for a peer\n     * @param {string} id\n     * @returns {Number}\n     */\n    score(id) {\n        const pstats = this.peerStats.get(id);\n        if (!pstats) {\n            return 0;\n        }\n        return compute_score_1.computeScore(id, pstats, this.params, this.peerIPs);\n    }\n    /**\n     * Apply a behavioural penalty to a peer\n     * @param {string} id\n     * @param {Number} penalty\n     * @returns {void}\n     */\n    addPenalty(id, penalty) {\n        const pstats = this.peerStats.get(id);\n        if (!pstats) {\n            return;\n        }\n        pstats.behaviourPenalty += penalty;\n    }\n    /**\n     * @param {string} id\n     * @returns {void}\n     */\n    addPeer(id) {\n        // create peer stats (not including topic stats for each topic to be scored)\n        // topic stats will be added as needed\n        const pstats = peer_stats_1.createPeerStats({\n            connected: true\n        });\n        this.peerStats.set(id, pstats);\n        // get + update peer IPs\n        const ips = this._getIPs(id);\n        this._setIPs(id, ips, pstats.ips);\n        pstats.ips = ips;\n    }\n    /**\n     * @param {string} id\n     * @returns {void}\n     */\n    removePeer(id) {\n        const pstats = this.peerStats.get(id);\n        if (!pstats) {\n            return;\n        }\n        // decide whether to retain the score; this currently only retains non-positive scores\n        // to dissuade attacks on the score function.\n        if (this.score(id) > 0) {\n            this._removeIPs(id, pstats.ips);\n            this.peerStats.delete(id);\n            return;\n        }\n        // furthermore, when we decide to retain the score, the firstMessageDelivery counters are\n        // reset to 0 and mesh delivery penalties applied.\n        Object.entries(pstats.topics).forEach(([topic, tstats]) => {\n            tstats.firstMessageDeliveries = 0;\n            const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;\n            if (tstats.inMesh && tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {\n                const deficit = threshold - tstats.meshMessageDeliveries;\n                tstats.meshFailurePenalty += deficit * deficit;\n            }\n            tstats.inMesh = false;\n        });\n        pstats.connected = false;\n        pstats.expire = Date.now() + this.params.retainScore;\n    }\n    /**\n     * @param {string} id\n     * @param {String} topic\n     * @returns {void}\n     */\n    graft(id, topic) {\n        const pstats = this.peerStats.get(id);\n        if (!pstats) {\n            return;\n        }\n        const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);\n        if (!tstats) {\n            return;\n        }\n        tstats.inMesh = true;\n        tstats.graftTime = Date.now();\n        tstats.meshTime = 0;\n        tstats.meshMessageDeliveriesActive = false;\n    }\n    /**\n     * @param {string} id\n     * @param {string} topic\n     * @returns {void}\n     */\n    prune(id, topic) {\n        const pstats = this.peerStats.get(id);\n        if (!pstats) {\n            return;\n        }\n        const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);\n        if (!tstats) {\n            return;\n        }\n        // sticky mesh delivery rate failure penalty\n        const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;\n        if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {\n            const deficit = threshold - tstats.meshMessageDeliveries;\n            tstats.meshFailurePenalty += deficit * deficit;\n        }\n        tstats.inMesh = false;\n    }\n    /**\n     * @param {InMessage} message\n     * @returns {Promise<void>}\n     */\n    validateMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.deliveryRecords.ensureRecord(yield this.msgId(message));\n        });\n    }\n    /**\n     * @param {InMessage} message\n     * @returns {Promise<void>}\n     */\n    deliverMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const id = message.receivedFrom;\n            this._markFirstMessageDelivery(id, message);\n            const drec = this.deliveryRecords.ensureRecord(yield this.msgId(message));\n            const now = Date.now();\n            // defensive check that this is the first delivery trace -- delivery status should be unknown\n            if (drec.status !== message_deliveries_1.DeliveryRecordStatus.unknown) {\n                log('unexpected delivery: message from %s was first seen %s ago and has delivery status %d', id, now - drec.firstSeen, message_deliveries_1.DeliveryRecordStatus[drec.status]);\n                return;\n            }\n            // mark the message as valid and reward mesh peers that have already forwarded it to us\n            drec.status = message_deliveries_1.DeliveryRecordStatus.valid;\n            drec.validated = now;\n            drec.peers.forEach(p => {\n                // this check is to make sure a peer can't send us a message twice and get a double count\n                // if it is a first delivery.\n                if (p !== id) {\n                    this._markDuplicateMessageDelivery(p, message);\n                }\n            });\n        });\n    }\n    /**\n     * @param {InMessage} message\n     * @param {string} reason\n     * @returns {Promise<void>}\n     */\n    rejectMessage(message, reason) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const id = message.receivedFrom;\n            switch (reason) {\n                case ERR_MISSING_SIGNATURE:\n                case ERR_INVALID_SIGNATURE:\n                    this._markInvalidMessageDelivery(id, message);\n                    return;\n            }\n            const drec = this.deliveryRecords.ensureRecord(yield this.msgId(message));\n            // defensive check that this is the first rejection -- delivery status should be unknown\n            if (drec.status !== message_deliveries_1.DeliveryRecordStatus.unknown) {\n                log('unexpected rejection: message from %s was first seen %s ago and has delivery status %d', id, Date.now() - drec.firstSeen, message_deliveries_1.DeliveryRecordStatus[drec.status]);\n                return;\n            }\n            switch (reason) {\n                case constants_1.ERR_TOPIC_VALIDATOR_IGNORE:\n                    // we were explicitly instructed by the validator to ignore the message but not penalize the peer\n                    drec.status = message_deliveries_1.DeliveryRecordStatus.ignored;\n                    return;\n            }\n            // mark the message as invalid and penalize peers that have already forwarded it.\n            drec.status = message_deliveries_1.DeliveryRecordStatus.invalid;\n            this._markInvalidMessageDelivery(id, message);\n            drec.peers.forEach(p => {\n                this._markInvalidMessageDelivery(p, message);\n            });\n        });\n    }\n    /**\n     * @param {InMessage} message\n     * @returns {Promise<void>}\n     */\n    duplicateMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const id = message.receivedFrom;\n            const drec = this.deliveryRecords.ensureRecord(yield this.msgId(message));\n            if (drec.peers.has(id)) {\n                // we have already seen this duplicate\n                return;\n            }\n            switch (drec.status) {\n                case message_deliveries_1.DeliveryRecordStatus.unknown:\n                    // the message is being validated; track the peer delivery and wait for\n                    // the Deliver/Reject/Ignore notification.\n                    drec.peers.add(id);\n                    break;\n                case message_deliveries_1.DeliveryRecordStatus.valid:\n                    // mark the peer delivery time to only count a duplicate delivery once.\n                    drec.peers.add(id);\n                    this._markDuplicateMessageDelivery(id, message, drec.validated);\n                    break;\n                case message_deliveries_1.DeliveryRecordStatus.invalid:\n                    // we no longer track delivery time\n                    this._markInvalidMessageDelivery(id, message);\n                    break;\n            }\n        });\n    }\n    /**\n     * Increments the \"invalid message deliveries\" counter for all scored topics the message is published in.\n     * @param {string} id\n     * @param {InMessage} message\n     * @returns {void}\n     */\n    _markInvalidMessageDelivery(id, message) {\n        const pstats = this.peerStats.get(id);\n        if (!pstats) {\n            return;\n        }\n        message.topicIDs.forEach(topic => {\n            const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);\n            if (!tstats) {\n                return;\n            }\n            tstats.invalidMessageDeliveries += 1;\n        });\n    }\n    /**\n     * Increments the \"first message deliveries\" counter for all scored topics the message is published in,\n     * as well as the \"mesh message deliveries\" counter, if the peer is in the mesh for the topic.\n     * @param {string} id\n     * @param {InMessage} message\n     * @returns {void}\n     */\n    _markFirstMessageDelivery(id, message) {\n        const pstats = this.peerStats.get(id);\n        if (!pstats) {\n            return;\n        }\n        message.topicIDs.forEach(topic => {\n            const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);\n            if (!tstats) {\n                return;\n            }\n            let cap = this.params.topics[topic].firstMessageDeliveriesCap;\n            tstats.firstMessageDeliveries += 1;\n            if (tstats.firstMessageDeliveries > cap) {\n                tstats.firstMessageDeliveries = cap;\n            }\n            if (!tstats.inMesh) {\n                return;\n            }\n            cap = this.params.topics[topic].meshMessageDeliveriesCap;\n            tstats.meshMessageDeliveries += 1;\n            if (tstats.meshMessageDeliveries > cap) {\n                tstats.meshMessageDeliveries = cap;\n            }\n        });\n    }\n    /**\n     * Increments the \"mesh message deliveries\" counter for messages we've seen before,\n     * as long the message was received within the P3 window.\n     * @param {string} id\n     * @param {InMessage} message\n     * @param {number} validatedTime\n     * @returns {void}\n     */\n    _markDuplicateMessageDelivery(id, message, validatedTime = 0) {\n        const pstats = this.peerStats.get(id);\n        if (!pstats) {\n            return;\n        }\n        const now = validatedTime ? Date.now() : 0;\n        message.topicIDs.forEach(topic => {\n            const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);\n            if (!tstats) {\n                return;\n            }\n            if (!tstats.inMesh) {\n                return;\n            }\n            const tparams = this.params.topics[topic];\n            // check against the mesh delivery window -- if the validated time is passed as 0, then\n            // the message was received before we finished validation and thus falls within the mesh\n            // delivery window.\n            if (validatedTime && now > validatedTime + tparams.meshMessageDeliveriesWindow) {\n                return;\n            }\n            const cap = tparams.meshMessageDeliveriesCap;\n            tstats.meshMessageDeliveries += 1;\n            if (tstats.meshMessageDeliveries > cap) {\n                tstats.meshMessageDeliveries = cap;\n            }\n        });\n    }\n    /**\n     * Gets the current IPs for a peer.\n     * @param {string} id\n     * @returns {Array<string>}\n     */\n    _getIPs(id) {\n        return this._connectionManager.getAll(peer_id_1.default.createFromB58String(id))\n            .map(c => c.remoteAddr.toOptions().host);\n    }\n    /**\n     * Adds tracking for the new IPs in the list, and removes tracking from the obsolete IPs.\n     * @param {string} id\n     * @param {Array<string>} newIPs\n     * @param {Array<string>} oldIPs\n     * @returns {void}\n     */\n    _setIPs(id, newIPs, oldIPs) {\n        // add the new IPs to the tracking\n        // eslint-disable-next-line no-labels\n        addNewIPs: for (const ip of newIPs) {\n            // check if it is in the old ips list\n            for (const xip of oldIPs) {\n                if (ip === xip) {\n                    // eslint-disable-next-line no-labels\n                    continue addNewIPs;\n                }\n            }\n            // no, it's a new one -- add it to the tracker\n            let peers = this.peerIPs.get(ip);\n            if (!peers) {\n                peers = new Set();\n                this.peerIPs.set(ip, peers);\n            }\n            peers.add(id);\n        }\n        // remove the obsolete old IPs from the tracking\n        // eslint-disable-next-line no-labels\n        removeOldIPs: for (const ip of oldIPs) {\n            // check if it is in the new ips list\n            for (const xip of newIPs) {\n                if (ip === xip) {\n                    // eslint-disable-next-line no-labels\n                    continue removeOldIPs;\n                }\n            }\n            // no, its obselete -- remove it from the tracker\n            const peers = this.peerIPs.get(ip);\n            if (!peers) {\n                continue;\n            }\n            peers.delete(id);\n            if (!peers.size) {\n                this.peerIPs.delete(ip);\n            }\n        }\n    }\n    /**\n     * Removes an IP list from the tracking list for a peer.\n     * @param {string} id\n     * @param {Array<string>} ips\n     * @returns {void}\n     */\n    _removeIPs(id, ips) {\n        ips.forEach(ip => {\n            const peers = this.peerIPs.get(ip);\n            if (!peers) {\n                return;\n            }\n            peers.delete(id);\n            if (!peers.size) {\n                this.peerIPs.delete(ip);\n            }\n        });\n    }\n    /**\n     * Update all peer IPs to currently open connections\n     * @returns {void}\n     */\n    _updateIPs() {\n        this.peerStats.forEach((pstats, id) => {\n            const newIPs = this._getIPs(id);\n            this._setIPs(id, newIPs, pstats.ips);\n            pstats.ips = newIPs;\n        });\n    }\n}\nexports.PeerScore = PeerScore;\n"]},"metadata":{},"sourceType":"script"}