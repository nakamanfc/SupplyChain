{"ast":null,"code":"'use strict';\n\nconst {\n  default: Queue\n} = require('p-queue');\n/**\n * @typedef {import('peer-id')} PeerId\n */\n\n\nclass WorkerQueue {\n  /**\n   * Creates a new WorkerQueue.\n   *\n   * @param {import('../index')} dht\n   * @param {import('./run')} run\n   * @param {import('./path')} path\n   * @param {Function & {error: Function}} log\n   */\n  constructor(dht, run, path, log) {\n    this.dht = dht;\n    this.run = run;\n    this.path = path;\n    this.log = log;\n    this.concurrency = this.dht.concurrency;\n    this.queue = this.setupQueue(); // a container for resolve/reject functions that will be populated\n    // when execute() is called\n\n    /** @type {{ resolve: (result?: any) => void, reject: (err: Error) => void} | null} */\n\n    this.execution = null;\n    /** @type {Set<PeerId>} */\n\n    this.queuedPeerIds = new Set();\n  }\n  /**\n   * Create the underlying async queue.\n   *\n   * @returns {Queue}\n   */\n\n\n  setupQueue() {\n    const q = new Queue({\n      concurrency: this.concurrency\n    }); // When all peers in the queue have been processed, stop the worker\n\n    q.on('idle', () => {\n      if (this.path.peersToQuery && !this.path.peersToQuery.length) {\n        this.log('queue:drain');\n        this.stop();\n      }\n    }); // When a space opens up in the queue, add some more peers\n\n    q.on('next', () => {\n      if (!this.running) {\n        return;\n      }\n\n      if (q.pending < this.concurrency) {\n        this.fill();\n      }\n    });\n    return q;\n  }\n  /**\n   * Stop the worker, optionally providing an error to pass to the worker's\n   * callback.\n   *\n   * @param {Error} [err]\n   */\n\n\n  stop(err) {\n    if (!this.running) {\n      return;\n    }\n\n    this.running = false;\n    this.queue.clear();\n    this.log('worker:stop, %d workers still running', this.run.workers.filter(w => w.running).length);\n\n    if (this.execution) {\n      if (err) {\n        this.execution.reject(err);\n      } else {\n        this.execution.resolve();\n      }\n    }\n  }\n  /**\n   * Use the queue from async to keep `concurrency` amount items running\n   * per path.\n   *\n   * @returns {Promise<void>}\n   */\n\n\n  async execute() {\n    this.running = true; // store the promise resolution functions to be resolved at end of queue\n\n    this.execution = null;\n    const execPromise = new Promise((resolve, reject) => {\n      this.execution = {\n        resolve,\n        reject\n      };\n    }); // start queue\n\n    this.fill(); // await completion\n\n    await execPromise;\n  }\n  /**\n   * Add peers to the worker queue until there are enough to satisfy the\n   * worker queue concurrency.\n   * Note that we don't want to take any more than those required to satisfy\n   * concurrency from the peers-to-query queue, because we always want to\n   * query the closest peers to the key first, and new peers are continuously\n   * being added to the peers-to-query queue.\n   */\n\n\n  fill() {\n    if (!this.path.peersToQuery) {\n      return;\n    } // Note:\n    // - queue.pending: number of items that are currently running\n    // - queue.size: the number of items that are waiting to be run\n\n\n    while (this.queue.pending + this.queue.size < this.concurrency && this.path.peersToQuery.length > 0) {\n      const peer = this.path.peersToQuery.dequeue(); // store the peer id so we can potentially abort early\n\n      this.queuedPeerIds.add(peer);\n      this.queue.add(() => {\n        return this.processNext(peer).catch(err => {\n          this.log.error('queue', err);\n          this.stop(err);\n        }).finally(() => {\n          this.queuedPeerIds.delete(peer);\n        });\n      });\n    }\n  }\n  /**\n   * Process the next peer in the queue\n   *\n   * @param {PeerId} peer\n   */\n\n\n  async processNext(peer) {\n    if (!this.running) {\n      return;\n    } // The paths must be disjoint, meaning that no two paths in the Query may\n    // traverse the same peer\n\n\n    if (this.run.peersSeen.has(peer.toB58String())) {\n      return;\n    } // Check if we've queried enough peers already\n\n\n    let continueQuerying, continueQueryingError;\n\n    try {\n      continueQuerying = await this.run.continueQuerying(this);\n    } catch (err) {\n      continueQueryingError = err;\n    } // Abort and ignore any error if we're no longer running\n\n\n    if (!this.running) {\n      return;\n    }\n\n    if (continueQueryingError) {\n      throw continueQueryingError;\n    } // No peer we're querying is closer, stop the queue\n    // This will cause queries that may potentially result in\n    // closer nodes to be ended, but it reduces overall query time\n\n\n    if (!continueQuerying) {\n      this.stop();\n      return;\n    } // Check if another path has queried this peer in the mean time\n\n\n    if (this.run.peersSeen.has(peer.toB58String())) {\n      return;\n    }\n\n    this.run.peersSeen.add(peer.toB58String()); // Execute the query on the next peer\n\n    this.log('queue:work');\n    let state, execError;\n\n    try {\n      state = await this.execQuery(peer);\n    } catch (err) {\n      execError = err;\n    } // Abort and ignore any error if we're no longer running\n\n\n    if (!this.running) {\n      return;\n    }\n\n    this.log('queue:work:done', execError, state);\n\n    if (execError) {\n      throw execError;\n    } // If query is complete, stop all workers.\n    // Note: run.stop() calls stop() on all the workers, which kills the\n    // queue and resolves execution\n\n\n    if (state && state.queryComplete) {\n      this.log('query:complete');\n      this.run.stop();\n      return;\n    } // If path is complete, just stop this worker.\n    // Note: this.stop() kills the queue and resolves execution\n\n\n    if (state && state.pathComplete) {\n      this.stop();\n    }\n  }\n  /**\n   * Execute a query on the next peer.\n   *\n   * @param {PeerId} peer\n   */\n\n\n  async execQuery(peer) {\n    let res, queryError;\n\n    try {\n      res = await this.path.queryFunc(peer);\n    } catch (err) {\n      queryError = err;\n    } // Abort and ignore any error if we're no longer running\n\n\n    if (!this.running) {\n      return;\n    }\n\n    if (queryError) {\n      this.run.errors.push(queryError);\n      return;\n    } // Add the peer to the closest peers we have successfully queried\n\n\n    this.run.peersQueried && (await this.run.peersQueried.add(peer));\n\n    if (!res) {\n      return;\n    } // If the query indicates that this path or the whole query is complete\n    // set the path result and bail out\n\n\n    if (res.pathComplete || res.queryComplete) {\n      this.path.res = res;\n      return {\n        pathComplete: res.pathComplete,\n        queryComplete: res.queryComplete\n      };\n    } // If there are closer peers to query, add them to the queue\n\n\n    if (res.closerPeers && res.closerPeers.length > 0) {\n      /**\n       * @param {import('../').PeerData} closer\n       */\n      const queryCloser = async closer => {\n        // don't add ourselves\n        if (this.dht._isSelf(closer.id)) {\n          return;\n        }\n\n        this.dht._peerDiscovered(closer.id, closer.multiaddrs);\n\n        await this.path.addPeerToQuery(closer.id);\n      };\n\n      await Promise.all(res.closerPeers.map(queryCloser));\n    }\n  }\n\n}\n\nmodule.exports = WorkerQueue;","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/libp2p-kad-dht/src/query/worker-queue.js"],"names":["default","Queue","require","WorkerQueue","constructor","dht","run","path","log","concurrency","queue","setupQueue","execution","queuedPeerIds","Set","q","on","peersToQuery","length","stop","running","pending","fill","err","clear","workers","filter","w","reject","resolve","execute","execPromise","Promise","size","peer","dequeue","add","processNext","catch","error","finally","delete","peersSeen","has","toB58String","continueQuerying","continueQueryingError","state","execError","execQuery","queryComplete","pathComplete","res","queryError","queryFunc","errors","push","peersQueried","closerPeers","queryCloser","closer","_isSelf","id","_peerDiscovered","multiaddrs","addPeerToQuery","all","map","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { default: Queue } = require('p-queue')\n\n/**\n * @typedef {import('peer-id')} PeerId\n */\n\nclass WorkerQueue {\n  /**\n   * Creates a new WorkerQueue.\n   *\n   * @param {import('../index')} dht\n   * @param {import('./run')} run\n   * @param {import('./path')} path\n   * @param {Function & {error: Function}} log\n   */\n  constructor (dht, run, path, log) {\n    this.dht = dht\n    this.run = run\n    this.path = path\n    this.log = log\n\n    this.concurrency = this.dht.concurrency\n    this.queue = this.setupQueue()\n    // a container for resolve/reject functions that will be populated\n    // when execute() is called\n\n    /** @type {{ resolve: (result?: any) => void, reject: (err: Error) => void} | null} */\n    this.execution = null\n\n    /** @type {Set<PeerId>} */\n    this.queuedPeerIds = new Set()\n  }\n\n  /**\n   * Create the underlying async queue.\n   *\n   * @returns {Queue}\n   */\n  setupQueue () {\n    const q = new Queue({\n      concurrency: this.concurrency\n    })\n\n    // When all peers in the queue have been processed, stop the worker\n    q.on('idle', () => {\n      if (this.path.peersToQuery && !this.path.peersToQuery.length) {\n        this.log('queue:drain')\n        this.stop()\n      }\n    })\n\n    // When a space opens up in the queue, add some more peers\n    q.on('next', () => {\n      if (!this.running) {\n        return\n      }\n\n      if (q.pending < this.concurrency) {\n        this.fill()\n      }\n    })\n\n    return q\n  }\n\n  /**\n   * Stop the worker, optionally providing an error to pass to the worker's\n   * callback.\n   *\n   * @param {Error} [err]\n   */\n  stop (err) {\n    if (!this.running) {\n      return\n    }\n\n    this.running = false\n    this.queue.clear()\n    this.log('worker:stop, %d workers still running', this.run.workers.filter(w => w.running).length)\n\n    if (this.execution) {\n      if (err) {\n        this.execution.reject(err)\n      } else {\n        this.execution.resolve()\n      }\n    }\n  }\n\n  /**\n   * Use the queue from async to keep `concurrency` amount items running\n   * per path.\n   *\n   * @returns {Promise<void>}\n   */\n  async execute () {\n    this.running = true\n    // store the promise resolution functions to be resolved at end of queue\n    this.execution = null\n    const execPromise = new Promise((resolve, reject) => {\n      this.execution = {\n        resolve, reject\n      }\n    })\n    // start queue\n    this.fill()\n    // await completion\n    await execPromise\n  }\n\n  /**\n   * Add peers to the worker queue until there are enough to satisfy the\n   * worker queue concurrency.\n   * Note that we don't want to take any more than those required to satisfy\n   * concurrency from the peers-to-query queue, because we always want to\n   * query the closest peers to the key first, and new peers are continuously\n   * being added to the peers-to-query queue.\n   */\n  fill () {\n    if (!this.path.peersToQuery) {\n      return\n    }\n\n    // Note:\n    // - queue.pending: number of items that are currently running\n    // - queue.size: the number of items that are waiting to be run\n    while (this.queue.pending + this.queue.size < this.concurrency && this.path.peersToQuery.length > 0) {\n      const peer = this.path.peersToQuery.dequeue()\n\n      // store the peer id so we can potentially abort early\n      this.queuedPeerIds.add(peer)\n\n      this.queue.add(\n        () => {\n          return this.processNext(peer)\n            .catch(err => {\n              this.log.error('queue', err)\n              this.stop(err)\n            })\n            .finally(() => {\n              this.queuedPeerIds.delete(peer)\n            })\n        }\n      )\n    }\n  }\n\n  /**\n   * Process the next peer in the queue\n   *\n   * @param {PeerId} peer\n   */\n  async processNext (peer) {\n    if (!this.running) {\n      return\n    }\n\n    // The paths must be disjoint, meaning that no two paths in the Query may\n    // traverse the same peer\n    if (this.run.peersSeen.has(peer.toB58String())) {\n      return\n    }\n\n    // Check if we've queried enough peers already\n    let continueQuerying, continueQueryingError\n    try {\n      continueQuerying = await this.run.continueQuerying(this)\n    } catch (err) {\n      continueQueryingError = err\n    }\n\n    // Abort and ignore any error if we're no longer running\n    if (!this.running) {\n      return\n    }\n\n    if (continueQueryingError) {\n      throw continueQueryingError\n    }\n\n    // No peer we're querying is closer, stop the queue\n    // This will cause queries that may potentially result in\n    // closer nodes to be ended, but it reduces overall query time\n    if (!continueQuerying) {\n      this.stop()\n      return\n    }\n\n    // Check if another path has queried this peer in the mean time\n    if (this.run.peersSeen.has(peer.toB58String())) {\n      return\n    }\n    this.run.peersSeen.add(peer.toB58String())\n\n    // Execute the query on the next peer\n    this.log('queue:work')\n    let state, execError\n    try {\n      state = await this.execQuery(peer)\n    } catch (err) {\n      execError = err\n    }\n\n    // Abort and ignore any error if we're no longer running\n    if (!this.running) {\n      return\n    }\n\n    this.log('queue:work:done', execError, state)\n\n    if (execError) {\n      throw execError\n    }\n\n    // If query is complete, stop all workers.\n    // Note: run.stop() calls stop() on all the workers, which kills the\n    // queue and resolves execution\n    if (state && state.queryComplete) {\n      this.log('query:complete')\n      this.run.stop()\n      return\n    }\n\n    // If path is complete, just stop this worker.\n    // Note: this.stop() kills the queue and resolves execution\n    if (state && state.pathComplete) {\n      this.stop()\n    }\n  }\n\n  /**\n   * Execute a query on the next peer.\n   *\n   * @param {PeerId} peer\n   */\n  async execQuery (peer) {\n    let res, queryError\n    try {\n      res = await this.path.queryFunc(peer)\n    } catch (err) {\n      queryError = err\n    }\n\n    // Abort and ignore any error if we're no longer running\n    if (!this.running) {\n      return\n    }\n\n    if (queryError) {\n      this.run.errors.push(queryError)\n      return\n    }\n\n    // Add the peer to the closest peers we have successfully queried\n    this.run.peersQueried && await this.run.peersQueried.add(peer)\n\n    if (!res) {\n      return\n    }\n\n    // If the query indicates that this path or the whole query is complete\n    // set the path result and bail out\n    if (res.pathComplete || res.queryComplete) {\n      this.path.res = res\n\n      return {\n        pathComplete: res.pathComplete,\n        queryComplete: res.queryComplete\n      }\n    }\n\n    // If there are closer peers to query, add them to the queue\n    if (res.closerPeers && res.closerPeers.length > 0) {\n      /**\n       * @param {import('../').PeerData} closer\n       */\n      const queryCloser = async (closer) => {\n        // don't add ourselves\n        if (this.dht._isSelf(closer.id)) {\n          return\n        }\n\n        this.dht._peerDiscovered(closer.id, closer.multiaddrs)\n        await this.path.addPeerToQuery(closer.id)\n      }\n\n      await Promise.all(res.closerPeers.map(queryCloser))\n    }\n  }\n}\n\nmodule.exports = WorkerQueue\n"]},"metadata":{},"sourceType":"script"}