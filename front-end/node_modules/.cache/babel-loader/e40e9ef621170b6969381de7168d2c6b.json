{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst {\n  default: parseDuration\n} = require('parse-duration');\n\nconst crypto = require('libp2p-crypto');\n\nconst errcode = require('err-code');\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst log = Object.assign(debug('ipfs:name:publish'), {\n  error: debug('ipfs:name:publish:error')\n});\n\nconst {\n  OFFLINE_ERROR,\n  normalizePath\n} = require('../../utils');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst {\n  resolvePath\n} = require('./utils');\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {Object} config\n * @param {import('../ipns')} config.ipns\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n * @param {import('peer-id')} config.peerId\n * @param {import('ipfs-core-types/src/root').API[\"isOnline\"]} config.isOnline\n * @param {import('libp2p/src/keychain')} config.keychain\n */\n\n\nmodule.exports = ({\n  ipns,\n  repo,\n  codecs,\n  peerId,\n  isOnline,\n  keychain\n}) => {\n  /**\n   * @param {string} keyName\n   */\n  const lookupKey = async keyName => {\n    if (keyName === 'self') {\n      return peerId.privKey;\n    }\n\n    try {\n      // We're exporting and immediately importing the key, so we can just use a throw away password\n      const pem = await keychain.exportKey(keyName, 'temp');\n      const privateKey = await crypto.keys.import(pem, 'temp');\n      return privateKey;\n    } catch (err) {\n      log.error(err);\n      throw errcode(err, 'ERR_CANNOT_GET_KEY');\n    }\n  };\n  /**\n   * @type {import('ipfs-core-types/src/name').API[\"publish\"]}\n   */\n\n\n  async function publish(value, options = {}) {\n    const resolve = !(options.resolve === false);\n    const lifetime = options.lifetime || '24h';\n    const key = options.key || 'self';\n\n    if (!isOnline()) {\n      throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR');\n    } // TODO: params related logic should be in the core implementation\n    // Normalize path value\n\n\n    try {\n      value = normalizePath(value);\n    } catch (err) {\n      log.error(err);\n      throw err;\n    }\n\n    let pubLifetime = 0;\n\n    try {\n      pubLifetime = parseDuration(lifetime) || 0; // Calculate lifetime with nanoseconds precision\n\n      pubLifetime = parseFloat(pubLifetime.toFixed(6));\n    } catch (err) {\n      log.error(err);\n      throw err;\n    } // TODO: ttl human for cache\n\n\n    const results = await Promise.all([// verify if the path exists, if not, an error will stop the execution\n    lookupKey(key), // if resolving, do a get so we make sure we have the blocks\n    resolve ? resolvePath({\n      ipns,\n      repo,\n      codecs\n    }, value) : Promise.resolve()]);\n    const bytes = uint8ArrayFromString(value); // Start publishing process\n\n    const result = await ipns.publish(results[0], bytes, pubLifetime);\n    return {\n      name: result.name,\n      value: uint8ArrayToString(result.value)\n    };\n  }\n\n  return withTimeoutOption(publish);\n};","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/ipfs-core/src/components/name/publish.js"],"names":["debug","require","default","parseDuration","crypto","errcode","fromString","uint8ArrayFromString","toString","uint8ArrayToString","log","Object","assign","error","OFFLINE_ERROR","normalizePath","withTimeoutOption","resolvePath","module","exports","ipns","repo","codecs","peerId","isOnline","keychain","lookupKey","keyName","privKey","pem","exportKey","privateKey","keys","import","err","publish","value","options","resolve","lifetime","key","Error","pubLifetime","parseFloat","toFixed","results","Promise","all","bytes","result","name"],"mappings":"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","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst { default: parseDuration } = require('parse-duration')\nconst crypto = require('libp2p-crypto')\nconst errcode = require('err-code')\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\n\nconst log = Object.assign(debug('ipfs:name:publish'), {\n  error: debug('ipfs:name:publish:error')\n})\n\nconst { OFFLINE_ERROR, normalizePath } = require('../../utils')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\nconst { resolvePath } = require('./utils')\n\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {Object} config\n * @param {import('../ipns')} config.ipns\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n * @param {import('ipfs-core-utils/src/multicodecs')} config.codecs\n * @param {import('peer-id')} config.peerId\n * @param {import('ipfs-core-types/src/root').API[\"isOnline\"]} config.isOnline\n * @param {import('libp2p/src/keychain')} config.keychain\n */\nmodule.exports = ({ ipns, repo, codecs, peerId, isOnline, keychain }) => {\n  /**\n   * @param {string} keyName\n   */\n  const lookupKey = async keyName => {\n    if (keyName === 'self') {\n      return peerId.privKey\n    }\n\n    try {\n      // We're exporting and immediately importing the key, so we can just use a throw away password\n      const pem = await keychain.exportKey(keyName, 'temp')\n      const privateKey = await crypto.keys.import(pem, 'temp')\n      return privateKey\n    } catch (err) {\n      log.error(err)\n      throw errcode(err, 'ERR_CANNOT_GET_KEY')\n    }\n  }\n\n  /**\n   * @type {import('ipfs-core-types/src/name').API[\"publish\"]}\n   */\n  async function publish (value, options = {}) {\n    const resolve = !(options.resolve === false)\n    const lifetime = options.lifetime || '24h'\n    const key = options.key || 'self'\n\n    if (!isOnline()) {\n      throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR')\n    }\n\n    // TODO: params related logic should be in the core implementation\n    // Normalize path value\n    try {\n      value = normalizePath(value)\n    } catch (err) {\n      log.error(err)\n      throw err\n    }\n\n    let pubLifetime = 0\n    try {\n      pubLifetime = parseDuration(lifetime) || 0\n\n      // Calculate lifetime with nanoseconds precision\n      pubLifetime = parseFloat(pubLifetime.toFixed(6))\n    } catch (err) {\n      log.error(err)\n      throw err\n    }\n\n    // TODO: ttl human for cache\n    const results = await Promise.all([\n      // verify if the path exists, if not, an error will stop the execution\n      lookupKey(key),\n      // if resolving, do a get so we make sure we have the blocks\n      resolve ? resolvePath({ ipns, repo, codecs }, value) : Promise.resolve()\n    ])\n\n    const bytes = uint8ArrayFromString(value)\n\n    // Start publishing process\n    const result = await ipns.publish(results[0], bytes, pubLifetime)\n\n    return {\n      name: result.name,\n      value: uint8ArrayToString(result.value)\n    }\n  }\n\n  return withTimeoutOption(publish)\n}\n"]},"metadata":{},"sourceType":"script"}