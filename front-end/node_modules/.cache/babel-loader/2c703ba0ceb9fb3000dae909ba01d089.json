{"ast":null,"code":"'use strict';\n\nconst PeerId = require('peer-id');\n\nconst errCode = require('err-code');\n\nconst {\n  NotEnabledError\n} = require('../errors');\n\nconst get = require('dlv');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n/**\n * @param {Object} config\n * @param {import('../types').NetworkService} config.network\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n */\n\n\nmodule.exports = ({\n  network,\n  repo\n}) => {\n  const {\n    get,\n    put,\n    findProvs,\n    findPeer,\n    provide,\n    query\n  } = {\n    /**\n     * @type {import('ipfs-core-types/src/dht').API[\"get\"]}\n     */\n    async get(key, options = {}) {\n      const {\n        libp2p\n      } = await use(network, options);\n      return libp2p._dht.get(key, options);\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API[\"put\"]}\n     */\n    async *put(key, value, options) {\n      const {\n        libp2p\n      } = await use(network, options);\n      yield* libp2p._dht.put(key, value);\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API[\"findProvs\"]}\n     */\n    async *findProvs(cid, options = {\n      numProviders: 20\n    }) {\n      const {\n        libp2p\n      } = await use(network, options);\n\n      for await (const peer of libp2p._dht.findProviders(cid, {\n        maxNumProviders: options.numProviders,\n        signal: options.signal\n      })) {\n        yield {\n          id: peer.id.toB58String(),\n          addrs: peer.addrs\n        };\n      }\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API[\"findPeer\"]}\n     */\n    async findPeer(peerId, options) {\n      const {\n        libp2p\n      } = await use(network, options);\n      const peer = await libp2p._dht.findPeer(PeerId.parse(peerId));\n      return {\n        id: peer.id.toB58String(),\n        addrs: peer.multiaddrs\n      };\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API[\"provide\"]}\n     */\n    async *provide(cids, options = {\n      recursive: false\n    }) {\n      const {\n        libp2p\n      } = await use(network, options);\n      const cidArr = Array.isArray(cids) ? cids : [cids]; // ensure blocks are actually local\n\n      const hasCids = await Promise.all(cidArr.map(cid => repo.blocks.has(cid)));\n      const hasAll = hasCids.every(has => has);\n\n      if (!hasAll) {\n        throw errCode(new Error('block(s) not found locally, cannot provide'), 'ERR_BLOCK_NOT_FOUND');\n      }\n\n      if (options.recursive) {\n        // TODO: Implement recursive providing\n        throw errCode(new Error('not implemented yet'), 'ERR_NOT_IMPLEMENTED_YET');\n      }\n\n      for (const cid of cidArr) {\n        yield libp2p._dht.provide(cid);\n      }\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API[\"query\"]}\n     */\n    async *query(peerId, options) {\n      const {\n        libp2p\n      } = await use(network, options);\n\n      for await (const closerPeerId of libp2p._dht.getClosestPeers(PeerId.parse(peerId).toBytes())) {\n        yield {\n          id: closerPeerId.toB58String(),\n          addrs: [] // TODO: get addrs?\n\n        };\n      }\n    }\n\n  };\n  return {\n    get: withTimeoutOption(get),\n    put: withTimeoutOption(put),\n    findProvs: withTimeoutOption(findProvs),\n    findPeer: withTimeoutOption(findPeer),\n    provide: withTimeoutOption(provide),\n    query: withTimeoutOption(query)\n  };\n};\n/**\n * @param {import('../types').NetworkService} network\n * @param {import('ipfs-core-types/src/utils').AbortOptions} [options]\n */\n\n\nconst use = async (network, options) => {\n  const net = await network.use(options);\n\n  if (get(net.libp2p, '_config.dht.enabled', false)) {\n    return net;\n  } else {\n    throw new NotEnabledError('dht not enabled');\n  }\n};","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/ipfs-core/src/components/dht.js"],"names":["PeerId","require","errCode","NotEnabledError","get","withTimeoutOption","module","exports","network","repo","put","findProvs","findPeer","provide","query","key","options","libp2p","use","_dht","value","cid","numProviders","peer","findProviders","maxNumProviders","signal","id","toB58String","addrs","peerId","parse","multiaddrs","cids","recursive","cidArr","Array","isArray","hasCids","Promise","all","map","blocks","has","hasAll","every","Error","closerPeerId","getClosestPeers","toBytes","net"],"mappings":"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","sourcesContent":["'use strict'\n\nconst PeerId = require('peer-id')\nconst errCode = require('err-code')\nconst { NotEnabledError } = require('../errors')\nconst get = require('dlv')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\n\n/**\n * @param {Object} config\n * @param {import('../types').NetworkService} config.network\n * @param {import('ipfs-repo').IPFSRepo} config.repo\n */\nmodule.exports = ({ network, repo }) => {\n  const { get, put, findProvs, findPeer, provide, query } = {\n    /**\n     * @type {import('ipfs-core-types/src/dht').API[\"get\"]}\n     */\n    async get (key, options = {}) {\n      const { libp2p } = await use(network, options)\n      return libp2p._dht.get(key, options)\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API[\"put\"]}\n     */\n    async * put (key, value, options) {\n      const { libp2p } = await use(network, options)\n      yield * libp2p._dht.put(key, value)\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API[\"findProvs\"]}\n     */\n    async * findProvs (cid, options = { numProviders: 20 }) {\n      const { libp2p } = await use(network, options)\n\n      for await (const peer of libp2p._dht.findProviders(cid, {\n        maxNumProviders: options.numProviders,\n        signal: options.signal\n      })) {\n        yield {\n          id: peer.id.toB58String(),\n          addrs: peer.addrs\n        }\n      }\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API[\"findPeer\"]}\n     */\n    async findPeer (peerId, options) {\n      const { libp2p } = await use(network, options)\n      const peer = await libp2p._dht.findPeer(PeerId.parse(peerId))\n\n      return {\n        id: peer.id.toB58String(),\n        addrs: peer.multiaddrs\n      }\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API[\"provide\"]}\n     */\n    async * provide (cids, options = { recursive: false }) {\n      const { libp2p } = await use(network, options)\n      const cidArr = Array.isArray(cids) ? cids : [cids]\n\n      // ensure blocks are actually local\n      const hasCids = await Promise.all(cidArr.map(cid => repo.blocks.has(cid)))\n      const hasAll = hasCids.every(has => has)\n\n      if (!hasAll) {\n        throw errCode(new Error('block(s) not found locally, cannot provide'), 'ERR_BLOCK_NOT_FOUND')\n      }\n\n      if (options.recursive) {\n        // TODO: Implement recursive providing\n        throw errCode(new Error('not implemented yet'), 'ERR_NOT_IMPLEMENTED_YET')\n      }\n\n      for (const cid of cidArr) {\n        yield libp2p._dht.provide(cid)\n      }\n    },\n\n    /**\n     * @type {import('ipfs-core-types/src/dht').API[\"query\"]}\n     */\n    async * query (peerId, options) {\n      const { libp2p } = await use(network, options)\n\n      for await (const closerPeerId of libp2p._dht.getClosestPeers(PeerId.parse(peerId).toBytes())) {\n        yield {\n          id: closerPeerId.toB58String(),\n          addrs: [] // TODO: get addrs?\n        }\n      }\n    }\n  }\n\n  return {\n    get: withTimeoutOption(get),\n    put: withTimeoutOption(put),\n    findProvs: withTimeoutOption(findProvs),\n    findPeer: withTimeoutOption(findPeer),\n    provide: withTimeoutOption(provide),\n    query: withTimeoutOption(query)\n  }\n}\n\n/**\n * @param {import('../types').NetworkService} network\n * @param {import('ipfs-core-types/src/utils').AbortOptions} [options]\n */\nconst use = async (network, options) => {\n  const net = await network.use(options)\n  if (get(net.libp2p, '_config.dht.enabled', false)) {\n    return net\n  } else {\n    throw new NotEnabledError('dht not enabled')\n  }\n}\n"]},"metadata":{},"sourceType":"script"}