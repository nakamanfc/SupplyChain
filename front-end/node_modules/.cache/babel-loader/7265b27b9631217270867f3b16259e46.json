{"ast":null,"code":"'use strict';\n\nconst pkgversion = require('../../package.json').version;\n\nconst {\n  Multiaddr\n} = require('multiaddr');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst PeerId = require('peer-id');\n\nconst {\n  NotStartedError\n} = require('../errors');\n/**\n * @param {Object} config\n * @param {import('peer-id')} config.peerId\n * @param {import('../types').NetworkService} config.network\n */\n\n\nmodule.exports = ({\n  peerId,\n  network\n}) => {\n  /**\n   * @type {import('ipfs-core-types/src/root').API[\"id\"]}\n   */\n  async function id(options = {}) {\n    // eslint-disable-line require-await\n    if (options.peerId === peerId.toB58String()) {\n      delete options.peerId;\n    }\n\n    const net = network.try();\n\n    if (!net) {\n      if (options.peerId) {\n        throw new NotStartedError();\n      }\n\n      const idStr = peerId.toB58String();\n      return {\n        id: idStr,\n        publicKey: uint8ArrayToString(peerId.pubKey.bytes, 'base64pad'),\n        addresses: [],\n        agentVersion: `js-ipfs/${pkgversion}`,\n        protocolVersion: '9000',\n        protocols: []\n      };\n    }\n\n    const id = options.peerId ? PeerId.createFromB58String(options.peerId.toString()) : peerId;\n    const {\n      libp2p\n    } = net;\n    const publicKey = options.peerId ? libp2p.peerStore.keyBook.get(id) : id.pubKey;\n    const addresses = options.peerId ? libp2p.peerStore.addressBook.getMultiaddrsForPeer(id) : libp2p.multiaddrs;\n    const protocols = options.peerId ? libp2p.peerStore.protoBook.get(id) : Array.from(libp2p.upgrader.protocols.keys());\n    const agentVersion = uint8ArrayToString(libp2p.peerStore.metadataBook.getValue(id, 'AgentVersion') || new Uint8Array());\n    const protocolVersion = uint8ArrayToString(libp2p.peerStore.metadataBook.getValue(id, 'ProtocolVersion') || new Uint8Array());\n    const idStr = id.toB58String();\n    return {\n      id: idStr,\n      publicKey: uint8ArrayToString(publicKey.bytes, 'base64pad'),\n      addresses: (addresses || []).map(ma => {\n        const str = ma.toString(); // some relay-style transports add our peer id to the ma for us\n        // so don't double-add\n\n        if (str.endsWith(`/p2p/${idStr}`)) {\n          return str;\n        }\n\n        return `${str}/p2p/${idStr}`;\n      }).sort().map(ma => new Multiaddr(ma)),\n      agentVersion,\n      protocolVersion,\n      protocols: (protocols || []).sort()\n    };\n  }\n\n  return withTimeoutOption(id);\n};","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/ipfs-core/src/components/id.js"],"names":["pkgversion","require","version","Multiaddr","withTimeoutOption","toString","uint8ArrayToString","PeerId","NotStartedError","module","exports","peerId","network","id","options","toB58String","net","try","idStr","publicKey","pubKey","bytes","addresses","agentVersion","protocolVersion","protocols","createFromB58String","libp2p","peerStore","keyBook","get","addressBook","getMultiaddrsForPeer","multiaddrs","protoBook","Array","from","upgrader","keys","metadataBook","getValue","Uint8Array","map","ma","str","endsWith","sort"],"mappings":"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","sourcesContent":["'use strict'\n\nconst pkgversion = require('../../package.json').version\nconst { Multiaddr } = require('multiaddr')\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst PeerId = require('peer-id')\nconst { NotStartedError } = require('../errors')\n\n/**\n * @param {Object} config\n * @param {import('peer-id')} config.peerId\n * @param {import('../types').NetworkService} config.network\n */\nmodule.exports = ({ peerId, network }) => {\n  /**\n   * @type {import('ipfs-core-types/src/root').API[\"id\"]}\n   */\n  async function id (options = {}) { // eslint-disable-line require-await\n    if (options.peerId === peerId.toB58String()) {\n      delete options.peerId\n    }\n\n    const net = network.try()\n\n    if (!net) {\n      if (options.peerId) {\n        throw new NotStartedError()\n      }\n\n      const idStr = peerId.toB58String()\n\n      return {\n        id: idStr,\n        publicKey: uint8ArrayToString(peerId.pubKey.bytes, 'base64pad'),\n        addresses: [],\n        agentVersion: `js-ipfs/${pkgversion}`,\n        protocolVersion: '9000',\n        protocols: []\n      }\n    }\n\n    const id = options.peerId ? PeerId.createFromB58String(options.peerId.toString()) : peerId\n    const { libp2p } = net\n\n    const publicKey = options.peerId ? libp2p.peerStore.keyBook.get(id) : id.pubKey\n    const addresses = options.peerId ? libp2p.peerStore.addressBook.getMultiaddrsForPeer(id) : libp2p.multiaddrs\n    const protocols = options.peerId ? libp2p.peerStore.protoBook.get(id) : Array.from(libp2p.upgrader.protocols.keys())\n    const agentVersion = uint8ArrayToString(libp2p.peerStore.metadataBook.getValue(id, 'AgentVersion') || new Uint8Array())\n    const protocolVersion = uint8ArrayToString(libp2p.peerStore.metadataBook.getValue(id, 'ProtocolVersion') || new Uint8Array())\n    const idStr = id.toB58String()\n\n    return {\n      id: idStr,\n      publicKey: uint8ArrayToString(publicKey.bytes, 'base64pad'),\n      addresses: (addresses || [])\n        .map(ma => {\n          const str = ma.toString()\n\n          // some relay-style transports add our peer id to the ma for us\n          // so don't double-add\n          if (str.endsWith(`/p2p/${idStr}`)) {\n            return str\n          }\n\n          return `${str}/p2p/${idStr}`\n        })\n        .sort()\n        .map(ma => new Multiaddr(ma)),\n      agentVersion,\n      protocolVersion,\n      protocols: (protocols || []).sort()\n    }\n  }\n  return withTimeoutOption(id)\n}\n"]},"metadata":{},"sourceType":"script"}