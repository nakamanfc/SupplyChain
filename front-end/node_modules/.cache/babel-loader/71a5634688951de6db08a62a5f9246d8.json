{"ast":null,"code":"'use strict';\n\nconst {\n  Multiaddr\n} = require('multiaddr');\n\nfunction cleanUrlSIO(ma) {\n  const maStrSplit = ma.toString().split('/');\n  const tcpProto = ma.protos()[1].name;\n  const wsProto = ma.protos()[2].name;\n  const tcpPort = ma.stringTuples()[1][1];\n\n  if (tcpProto !== 'tcp' || wsProto !== 'ws' && wsProto !== 'wss') {\n    throw new Error('invalid multiaddr: ' + ma.toString());\n  }\n\n  if (!Multiaddr.isName(ma)) {\n    return 'http://' + maStrSplit[2] + ':' + maStrSplit[4];\n  }\n\n  if (wsProto === 'ws') {\n    return 'http://' + maStrSplit[2] + (tcpPort === '80' ? '' : ':' + tcpPort);\n  }\n\n  if (wsProto === 'wss') {\n    return 'https://' + maStrSplit[2] + (tcpPort === '443' ? '' : ':' + tcpPort);\n  }\n}\n\nfunction cleanMultiaddr(maStr) {\n  const legacy = '/libp2p-webrtc-star';\n\n  if (maStr.indexOf(legacy) !== -1) {\n    maStr = maStr.substring(legacy.length, maStr.length);\n    let ma = new Multiaddr(maStr);\n    const tuppleIPFS = ma.stringTuples().filter(tupple => {\n      return tupple[0] === 421; // ipfs code\n    })[0];\n    ma = ma.decapsulate('p2p');\n    ma = ma.encapsulate('/p2p-webrtc-star');\n    ma = ma.encapsulate(`/p2p/${tuppleIPFS[1]}`);\n    maStr = ma.toString();\n  }\n\n  return maStr;\n}\n\nmodule.exports = {\n  cleanUrlSIO,\n  cleanMultiaddr\n};","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/libp2p-webrtc-star/src/utils.js"],"names":["Multiaddr","require","cleanUrlSIO","ma","maStrSplit","toString","split","tcpProto","protos","name","wsProto","tcpPort","stringTuples","Error","isName","cleanMultiaddr","maStr","legacy","indexOf","substring","length","tuppleIPFS","filter","tupple","decapsulate","encapsulate","module","exports"],"mappings":"AAAA;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAgBC,OAAO,CAAC,WAAD,CAA7B;;AAEA,SAASC,WAAT,CAAsBC,EAAtB,EAA0B;AACxB,QAAMC,UAAU,GAAGD,EAAE,CAACE,QAAH,GAAcC,KAAd,CAAoB,GAApB,CAAnB;AACA,QAAMC,QAAQ,GAAGJ,EAAE,CAACK,MAAH,GAAY,CAAZ,EAAeC,IAAhC;AACA,QAAMC,OAAO,GAAGP,EAAE,CAACK,MAAH,GAAY,CAAZ,EAAeC,IAA/B;AACA,QAAME,OAAO,GAAGR,EAAE,CAACS,YAAH,GAAkB,CAAlB,EAAqB,CAArB,CAAhB;;AAEA,MAAIL,QAAQ,KAAK,KAAb,IAAuBG,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAA3D,EAAmE;AACjE,UAAM,IAAIG,KAAJ,CAAU,wBAAwBV,EAAE,CAACE,QAAH,EAAlC,CAAN;AACD;;AAED,MAAI,CAACL,SAAS,CAACc,MAAV,CAAiBX,EAAjB,CAAL,EAA2B;AACzB,WAAO,YAAYC,UAAU,CAAC,CAAD,CAAtB,GAA4B,GAA5B,GAAkCA,UAAU,CAAC,CAAD,CAAnD;AACD;;AAED,MAAIM,OAAO,KAAK,IAAhB,EAAsB;AACpB,WAAO,YAAYN,UAAU,CAAC,CAAD,CAAtB,IAA6BO,OAAO,KAAK,IAAZ,GAAmB,EAAnB,GAAwB,MAAMA,OAA3D,CAAP;AACD;;AAED,MAAID,OAAO,KAAK,KAAhB,EAAuB;AACrB,WAAO,aAAaN,UAAU,CAAC,CAAD,CAAvB,IAA8BO,OAAO,KAAK,KAAZ,GAAoB,EAApB,GAAyB,MAAMA,OAA7D,CAAP;AACD;AACF;;AAED,SAASI,cAAT,CAAyBC,KAAzB,EAAgC;AAC9B,QAAMC,MAAM,GAAG,qBAAf;;AAEA,MAAID,KAAK,CAACE,OAAN,CAAcD,MAAd,MAA0B,CAAC,CAA/B,EAAkC;AAChCD,IAAAA,KAAK,GAAGA,KAAK,CAACG,SAAN,CAAgBF,MAAM,CAACG,MAAvB,EAA+BJ,KAAK,CAACI,MAArC,CAAR;AACA,QAAIjB,EAAE,GAAG,IAAIH,SAAJ,CAAcgB,KAAd,CAAT;AACA,UAAMK,UAAU,GAAGlB,EAAE,CAACS,YAAH,GAAkBU,MAAlB,CAA0BC,MAAD,IAAY;AACtD,aAAOA,MAAM,CAAC,CAAD,CAAN,KAAc,GAArB,CADsD,CAC7B;AAC1B,KAFkB,EAEhB,CAFgB,CAAnB;AAIApB,IAAAA,EAAE,GAAGA,EAAE,CAACqB,WAAH,CAAe,KAAf,CAAL;AACArB,IAAAA,EAAE,GAAGA,EAAE,CAACsB,WAAH,CAAe,kBAAf,CAAL;AACAtB,IAAAA,EAAE,GAAGA,EAAE,CAACsB,WAAH,CAAgB,QAAOJ,UAAU,CAAC,CAAD,CAAI,EAArC,CAAL;AACAL,IAAAA,KAAK,GAAGb,EAAE,CAACE,QAAH,EAAR;AACD;;AAED,SAAOW,KAAP;AACD;;AAEDU,MAAM,CAACC,OAAP,GAAiB;AACfzB,EAAAA,WADe;AAEfa,EAAAA;AAFe,CAAjB","sourcesContent":["'use strict'\n\nconst { Multiaddr } = require('multiaddr')\n\nfunction cleanUrlSIO (ma) {\n  const maStrSplit = ma.toString().split('/')\n  const tcpProto = ma.protos()[1].name\n  const wsProto = ma.protos()[2].name\n  const tcpPort = ma.stringTuples()[1][1]\n\n  if (tcpProto !== 'tcp' || (wsProto !== 'ws' && wsProto !== 'wss')) {\n    throw new Error('invalid multiaddr: ' + ma.toString())\n  }\n\n  if (!Multiaddr.isName(ma)) {\n    return 'http://' + maStrSplit[2] + ':' + maStrSplit[4]\n  }\n\n  if (wsProto === 'ws') {\n    return 'http://' + maStrSplit[2] + (tcpPort === '80' ? '' : ':' + tcpPort)\n  }\n\n  if (wsProto === 'wss') {\n    return 'https://' + maStrSplit[2] + (tcpPort === '443' ? '' : ':' + tcpPort)\n  }\n}\n\nfunction cleanMultiaddr (maStr) {\n  const legacy = '/libp2p-webrtc-star'\n\n  if (maStr.indexOf(legacy) !== -1) {\n    maStr = maStr.substring(legacy.length, maStr.length)\n    let ma = new Multiaddr(maStr)\n    const tuppleIPFS = ma.stringTuples().filter((tupple) => {\n      return tupple[0] === 421 // ipfs code\n    })[0]\n\n    ma = ma.decapsulate('p2p')\n    ma = ma.encapsulate('/p2p-webrtc-star')\n    ma = ma.encapsulate(`/p2p/${tuppleIPFS[1]}`)\n    maStr = ma.toString()\n  }\n\n  return maStr\n}\n\nmodule.exports = {\n  cleanUrlSIO,\n  cleanMultiaddr\n}\n"]},"metadata":{},"sourceType":"script"}