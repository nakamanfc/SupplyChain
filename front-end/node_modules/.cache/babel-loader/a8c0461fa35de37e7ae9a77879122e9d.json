{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:registrar'), {\n  error: debug('libp2p:registrar:err')\n});\n\nconst errcode = require('err-code');\n\nconst {\n  codes: {\n    ERR_INVALID_PARAMETERS\n  }\n} = require('./errors');\n\nconst Topology = require('libp2p-interfaces/src/topology');\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('./peer-store')} PeerStore\n * @typedef {import('./connection-manager')} ConnectionManager\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('./').HandlerProps} HandlerProps\n */\n\n/**\n *\n */\n\n/**\n * Responsible for notifying registered protocols of events in the network.\n */\n\n\nclass Registrar {\n  /**\n   * @param {Object} props\n   * @param {PeerStore} props.peerStore\n   * @param {ConnectionManager} props.connectionManager\n   * @class\n   */\n  constructor({\n    peerStore,\n    connectionManager\n  }) {\n    // Used on topology to listen for protocol changes\n    this.peerStore = peerStore;\n    this.connectionManager = connectionManager;\n    /**\n     * Map of topologies\n     *\n     * @type {Map<string, Topology>}\n     */\n\n    this.topologies = new Map();\n    /** @type {(protocols: string[]|string, handler: (props: HandlerProps) => void) => void} */\n    // @ts-ignore handle is not optional\n\n    this._handle = undefined;\n    this._onDisconnect = this._onDisconnect.bind(this);\n    this.connectionManager.on('peer:disconnect', this._onDisconnect);\n  }\n  /**\n   * @returns {(protocols: string[]|string, handler: (props: HandlerProps) => void) => void}\n   */\n\n\n  get handle() {\n    return this._handle;\n  }\n  /**\n   * @param {(protocols: string[]|string, handler: (props: HandlerProps) => void) => void} handle\n   */\n\n\n  set handle(handle) {\n    this._handle = handle;\n  }\n  /**\n   * Get a connection with a peer.\n   *\n   * @param {PeerId} peerId\n   * @returns {Connection | null}\n   */\n\n\n  getConnection(peerId) {\n    return this.connectionManager.get(peerId);\n  }\n  /**\n   * Register handlers for a set of multicodecs given\n   *\n   * @param {Topology} topology - protocol topology\n   * @returns {string} registrar identifier\n   */\n\n\n  register(topology) {\n    if (!Topology.isTopology(topology)) {\n      log.error('topology must be an instance of interfaces/topology');\n      throw errcode(new Error('topology must be an instance of interfaces/topology'), ERR_INVALID_PARAMETERS);\n    } // Create topology\n\n\n    const id = (Math.random() * 1e9).toString(36) + Date.now();\n    this.topologies.set(id, topology); // Set registrar\n\n    topology.registrar = this;\n    return id;\n  }\n  /**\n   * Unregister topology.\n   *\n   * @param {string} id - registrar identifier\n   * @returns {boolean} unregistered successfully\n   */\n\n\n  unregister(id) {\n    return this.topologies.delete(id);\n  }\n  /**\n   * Remove a disconnected peer from the record\n   *\n   * @param {Connection} connection\n   * @returns {void}\n   */\n\n\n  _onDisconnect(connection) {\n    for (const [, topology] of this.topologies) {\n      topology.disconnect(connection.remotePeer);\n    }\n  }\n\n}\n\nmodule.exports = Registrar;","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/libp2p/src/registrar.js"],"names":["debug","require","log","Object","assign","error","errcode","codes","ERR_INVALID_PARAMETERS","Topology","Registrar","constructor","peerStore","connectionManager","topologies","Map","_handle","undefined","_onDisconnect","bind","on","handle","getConnection","peerId","get","register","topology","isTopology","Error","id","Math","random","toString","Date","now","set","registrar","unregister","delete","connection","disconnect","remotePeer","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMC,GAAG,GAAGC,MAAM,CAACC,MAAP,CAAcJ,KAAK,CAAC,kBAAD,CAAnB,EAAyC;AACnDK,EAAAA,KAAK,EAAEL,KAAK,CAAC,sBAAD;AADuC,CAAzC,CAAZ;;AAGA,MAAMM,OAAO,GAAGL,OAAO,CAAC,UAAD,CAAvB;;AAEA,MAAM;AACJM,EAAAA,KAAK,EAAE;AAAEC,IAAAA;AAAF;AADH,IAEFP,OAAO,CAAC,UAAD,CAFX;;AAGA,MAAMQ,QAAQ,GAAGR,OAAO,CAAC,gCAAD,CAAxB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AACA,MAAMS,SAAN,CAAgB;AACd;AACF;AACA;AACA;AACA;AACA;AACEC,EAAAA,WAAW,CAAE;AAAEC,IAAAA,SAAF;AAAaC,IAAAA;AAAb,GAAF,EAAoC;AAC7C;AACA,SAAKD,SAAL,GAAiBA,SAAjB;AAEA,SAAKC,iBAAL,GAAyBA,iBAAzB;AAEA;AACJ;AACA;AACA;AACA;;AACI,SAAKC,UAAL,GAAkB,IAAIC,GAAJ,EAAlB;AAEA;AACA;;AACA,SAAKC,OAAL,GAAeC,SAAf;AAEA,SAAKC,aAAL,GAAqB,KAAKA,aAAL,CAAmBC,IAAnB,CAAwB,IAAxB,CAArB;AACA,SAAKN,iBAAL,CAAuBO,EAAvB,CAA0B,iBAA1B,EAA6C,KAAKF,aAAlD;AACD;AAED;AACF;AACA;;;AACY,MAANG,MAAM,GAAI;AACZ,WAAO,KAAKL,OAAZ;AACD;AAED;AACF;AACA;;;AACY,MAANK,MAAM,CAAEA,MAAF,EAAU;AAClB,SAAKL,OAAL,GAAeK,MAAf;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEC,EAAAA,aAAa,CAAEC,MAAF,EAAU;AACrB,WAAO,KAAKV,iBAAL,CAAuBW,GAAvB,CAA2BD,MAA3B,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEE,EAAAA,QAAQ,CAAEC,QAAF,EAAY;AAClB,QAAI,CAACjB,QAAQ,CAACkB,UAAT,CAAoBD,QAApB,CAAL,EAAoC;AAClCxB,MAAAA,GAAG,CAACG,KAAJ,CAAU,qDAAV;AACA,YAAMC,OAAO,CAAC,IAAIsB,KAAJ,CAAU,qDAAV,CAAD,EAAmEpB,sBAAnE,CAAb;AACD,KAJiB,CAMlB;;;AACA,UAAMqB,EAAE,GAAG,CAACC,IAAI,CAACC,MAAL,KAAgB,GAAjB,EAAsBC,QAAtB,CAA+B,EAA/B,IAAqCC,IAAI,CAACC,GAAL,EAAhD;AAEA,SAAKpB,UAAL,CAAgBqB,GAAhB,CAAoBN,EAApB,EAAwBH,QAAxB,EATkB,CAWlB;;AACAA,IAAAA,QAAQ,CAACU,SAAT,GAAqB,IAArB;AAEA,WAAOP,EAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEQ,EAAAA,UAAU,CAAER,EAAF,EAAM;AACd,WAAO,KAAKf,UAAL,CAAgBwB,MAAhB,CAAuBT,EAAvB,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEX,EAAAA,aAAa,CAAEqB,UAAF,EAAc;AACzB,SAAK,MAAM,GAAGb,QAAH,CAAX,IAA2B,KAAKZ,UAAhC,EAA4C;AAC1CY,MAAAA,QAAQ,CAACc,UAAT,CAAoBD,UAAU,CAACE,UAA/B;AACD;AACF;;AA/Fa;;AAkGhBC,MAAM,CAACC,OAAP,GAAiBjC,SAAjB","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = Object.assign(debug('libp2p:registrar'), {\n  error: debug('libp2p:registrar:err')\n})\nconst errcode = require('err-code')\n\nconst {\n  codes: { ERR_INVALID_PARAMETERS }\n} = require('./errors')\nconst Topology = require('libp2p-interfaces/src/topology')\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('./peer-store')} PeerStore\n * @typedef {import('./connection-manager')} ConnectionManager\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('./').HandlerProps} HandlerProps\n */\n\n/**\n *\n */\n\n/**\n * Responsible for notifying registered protocols of events in the network.\n */\nclass Registrar {\n  /**\n   * @param {Object} props\n   * @param {PeerStore} props.peerStore\n   * @param {ConnectionManager} props.connectionManager\n   * @class\n   */\n  constructor ({ peerStore, connectionManager }) {\n    // Used on topology to listen for protocol changes\n    this.peerStore = peerStore\n\n    this.connectionManager = connectionManager\n\n    /**\n     * Map of topologies\n     *\n     * @type {Map<string, Topology>}\n     */\n    this.topologies = new Map()\n\n    /** @type {(protocols: string[]|string, handler: (props: HandlerProps) => void) => void} */\n    // @ts-ignore handle is not optional\n    this._handle = undefined\n\n    this._onDisconnect = this._onDisconnect.bind(this)\n    this.connectionManager.on('peer:disconnect', this._onDisconnect)\n  }\n\n  /**\n   * @returns {(protocols: string[]|string, handler: (props: HandlerProps) => void) => void}\n   */\n  get handle () {\n    return this._handle\n  }\n\n  /**\n   * @param {(protocols: string[]|string, handler: (props: HandlerProps) => void) => void} handle\n   */\n  set handle (handle) {\n    this._handle = handle\n  }\n\n  /**\n   * Get a connection with a peer.\n   *\n   * @param {PeerId} peerId\n   * @returns {Connection | null}\n   */\n  getConnection (peerId) {\n    return this.connectionManager.get(peerId)\n  }\n\n  /**\n   * Register handlers for a set of multicodecs given\n   *\n   * @param {Topology} topology - protocol topology\n   * @returns {string} registrar identifier\n   */\n  register (topology) {\n    if (!Topology.isTopology(topology)) {\n      log.error('topology must be an instance of interfaces/topology')\n      throw errcode(new Error('topology must be an instance of interfaces/topology'), ERR_INVALID_PARAMETERS)\n    }\n\n    // Create topology\n    const id = (Math.random() * 1e9).toString(36) + Date.now()\n\n    this.topologies.set(id, topology)\n\n    // Set registrar\n    topology.registrar = this\n\n    return id\n  }\n\n  /**\n   * Unregister topology.\n   *\n   * @param {string} id - registrar identifier\n   * @returns {boolean} unregistered successfully\n   */\n  unregister (id) {\n    return this.topologies.delete(id)\n  }\n\n  /**\n   * Remove a disconnected peer from the record\n   *\n   * @param {Connection} connection\n   * @returns {void}\n   */\n  _onDisconnect (connection) {\n    for (const [, topology] of this.topologies) {\n      topology.disconnect(connection.remotePeer)\n    }\n  }\n}\n\nmodule.exports = Registrar\n"]},"metadata":{},"sourceType":"script"}