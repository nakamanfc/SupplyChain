{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst {\n  BigNumber: Big\n} = require('bignumber.js');\n\nconst MovingAverage = require('@vascosantos/moving-average');\n\nconst retimer = require('retimer');\n/**\n * @typedef {import('@vascosantos/moving-average').IMovingAverage} IMovingAverage\n */\n\n\nclass Stats extends EventEmitter {\n  /**\n   * A queue based manager for stat processing\n   *\n   * @class\n   * @param {string[]} initialCounters\n   * @param {any} options\n   */\n  constructor(initialCounters, options) {\n    super();\n    this._options = options;\n    this._queue = [];\n    /** @type {{ dataReceived: Big, dataSent: Big }} */\n\n    this._stats = {\n      dataReceived: Big(0),\n      dataSent: Big(0)\n    };\n    this._frequencyLastTime = Date.now();\n    this._frequencyAccumulators = {};\n    /** @type {{ dataReceived: IMovingAverage[], dataSent: IMovingAverage[] }} */\n\n    this._movingAverages = {};\n    this._update = this._update.bind(this);\n    const intervals = this._options.movingAverageIntervals;\n\n    for (let i = 0; i < initialCounters.length; i++) {\n      const key = initialCounters[i];\n      this._stats[key] = Big(0);\n      this._movingAverages[key] = {};\n\n      for (let k = 0; k < intervals.length; k++) {\n        const interval = intervals[k];\n        const ma = this._movingAverages[key][interval] = MovingAverage(interval);\n        ma.push(this._frequencyLastTime, 0);\n      }\n    }\n  }\n  /**\n   * Initializes the internal timer if there are items in the queue. This\n   * should only need to be called if `Stats.stop` was previously called, as\n   * `Stats.push` will also start the processing.\n   *\n   * @returns {void}\n   */\n\n\n  start() {\n    if (this._queue.length) {\n      this._resetComputeTimeout();\n    }\n  }\n  /**\n   * Stops processing and computing of stats by clearing the internal\n   * timer.\n   *\n   * @returns {void}\n   */\n\n\n  stop() {\n    if (this._timeout) {\n      this._timeout.clear();\n\n      this._timeout = null;\n    }\n  }\n  /**\n   * Returns a clone of the current stats.\n   */\n\n\n  get snapshot() {\n    return Object.assign({}, this._stats);\n  }\n  /**\n   * Returns a clone of the internal movingAverages\n   */\n\n\n  get movingAverages() {\n    return Object.assign({}, this._movingAverages);\n  }\n  /**\n   * Returns a plain JSON object of the stats\n   *\n   * @returns {*}\n   */\n\n\n  toJSON() {\n    const snapshot = this.snapshot;\n    const movingAverages = this.movingAverages;\n    const data = {\n      dataReceived: snapshot.dataReceived.toString(),\n      dataSent: snapshot.dataSent.toString(),\n      movingAverages: {}\n    };\n    const counters = Object.keys(movingAverages);\n\n    for (const key of counters) {\n      data.movingAverages[key] = {};\n\n      for (const interval of Object.keys(movingAverages[key])) {\n        data.movingAverages[key][interval] = movingAverages[key][interval].movingAverage();\n      }\n    }\n\n    return data;\n  }\n  /**\n   * Pushes the given operation data to the queue, along with the\n   * current Timestamp, then resets the update timer.\n   *\n   * @param {string} counter\n   * @param {number} inc\n   * @returns {void}\n   */\n\n\n  push(counter, inc) {\n    this._queue.push([counter, inc, Date.now()]);\n\n    this._resetComputeTimeout();\n  }\n  /**\n   * Resets the timeout for triggering updates.\n   *\n   * @private\n   * @returns {void}\n   */\n\n\n  _resetComputeTimeout() {\n    this._timeout = retimer(this._update, this._nextTimeout());\n  }\n  /**\n   * Calculates and returns the timeout for the next update based on\n   * the urgency of the update.\n   *\n   * @private\n   * @returns {number}\n   */\n\n\n  _nextTimeout() {\n    // calculate the need for an update, depending on the queue length\n    const urgency = this._queue.length / this._options.computeThrottleMaxQueueSize;\n    const timeout = Math.max(this._options.computeThrottleTimeout * (1 - urgency), 0);\n    return timeout;\n  }\n  /**\n   * If there are items in the queue, they will will be processed and\n   * the frequency for all items will be updated based on the Timestamp\n   * of the last item in the queue. The `update` event will also be emitted\n   * with the latest stats.\n   *\n   * If there are no items in the queue, no action is taken.\n   *\n   * @private\n   * @returns {void}\n   */\n\n\n  _update() {\n    this._timeout = null;\n\n    if (this._queue.length) {\n      let last;\n\n      for (last of this._queue) {\n        this._applyOp(last);\n      }\n\n      this._queue = [];\n\n      this._updateFrequency(last[2]); // contains timestamp of last op\n\n\n      this.emit('update', this._stats);\n    }\n  }\n  /**\n   * For each key in the stats, the frequency and moving averages\n   * will be updated via Stats._updateFrequencyFor based on the time\n   * difference between calls to this method.\n   *\n   * @private\n   * @param {Timestamp} latestTime\n   * @returns {void}\n   */\n\n\n  _updateFrequency(latestTime) {\n    const timeDiff = latestTime - this._frequencyLastTime;\n    Object.keys(this._stats).forEach(key => {\n      this._updateFrequencyFor(key, timeDiff, latestTime);\n    });\n    this._frequencyLastTime = latestTime;\n  }\n  /**\n   * Updates the `movingAverages` for the given `key` and also\n   * resets the `frequencyAccumulator` for the `key`.\n   *\n   * @private\n   * @param {string} key\n   * @param {number} timeDiffMS - Time in milliseconds\n   * @param {Timestamp} latestTime - Time in ticks\n   * @returns {void}\n   */\n\n\n  _updateFrequencyFor(key, timeDiffMS, latestTime) {\n    const count = this._frequencyAccumulators[key] || 0;\n    this._frequencyAccumulators[key] = 0; // if `timeDiff` is zero, `hz` becomes Infinity, so we fallback to 1ms\n\n    const safeTimeDiff = timeDiffMS || 1;\n    const hz = count / safeTimeDiff * 1000;\n    let movingAverages = this._movingAverages[key];\n\n    if (!movingAverages) {\n      movingAverages = this._movingAverages[key] = {};\n    }\n\n    const intervals = this._options.movingAverageIntervals;\n\n    for (let i = 0; i < intervals.length; i++) {\n      const movingAverageInterval = intervals[i];\n      let movingAverage = movingAverages[movingAverageInterval];\n\n      if (!movingAverage) {\n        movingAverage = movingAverages[movingAverageInterval] = MovingAverage(movingAverageInterval);\n      }\n\n      movingAverage.push(latestTime, hz);\n    }\n  }\n  /**\n   * For the given operation, `op`, the stats and `frequencyAccumulator`\n   * will be updated or initialized if they don't already exist.\n   *\n   * @private\n   * @param {{string, number}[]} op\n   * @throws {InvalidNumber}\n   * @returns {void}\n   */\n\n\n  _applyOp(op) {\n    const key = op[0];\n    const inc = op[1];\n\n    if (typeof inc !== 'number') {\n      throw new Error(`invalid increment number: ${inc}`);\n    }\n\n    let n;\n\n    if (!Object.prototype.hasOwnProperty.call(this._stats, key)) {\n      n = this._stats[key] = Big(0);\n    } else {\n      n = this._stats[key];\n    }\n\n    this._stats[key] = n.plus(inc);\n\n    if (!this._frequencyAccumulators[key]) {\n      this._frequencyAccumulators[key] = 0;\n    }\n\n    this._frequencyAccumulators[key] += inc;\n  }\n\n}\n\nmodule.exports = Stats;","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/libp2p/src/metrics/stats.js"],"names":["EventEmitter","require","BigNumber","Big","MovingAverage","retimer","Stats","constructor","initialCounters","options","_options","_queue","_stats","dataReceived","dataSent","_frequencyLastTime","Date","now","_frequencyAccumulators","_movingAverages","_update","bind","intervals","movingAverageIntervals","i","length","key","k","interval","ma","push","start","_resetComputeTimeout","stop","_timeout","clear","snapshot","Object","assign","movingAverages","toJSON","data","toString","counters","keys","movingAverage","counter","inc","_nextTimeout","urgency","computeThrottleMaxQueueSize","timeout","Math","max","computeThrottleTimeout","last","_applyOp","_updateFrequency","emit","latestTime","timeDiff","forEach","_updateFrequencyFor","timeDiffMS","count","safeTimeDiff","hz","movingAverageInterval","op","Error","n","prototype","hasOwnProperty","call","plus","module","exports"],"mappings":"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","sourcesContent":["// @ts-nocheck\n'use strict'\n\nconst { EventEmitter } = require('events')\nconst { BigNumber: Big } = require('bignumber.js')\nconst MovingAverage = require('@vascosantos/moving-average')\nconst retimer = require('retimer')\n\n/**\n * @typedef {import('@vascosantos/moving-average').IMovingAverage} IMovingAverage\n */\n\nclass Stats extends EventEmitter {\n  /**\n   * A queue based manager for stat processing\n   *\n   * @class\n   * @param {string[]} initialCounters\n   * @param {any} options\n   */\n  constructor (initialCounters, options) {\n    super()\n\n    this._options = options\n    this._queue = []\n\n    /** @type {{ dataReceived: Big, dataSent: Big }} */\n    this._stats = {\n      dataReceived: Big(0),\n      dataSent: Big(0)\n    }\n\n    this._frequencyLastTime = Date.now()\n    this._frequencyAccumulators = {}\n\n    /** @type {{ dataReceived: IMovingAverage[], dataSent: IMovingAverage[] }} */\n    this._movingAverages = {}\n\n    this._update = this._update.bind(this)\n\n    const intervals = this._options.movingAverageIntervals\n\n    for (let i = 0; i < initialCounters.length; i++) {\n      const key = initialCounters[i]\n      this._stats[key] = Big(0)\n      this._movingAverages[key] = {}\n      for (let k = 0; k < intervals.length; k++) {\n        const interval = intervals[k]\n        const ma = this._movingAverages[key][interval] = MovingAverage(interval)\n        ma.push(this._frequencyLastTime, 0)\n      }\n    }\n  }\n\n  /**\n   * Initializes the internal timer if there are items in the queue. This\n   * should only need to be called if `Stats.stop` was previously called, as\n   * `Stats.push` will also start the processing.\n   *\n   * @returns {void}\n   */\n  start () {\n    if (this._queue.length) {\n      this._resetComputeTimeout()\n    }\n  }\n\n  /**\n   * Stops processing and computing of stats by clearing the internal\n   * timer.\n   *\n   * @returns {void}\n   */\n  stop () {\n    if (this._timeout) {\n      this._timeout.clear()\n      this._timeout = null\n    }\n  }\n\n  /**\n   * Returns a clone of the current stats.\n   */\n  get snapshot () {\n    return Object.assign({}, this._stats)\n  }\n\n  /**\n   * Returns a clone of the internal movingAverages\n   */\n  get movingAverages () {\n    return Object.assign({}, this._movingAverages)\n  }\n\n  /**\n   * Returns a plain JSON object of the stats\n   *\n   * @returns {*}\n   */\n  toJSON () {\n    const snapshot = this.snapshot\n    const movingAverages = this.movingAverages\n    const data = {\n      dataReceived: snapshot.dataReceived.toString(),\n      dataSent: snapshot.dataSent.toString(),\n      movingAverages: {}\n    }\n\n    const counters = Object.keys(movingAverages)\n    for (const key of counters) {\n      data.movingAverages[key] = {}\n      for (const interval of Object.keys(movingAverages[key])) {\n        data.movingAverages[key][interval] = movingAverages[key][interval].movingAverage()\n      }\n    }\n\n    return data\n  }\n\n  /**\n   * Pushes the given operation data to the queue, along with the\n   * current Timestamp, then resets the update timer.\n   *\n   * @param {string} counter\n   * @param {number} inc\n   * @returns {void}\n   */\n  push (counter, inc) {\n    this._queue.push([counter, inc, Date.now()])\n    this._resetComputeTimeout()\n  }\n\n  /**\n   * Resets the timeout for triggering updates.\n   *\n   * @private\n   * @returns {void}\n   */\n  _resetComputeTimeout () {\n    this._timeout = retimer(this._update, this._nextTimeout())\n  }\n\n  /**\n   * Calculates and returns the timeout for the next update based on\n   * the urgency of the update.\n   *\n   * @private\n   * @returns {number}\n   */\n  _nextTimeout () {\n    // calculate the need for an update, depending on the queue length\n    const urgency = this._queue.length / this._options.computeThrottleMaxQueueSize\n    const timeout = Math.max(this._options.computeThrottleTimeout * (1 - urgency), 0)\n    return timeout\n  }\n\n  /**\n   * If there are items in the queue, they will will be processed and\n   * the frequency for all items will be updated based on the Timestamp\n   * of the last item in the queue. The `update` event will also be emitted\n   * with the latest stats.\n   *\n   * If there are no items in the queue, no action is taken.\n   *\n   * @private\n   * @returns {void}\n   */\n  _update () {\n    this._timeout = null\n    if (this._queue.length) {\n      let last\n      for (last of this._queue) {\n        this._applyOp(last)\n      }\n      this._queue = []\n\n      this._updateFrequency(last[2]) // contains timestamp of last op\n\n      this.emit('update', this._stats)\n    }\n  }\n\n  /**\n   * For each key in the stats, the frequency and moving averages\n   * will be updated via Stats._updateFrequencyFor based on the time\n   * difference between calls to this method.\n   *\n   * @private\n   * @param {Timestamp} latestTime\n   * @returns {void}\n   */\n  _updateFrequency (latestTime) {\n    const timeDiff = latestTime - this._frequencyLastTime\n\n    Object.keys(this._stats).forEach((key) => {\n      this._updateFrequencyFor(key, timeDiff, latestTime)\n    })\n\n    this._frequencyLastTime = latestTime\n  }\n\n  /**\n   * Updates the `movingAverages` for the given `key` and also\n   * resets the `frequencyAccumulator` for the `key`.\n   *\n   * @private\n   * @param {string} key\n   * @param {number} timeDiffMS - Time in milliseconds\n   * @param {Timestamp} latestTime - Time in ticks\n   * @returns {void}\n   */\n  _updateFrequencyFor (key, timeDiffMS, latestTime) {\n    const count = this._frequencyAccumulators[key] || 0\n    this._frequencyAccumulators[key] = 0\n    // if `timeDiff` is zero, `hz` becomes Infinity, so we fallback to 1ms\n    const safeTimeDiff = timeDiffMS || 1\n    const hz = (count / safeTimeDiff) * 1000\n\n    let movingAverages = this._movingAverages[key]\n    if (!movingAverages) {\n      movingAverages = this._movingAverages[key] = {}\n    }\n\n    const intervals = this._options.movingAverageIntervals\n\n    for (let i = 0; i < intervals.length; i++) {\n      const movingAverageInterval = intervals[i]\n      let movingAverage = movingAverages[movingAverageInterval]\n      if (!movingAverage) {\n        movingAverage = movingAverages[movingAverageInterval] = MovingAverage(movingAverageInterval)\n      }\n      movingAverage.push(latestTime, hz)\n    }\n  }\n\n  /**\n   * For the given operation, `op`, the stats and `frequencyAccumulator`\n   * will be updated or initialized if they don't already exist.\n   *\n   * @private\n   * @param {{string, number}[]} op\n   * @throws {InvalidNumber}\n   * @returns {void}\n   */\n  _applyOp (op) {\n    const key = op[0]\n    const inc = op[1]\n\n    if (typeof inc !== 'number') {\n      throw new Error(`invalid increment number: ${inc}`)\n    }\n\n    let n\n\n    if (!Object.prototype.hasOwnProperty.call(this._stats, key)) {\n      n = this._stats[key] = Big(0)\n    } else {\n      n = this._stats[key]\n    }\n    this._stats[key] = n.plus(inc)\n\n    if (!this._frequencyAccumulators[key]) {\n      this._frequencyAccumulators[key] = 0\n    }\n    this._frequencyAccumulators[key] += inc\n  }\n}\n\nmodule.exports = Stats\n"]},"metadata":{},"sourceType":"script"}