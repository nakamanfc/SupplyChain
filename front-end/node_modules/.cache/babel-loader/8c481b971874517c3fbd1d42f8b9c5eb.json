{"ast":null,"code":"'use strict';\n\nconst {\n  CID\n} = require('multiformats/cid');\n\nconst log = require('debug')('ipfs:repo:gc');\n\nconst {\n  Errors\n} = require('interface-datastore');\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code;\n\nconst parallelBatch = require('it-parallel-batch');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst merge = require('it-merge');\n\nconst map = require('it-map');\n\nconst filter = require('it-filter');\n\nconst {\n  Key\n} = require('interface-datastore');\n\nconst {\n  base32\n} = require('multiformats/bases/base32');\n\nconst walkDag = require('./utils/walk-dag'); // Limit on the number of parallel block remove operations\n\n\nconst BLOCK_RM_CONCURRENCY = 256;\nconst MFS_ROOT_KEY = new Key('/local/filesroot');\n/**\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('./types').loadCodec} loadCodec\n * @typedef {import('./types').GCErrorResult} GCErrorResult\n * @typedef {import('./types').GCSuccessResult} GCSuccessResult\n */\n\n/**\n * Perform mark and sweep garbage collection\n *\n * @param {object} config\n * @param {import('./types').GCLock} config.gcLock\n * @param {import('./pins').Pins} config.pins\n * @param {Blockstore} config.blockstore\n * @param {import('interface-datastore').Datastore} config.root\n * @param {loadCodec} config.loadCodec\n */\n\nmodule.exports = ({\n  gcLock,\n  pins,\n  blockstore,\n  root,\n  loadCodec\n}) => {\n  /**\n   * @returns {AsyncGenerator<GCErrorResult | GCSuccessResult, void, unknown>}\n   */\n  async function* gc() {\n    const start = Date.now();\n    log('Creating set of marked blocks');\n    const release = await gcLock.writeLock();\n\n    try {\n      // Mark all blocks that are being used\n      const markedSet = await createMarkedSet({\n        pins,\n        blockstore,\n        root,\n        loadCodec\n      }); // Get all blocks keys from the blockstore\n\n      const blockKeys = blockstore.queryKeys({}); // Delete blocks that are not being used\n      // @ts-ignore ts cannot tell that we filter out null results\n\n      yield* deleteUnmarkedBlocks({\n        blockstore\n      }, markedSet, blockKeys);\n      log(`Complete (${Date.now() - start}ms)`);\n    } finally {\n      release();\n    }\n  }\n\n  return gc;\n};\n/**\n * Get Set of CIDs of blocks to keep\n *\n * @param {object} config\n * @param {import('./pins').Pins} config.pins\n * @param {import('interface-blockstore').Blockstore} config.blockstore\n * @param {import('interface-datastore').Datastore} config.root\n * @param {loadCodec} config.loadCodec\n */\n\n\nasync function createMarkedSet({\n  pins,\n  blockstore,\n  loadCodec,\n  root\n}) {\n  const mfsSource = async function* () {\n    let mh;\n\n    try {\n      mh = await root.get(MFS_ROOT_KEY);\n    } catch (err) {\n      if (err.code === ERR_NOT_FOUND) {\n        log('No blocks in MFS');\n        return;\n      }\n\n      throw err;\n    }\n\n    const rootCid = CID.decode(mh);\n    yield rootCid;\n    yield* walkDag(rootCid, blockstore, loadCodec);\n  }();\n\n  const pinsSource = merge(map(pins.recursiveKeys(), ({\n    cid\n  }) => cid), pins.indirectKeys(), map(pins.directKeys(), ({\n    cid\n  }) => cid), mfsSource);\n  const output = new Set();\n\n  for await (const cid of merge(pinsSource, mfsSource)) {\n    output.add(base32.encode(cid.multihash.bytes));\n  }\n\n  return output;\n}\n/**\n * Delete all blocks that are not marked as in use\n *\n * @param {object} arg\n * @param {Blockstore} arg.blockstore\n * @param {Set<string>} markedSet\n * @param {AsyncIterable<CID>} blockKeys\n */\n\n\nasync function* deleteUnmarkedBlocks({\n  blockstore\n}, markedSet, blockKeys) {\n  // Iterate through all blocks and find those that are not in the marked set\n  // blockKeys yields { key: Key() }\n  let blocksCount = 0;\n  let removedBlocksCount = 0;\n  /**\n   * @param {CID} cid\n   */\n\n  const removeBlock = async cid => {\n    return async function remove() {\n      blocksCount++;\n\n      try {\n        const b32 = base32.encode(cid.multihash.bytes);\n\n        if (markedSet.has(b32)) {\n          return null;\n        }\n\n        try {\n          await blockstore.delete(cid);\n          removedBlocksCount++;\n        } catch (err) {\n          return {\n            err: new Error(`Could not delete block with CID ${cid}: ${err.message}`)\n          };\n        }\n\n        return {\n          cid\n        };\n      } catch (err) {\n        const msg = `Could delete block with CID ${cid}`;\n        log(msg, err);\n        return {\n          err: new Error(msg + `: ${err.message}`)\n        };\n      }\n    };\n  };\n\n  yield* pipe(parallelBatch(map(blockKeys, removeBlock), BLOCK_RM_CONCURRENCY), // filter nulls (blocks that were retained)\n  source => filter(source, Boolean));\n  log(`Marked set has ${markedSet.size} unique blocks. Blockstore has ${blocksCount} blocks. ` + `Deleted ${removedBlocksCount} blocks.`);\n}","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/ipfs-repo/src/gc.js"],"names":["CID","require","log","Errors","ERR_NOT_FOUND","notFoundError","code","parallelBatch","pipe","merge","map","filter","Key","base32","walkDag","BLOCK_RM_CONCURRENCY","MFS_ROOT_KEY","module","exports","gcLock","pins","blockstore","root","loadCodec","gc","start","Date","now","release","writeLock","markedSet","createMarkedSet","blockKeys","queryKeys","deleteUnmarkedBlocks","mfsSource","mh","get","err","rootCid","decode","pinsSource","recursiveKeys","cid","indirectKeys","directKeys","output","Set","add","encode","multihash","bytes","blocksCount","removedBlocksCount","removeBlock","remove","b32","has","delete","Error","message","msg","source","Boolean","size"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { CID } = require('multiformats/cid')\nconst log = require('debug')('ipfs:repo:gc')\nconst { Errors } = require('interface-datastore')\nconst ERR_NOT_FOUND = Errors.notFoundError().code\nconst parallelBatch = require('it-parallel-batch')\nconst { pipe } = require('it-pipe')\nconst merge = require('it-merge')\nconst map = require('it-map')\nconst filter = require('it-filter')\nconst { Key } = require('interface-datastore')\nconst { base32 } = require('multiformats/bases/base32')\nconst walkDag = require('./utils/walk-dag')\n\n// Limit on the number of parallel block remove operations\nconst BLOCK_RM_CONCURRENCY = 256\n\nconst MFS_ROOT_KEY = new Key('/local/filesroot')\n\n/**\n * @typedef {import('interface-blockstore').Blockstore} Blockstore\n * @typedef {import('./types').loadCodec} loadCodec\n * @typedef {import('./types').GCErrorResult} GCErrorResult\n * @typedef {import('./types').GCSuccessResult} GCSuccessResult\n */\n\n/**\n * Perform mark and sweep garbage collection\n *\n * @param {object} config\n * @param {import('./types').GCLock} config.gcLock\n * @param {import('./pins').Pins} config.pins\n * @param {Blockstore} config.blockstore\n * @param {import('interface-datastore').Datastore} config.root\n * @param {loadCodec} config.loadCodec\n */\nmodule.exports = ({ gcLock, pins, blockstore, root, loadCodec }) => {\n  /**\n   * @returns {AsyncGenerator<GCErrorResult | GCSuccessResult, void, unknown>}\n   */\n  async function * gc () {\n    const start = Date.now()\n    log('Creating set of marked blocks')\n\n    const release = await gcLock.writeLock()\n\n    try {\n      // Mark all blocks that are being used\n      const markedSet = await createMarkedSet({ pins, blockstore, root, loadCodec })\n      // Get all blocks keys from the blockstore\n      const blockKeys = blockstore.queryKeys({})\n\n      // Delete blocks that are not being used\n      // @ts-ignore ts cannot tell that we filter out null results\n      yield * deleteUnmarkedBlocks({ blockstore }, markedSet, blockKeys)\n\n      log(`Complete (${Date.now() - start}ms)`)\n    } finally {\n      release()\n    }\n  }\n\n  return gc\n}\n\n/**\n * Get Set of CIDs of blocks to keep\n *\n * @param {object} config\n * @param {import('./pins').Pins} config.pins\n * @param {import('interface-blockstore').Blockstore} config.blockstore\n * @param {import('interface-datastore').Datastore} config.root\n * @param {loadCodec} config.loadCodec\n */\nasync function createMarkedSet ({ pins, blockstore, loadCodec, root }) {\n  const mfsSource = (async function * () {\n    let mh\n    try {\n      mh = await root.get(MFS_ROOT_KEY)\n    } catch (err) {\n      if (err.code === ERR_NOT_FOUND) {\n        log('No blocks in MFS')\n        return\n      }\n\n      throw err\n    }\n\n    const rootCid = CID.decode(mh)\n    yield rootCid\n    yield * walkDag(rootCid, blockstore, loadCodec)\n  })()\n\n  const pinsSource = merge(\n    map(pins.recursiveKeys(), ({ cid }) => cid),\n    pins.indirectKeys(),\n    map(pins.directKeys(), ({ cid }) => cid),\n    mfsSource\n  )\n\n  const output = new Set()\n\n  for await (const cid of merge(pinsSource, mfsSource)) {\n    output.add(base32.encode(cid.multihash.bytes))\n  }\n\n  return output\n}\n\n/**\n * Delete all blocks that are not marked as in use\n *\n * @param {object} arg\n * @param {Blockstore} arg.blockstore\n * @param {Set<string>} markedSet\n * @param {AsyncIterable<CID>} blockKeys\n */\nasync function * deleteUnmarkedBlocks ({ blockstore }, markedSet, blockKeys) {\n  // Iterate through all blocks and find those that are not in the marked set\n  // blockKeys yields { key: Key() }\n  let blocksCount = 0\n  let removedBlocksCount = 0\n\n  /**\n   * @param {CID} cid\n   */\n  const removeBlock = async (cid) => {\n    return async function remove () {\n      blocksCount++\n\n      try {\n        const b32 = base32.encode(cid.multihash.bytes)\n\n        if (markedSet.has(b32)) {\n          return null\n        }\n\n        try {\n          await blockstore.delete(cid)\n          removedBlocksCount++\n        } catch (err) {\n          return {\n            err: new Error(`Could not delete block with CID ${cid}: ${err.message}`)\n          }\n        }\n\n        return { cid }\n      } catch (err) {\n        const msg = `Could delete block with CID ${cid}`\n        log(msg, err)\n        return { err: new Error(msg + `: ${err.message}`) }\n      }\n    }\n  }\n\n  yield * pipe(\n    parallelBatch(map(blockKeys, removeBlock), BLOCK_RM_CONCURRENCY),\n    // filter nulls (blocks that were retained)\n    source => filter(source, Boolean)\n  )\n\n  log(`Marked set has ${markedSet.size} unique blocks. Blockstore has ${blocksCount} blocks. ` +\n  `Deleted ${removedBlocksCount} blocks.`)\n}\n"]},"metadata":{},"sourceType":"script"}