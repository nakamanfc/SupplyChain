{"ast":null,"code":"'use strict';\n\nconst inherits = require('inherits');\n\nconst AbstractIterator = require('abstract-leveldown').AbstractIterator;\n\nconst createKeyRange = require('./util/key-range');\n\nconst deserialize = require('./util/deserialize');\n\nconst noop = function () {};\n\nmodule.exports = Iterator;\n\nfunction Iterator(db, location, options) {\n  AbstractIterator.call(this, db);\n  this._limit = options.limit;\n  this._count = 0;\n  this._callback = null;\n  this._cache = [];\n  this._completed = false;\n  this._aborted = false;\n  this._error = null;\n  this._transaction = null;\n  this._keys = options.keys;\n  this._values = options.values;\n  this._keyAsBuffer = options.keyAsBuffer;\n  this._valueAsBuffer = options.valueAsBuffer;\n\n  if (this._limit === 0) {\n    this._completed = true;\n    return;\n  }\n\n  let keyRange;\n\n  try {\n    keyRange = createKeyRange(options);\n  } catch (e) {\n    // The lower key is greater than the upper key.\n    // IndexedDB throws an error, but we'll just return 0 results.\n    this._completed = true;\n    return;\n  }\n\n  this.createIterator(location, keyRange, options.reverse);\n}\n\ninherits(Iterator, AbstractIterator);\n\nIterator.prototype.createIterator = function (location, keyRange, reverse) {\n  const transaction = this.db.db.transaction([location], 'readonly');\n  const store = transaction.objectStore(location);\n  const req = store.openCursor(keyRange, reverse ? 'prev' : 'next');\n\n  req.onsuccess = ev => {\n    const cursor = ev.target.result;\n    if (cursor) this.onItem(cursor);\n  };\n\n  this._transaction = transaction; // If an error occurs (on the request), the transaction will abort.\n\n  transaction.onabort = () => {\n    this.onAbort(this._transaction.error || new Error('aborted by user'));\n  };\n\n  transaction.oncomplete = () => {\n    this.onComplete();\n  };\n};\n\nIterator.prototype.onItem = function (cursor) {\n  this._cache.push(cursor.key, cursor.value);\n\n  if (this._limit <= 0 || ++this._count < this._limit) {\n    cursor.continue();\n  }\n\n  this.maybeNext();\n};\n\nIterator.prototype.onAbort = function (err) {\n  this._aborted = true;\n  this._error = err;\n  this.maybeNext();\n};\n\nIterator.prototype.onComplete = function () {\n  this._completed = true;\n  this.maybeNext();\n};\n\nIterator.prototype.maybeNext = function () {\n  if (this._callback) {\n    this._next(this._callback);\n\n    this._callback = null;\n  }\n};\n\nIterator.prototype._next = function (callback) {\n  if (this._aborted) {\n    // The error should be picked up by either next() or end().\n    const err = this._error;\n    this._error = null;\n\n    this._nextTick(callback, err);\n  } else if (this._cache.length > 0) {\n    let key = this._cache.shift();\n\n    let value = this._cache.shift();\n\n    if (this._keys && key !== undefined) {\n      key = this._deserializeKey(key, this._keyAsBuffer);\n    } else {\n      key = undefined;\n    }\n\n    if (this._values && value !== undefined) {\n      value = this._deserializeValue(value, this._valueAsBuffer);\n    } else {\n      value = undefined;\n    }\n\n    this._nextTick(callback, null, key, value);\n  } else if (this._completed) {\n    this._nextTick(callback);\n  } else {\n    this._callback = callback;\n  }\n}; // Exposed for the v4 to v5 upgrade utility\n\n\nIterator.prototype._deserializeKey = deserialize;\nIterator.prototype._deserializeValue = deserialize;\n\nIterator.prototype._end = function (callback) {\n  if (this._aborted || this._completed) {\n    return this._nextTick(callback, this._error);\n  } // Don't advance the cursor anymore, and the transaction will complete\n  // on its own in the next tick. This approach is much cleaner than calling\n  // transaction.abort() with its unpredictable event order.\n\n\n  this.onItem = noop;\n  this.onAbort = callback;\n  this.onComplete = callback;\n};","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/level-js/iterator.js"],"names":["inherits","require","AbstractIterator","createKeyRange","deserialize","noop","module","exports","Iterator","db","location","options","call","_limit","limit","_count","_callback","_cache","_completed","_aborted","_error","_transaction","_keys","keys","_values","values","_keyAsBuffer","keyAsBuffer","_valueAsBuffer","valueAsBuffer","keyRange","e","createIterator","reverse","prototype","transaction","store","objectStore","req","openCursor","onsuccess","ev","cursor","target","result","onItem","onabort","onAbort","error","Error","oncomplete","onComplete","push","key","value","continue","maybeNext","err","_next","callback","_nextTick","length","shift","undefined","_deserializeKey","_deserializeValue","_end"],"mappings":"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","sourcesContent":["'use strict'\n\nconst inherits = require('inherits')\nconst AbstractIterator = require('abstract-leveldown').AbstractIterator\nconst createKeyRange = require('./util/key-range')\nconst deserialize = require('./util/deserialize')\nconst noop = function () {}\n\nmodule.exports = Iterator\n\nfunction Iterator (db, location, options) {\n  AbstractIterator.call(this, db)\n\n  this._limit = options.limit\n  this._count = 0\n  this._callback = null\n  this._cache = []\n  this._completed = false\n  this._aborted = false\n  this._error = null\n  this._transaction = null\n\n  this._keys = options.keys\n  this._values = options.values\n  this._keyAsBuffer = options.keyAsBuffer\n  this._valueAsBuffer = options.valueAsBuffer\n\n  if (this._limit === 0) {\n    this._completed = true\n    return\n  }\n\n  let keyRange\n\n  try {\n    keyRange = createKeyRange(options)\n  } catch (e) {\n    // The lower key is greater than the upper key.\n    // IndexedDB throws an error, but we'll just return 0 results.\n    this._completed = true\n    return\n  }\n\n  this.createIterator(location, keyRange, options.reverse)\n}\n\ninherits(Iterator, AbstractIterator)\n\nIterator.prototype.createIterator = function (location, keyRange, reverse) {\n  const transaction = this.db.db.transaction([location], 'readonly')\n  const store = transaction.objectStore(location)\n  const req = store.openCursor(keyRange, reverse ? 'prev' : 'next')\n\n  req.onsuccess = (ev) => {\n    const cursor = ev.target.result\n    if (cursor) this.onItem(cursor)\n  }\n\n  this._transaction = transaction\n\n  // If an error occurs (on the request), the transaction will abort.\n  transaction.onabort = () => {\n    this.onAbort(this._transaction.error || new Error('aborted by user'))\n  }\n\n  transaction.oncomplete = () => {\n    this.onComplete()\n  }\n}\n\nIterator.prototype.onItem = function (cursor) {\n  this._cache.push(cursor.key, cursor.value)\n\n  if (this._limit <= 0 || ++this._count < this._limit) {\n    cursor.continue()\n  }\n\n  this.maybeNext()\n}\n\nIterator.prototype.onAbort = function (err) {\n  this._aborted = true\n  this._error = err\n  this.maybeNext()\n}\n\nIterator.prototype.onComplete = function () {\n  this._completed = true\n  this.maybeNext()\n}\n\nIterator.prototype.maybeNext = function () {\n  if (this._callback) {\n    this._next(this._callback)\n    this._callback = null\n  }\n}\n\nIterator.prototype._next = function (callback) {\n  if (this._aborted) {\n    // The error should be picked up by either next() or end().\n    const err = this._error\n    this._error = null\n    this._nextTick(callback, err)\n  } else if (this._cache.length > 0) {\n    let key = this._cache.shift()\n    let value = this._cache.shift()\n\n    if (this._keys && key !== undefined) {\n      key = this._deserializeKey(key, this._keyAsBuffer)\n    } else {\n      key = undefined\n    }\n\n    if (this._values && value !== undefined) {\n      value = this._deserializeValue(value, this._valueAsBuffer)\n    } else {\n      value = undefined\n    }\n\n    this._nextTick(callback, null, key, value)\n  } else if (this._completed) {\n    this._nextTick(callback)\n  } else {\n    this._callback = callback\n  }\n}\n\n// Exposed for the v4 to v5 upgrade utility\nIterator.prototype._deserializeKey = deserialize\nIterator.prototype._deserializeValue = deserialize\n\nIterator.prototype._end = function (callback) {\n  if (this._aborted || this._completed) {\n    return this._nextTick(callback, this._error)\n  }\n\n  // Don't advance the cursor anymore, and the transaction will complete\n  // on its own in the next tick. This approach is much cleaner than calling\n  // transaction.abort() with its unpredictable event order.\n  this.onItem = noop\n  this.onAbort = callback\n  this.onComplete = callback\n}\n"]},"metadata":{},"sourceType":"script"}