{"ast":null,"code":"'use strict';\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst {\n  Multiaddr\n} = require('multiaddr');\n\nconst PeerId = require('peer-id');\n/**\n * @typedef {Object} AddressManagerOptions\n * @property {string[]} [listen = []] - list of multiaddrs string representation to listen.\n * @property {string[]} [announce = []] - list of multiaddrs string representation to announce.\n */\n\n/**\n * @fires AddressManager#change:addresses Emitted when a addresses change.\n */\n\n\nclass AddressManager extends EventEmitter {\n  /**\n   * Responsible for managing the peer addresses.\n   * Peers can specify their listen and announce addresses.\n   * The listen addresses will be used by the libp2p transports to listen for new connections,\n   * while the announce addresses will be used for the peer addresses' to other peers in the network.\n   *\n   * @class\n   * @param {PeerId} peerId - The Peer ID of the node\n   * @param {object} [options]\n   * @param {Array<string>} [options.listen = []] - list of multiaddrs string representation to listen.\n   * @param {Array<string>} [options.announce = []] - list of multiaddrs string representation to announce.\n   */\n  constructor(peerId, {\n    listen = [],\n    announce = []\n  } = {}) {\n    super();\n    this.peerId = peerId;\n    this.listen = new Set(listen.map(ma => ma.toString()));\n    this.announce = new Set(announce.map(ma => ma.toString()));\n    this.observed = new Set();\n  }\n  /**\n   * Get peer listen multiaddrs.\n   *\n   * @returns {Multiaddr[]}\n   */\n\n\n  getListenAddrs() {\n    return Array.from(this.listen).map(a => new Multiaddr(a));\n  }\n  /**\n   * Get peer announcing multiaddrs.\n   *\n   * @returns {Multiaddr[]}\n   */\n\n\n  getAnnounceAddrs() {\n    return Array.from(this.announce).map(a => new Multiaddr(a));\n  }\n  /**\n   * Get observed multiaddrs.\n   *\n   * @returns {Array<Multiaddr>}\n   */\n\n\n  getObservedAddrs() {\n    return Array.from(this.observed).map(a => new Multiaddr(a));\n  }\n  /**\n   * Add peer observed addresses\n   *\n   * @param {string | Multiaddr} addr\n   */\n\n\n  addObservedAddr(addr) {\n    let ma = new Multiaddr(addr);\n    const remotePeer = ma.getPeerId(); // strip our peer id if it has been passed\n\n    if (remotePeer) {\n      const remotePeerId = PeerId.createFromB58String(remotePeer); // use same encoding for comparison\n\n      if (remotePeerId.equals(this.peerId)) {\n        ma = ma.decapsulate(new Multiaddr(`/p2p/${this.peerId}`));\n      }\n    }\n\n    const addrString = ma.toString(); // do not trigger the change:addresses event if we already know about this address\n\n    if (this.observed.has(addrString)) {\n      return;\n    }\n\n    this.observed.add(addrString);\n    this.emit('change:addresses');\n  }\n\n}\n\nmodule.exports = AddressManager;","map":{"version":3,"sources":["C:/Users/user/mew-supplychain/front-end/node_modules/libp2p/src/address-manager/index.js"],"names":["EventEmitter","require","Multiaddr","PeerId","AddressManager","constructor","peerId","listen","announce","Set","map","ma","toString","observed","getListenAddrs","Array","from","a","getAnnounceAddrs","getObservedAddrs","addObservedAddr","addr","remotePeer","getPeerId","remotePeerId","createFromB58String","equals","decapsulate","addrString","has","add","emit","module","exports"],"mappings":"AAAA;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAmBC,OAAO,CAAC,QAAD,CAAhC;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAgBD,OAAO,CAAC,WAAD,CAA7B;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,SAAD,CAAtB;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AACA,MAAMG,cAAN,SAA6BJ,YAA7B,CAA0C;AACxC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEK,EAAAA,WAAW,CAAEC,MAAF,EAAU;AAAEC,IAAAA,MAAM,GAAG,EAAX;AAAeC,IAAAA,QAAQ,GAAG;AAA1B,MAAiC,EAA3C,EAA+C;AACxD;AAEA,SAAKF,MAAL,GAAcA,MAAd;AACA,SAAKC,MAAL,GAAc,IAAIE,GAAJ,CAAQF,MAAM,CAACG,GAAP,CAAWC,EAAE,IAAIA,EAAE,CAACC,QAAH,EAAjB,CAAR,CAAd;AACA,SAAKJ,QAAL,GAAgB,IAAIC,GAAJ,CAAQD,QAAQ,CAACE,GAAT,CAAaC,EAAE,IAAIA,EAAE,CAACC,QAAH,EAAnB,CAAR,CAAhB;AACA,SAAKC,QAAL,GAAgB,IAAIJ,GAAJ,EAAhB;AACD;AAED;AACF;AACA;AACA;AACA;;;AACEK,EAAAA,cAAc,GAAI;AAChB,WAAOC,KAAK,CAACC,IAAN,CAAW,KAAKT,MAAhB,EAAwBG,GAAxB,CAA6BO,CAAD,IAAO,IAAIf,SAAJ,CAAce,CAAd,CAAnC,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AACEC,EAAAA,gBAAgB,GAAI;AAClB,WAAOH,KAAK,CAACC,IAAN,CAAW,KAAKR,QAAhB,EAA0BE,GAA1B,CAA+BO,CAAD,IAAO,IAAIf,SAAJ,CAAce,CAAd,CAArC,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AACEE,EAAAA,gBAAgB,GAAI;AAClB,WAAOJ,KAAK,CAACC,IAAN,CAAW,KAAKH,QAAhB,EAA0BH,GAA1B,CAA+BO,CAAD,IAAO,IAAIf,SAAJ,CAAce,CAAd,CAArC,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AACEG,EAAAA,eAAe,CAAEC,IAAF,EAAQ;AACrB,QAAIV,EAAE,GAAG,IAAIT,SAAJ,CAAcmB,IAAd,CAAT;AACA,UAAMC,UAAU,GAAGX,EAAE,CAACY,SAAH,EAAnB,CAFqB,CAIrB;;AACA,QAAID,UAAJ,EAAgB;AACd,YAAME,YAAY,GAAGrB,MAAM,CAACsB,mBAAP,CAA2BH,UAA3B,CAArB,CADc,CAGd;;AACA,UAAIE,YAAY,CAACE,MAAb,CAAoB,KAAKpB,MAAzB,CAAJ,EAAsC;AACpCK,QAAAA,EAAE,GAAGA,EAAE,CAACgB,WAAH,CAAe,IAAIzB,SAAJ,CAAe,QAAO,KAAKI,MAAO,EAAlC,CAAf,CAAL;AACD;AACF;;AAED,UAAMsB,UAAU,GAAGjB,EAAE,CAACC,QAAH,EAAnB,CAdqB,CAgBrB;;AACA,QAAI,KAAKC,QAAL,CAAcgB,GAAd,CAAkBD,UAAlB,CAAJ,EAAmC;AACjC;AACD;;AAED,SAAKf,QAAL,CAAciB,GAAd,CAAkBF,UAAlB;AACA,SAAKG,IAAL,CAAU,kBAAV;AACD;;AA7EuC;;AAgF1CC,MAAM,CAACC,OAAP,GAAiB7B,cAAjB","sourcesContent":["'use strict'\n\nconst { EventEmitter } = require('events')\nconst { Multiaddr } = require('multiaddr')\nconst PeerId = require('peer-id')\n\n/**\n * @typedef {Object} AddressManagerOptions\n * @property {string[]} [listen = []] - list of multiaddrs string representation to listen.\n * @property {string[]} [announce = []] - list of multiaddrs string representation to announce.\n */\n\n/**\n * @fires AddressManager#change:addresses Emitted when a addresses change.\n */\nclass AddressManager extends EventEmitter {\n  /**\n   * Responsible for managing the peer addresses.\n   * Peers can specify their listen and announce addresses.\n   * The listen addresses will be used by the libp2p transports to listen for new connections,\n   * while the announce addresses will be used for the peer addresses' to other peers in the network.\n   *\n   * @class\n   * @param {PeerId} peerId - The Peer ID of the node\n   * @param {object} [options]\n   * @param {Array<string>} [options.listen = []] - list of multiaddrs string representation to listen.\n   * @param {Array<string>} [options.announce = []] - list of multiaddrs string representation to announce.\n   */\n  constructor (peerId, { listen = [], announce = [] } = {}) {\n    super()\n\n    this.peerId = peerId\n    this.listen = new Set(listen.map(ma => ma.toString()))\n    this.announce = new Set(announce.map(ma => ma.toString()))\n    this.observed = new Set()\n  }\n\n  /**\n   * Get peer listen multiaddrs.\n   *\n   * @returns {Multiaddr[]}\n   */\n  getListenAddrs () {\n    return Array.from(this.listen).map((a) => new Multiaddr(a))\n  }\n\n  /**\n   * Get peer announcing multiaddrs.\n   *\n   * @returns {Multiaddr[]}\n   */\n  getAnnounceAddrs () {\n    return Array.from(this.announce).map((a) => new Multiaddr(a))\n  }\n\n  /**\n   * Get observed multiaddrs.\n   *\n   * @returns {Array<Multiaddr>}\n   */\n  getObservedAddrs () {\n    return Array.from(this.observed).map((a) => new Multiaddr(a))\n  }\n\n  /**\n   * Add peer observed addresses\n   *\n   * @param {string | Multiaddr} addr\n   */\n  addObservedAddr (addr) {\n    let ma = new Multiaddr(addr)\n    const remotePeer = ma.getPeerId()\n\n    // strip our peer id if it has been passed\n    if (remotePeer) {\n      const remotePeerId = PeerId.createFromB58String(remotePeer)\n\n      // use same encoding for comparison\n      if (remotePeerId.equals(this.peerId)) {\n        ma = ma.decapsulate(new Multiaddr(`/p2p/${this.peerId}`))\n      }\n    }\n\n    const addrString = ma.toString()\n\n    // do not trigger the change:addresses event if we already know about this address\n    if (this.observed.has(addrString)) {\n      return\n    }\n\n    this.observed.add(addrString)\n    this.emit('change:addresses')\n  }\n}\n\nmodule.exports = AddressManager\n"]},"metadata":{},"sourceType":"script"}